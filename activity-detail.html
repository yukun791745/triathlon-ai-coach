<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ã‚¢ã‚¯ãƒ†ã‚£ãƒ“ãƒ†ã‚£è©³ç´° | AI Triathlon Coach</title>
    <!-- Leaflet CSS -->
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            line-height: 1.6;
            color: #333;
            background: linear-gradient(135deg, #dbeafe 0%, #ffffff 50%, #cffafe 100%);
            min-height: 100vh;
            margin: 0;
            padding: 0;
            display: flex;
        }
        
        /* ãƒŠãƒ“ã‚²ãƒ¼ã‚·ãƒ§ãƒ³ */
        .flow-navbar {
            position: fixed;
            top: 0;
            left: 0;
            bottom: 0;
            width: 240px;
            background: linear-gradient(180deg, #667eea 0%, #764ba2 100%);
            box-shadow: 4px 0 20px rgba(0, 0, 0, 0.1);
            z-index: 1000;
            display: flex;
            flex-direction: column;
            padding: 24px 0;
            overflow-y: auto;
        }

        .flow-nav-container {
            display: flex;
            flex-direction: column;
            height: 100%;
        }

        .flow-nav-logo {
            font-size: 1.3rem;
            font-weight: 700;
            color: white;
            text-align: center;
            padding: 0 20px 30px;
            margin-bottom: 20px;
            border-bottom: 2px solid rgba(255, 255, 255, 0.2);
        }

        .flow-nav-steps {
            display: flex;
            flex-direction: column;
            gap: 8px;
            padding: 0 16px;
            flex: 1;
        }

        .flow-nav-step {
            display: flex;
            align-items: center;
            gap: 12px;
            padding: 12px 16px;
            border-radius: 10px;
            font-size: 0.9rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            text-decoration: none;
            color: rgba(255, 255, 255, 0.8);
            white-space: nowrap;
        }

        .flow-nav-step .nav-icon {
            font-size: 1.4rem;
            flex-shrink: 0;
        }

        .flow-nav-step.current {
            background: rgba(255, 255, 255, 0.25);
            color: white;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
        }

        .flow-nav-step.available:hover {
            background: rgba(255, 255, 255, 0.15);
            color: white;
            transform: translateX(5px);
        }

        /* ãƒ¡ã‚¤ãƒ³ã‚³ãƒ³ãƒ†ãƒ³ãƒ„ */
        .content-wrapper {
            margin-left: 240px;
            flex: 1;
            padding: 24px;
            width: calc(100% - 240px);
        }
        
        .container {
            max-width: 1400px;
            margin: 0 auto;
        }
        
        .back-button {
            background: #6c757d;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 0.9em;
            margin-bottom: 16px;
            transition: background 0.2s;
            text-decoration: none;
            display: inline-block;
        }
        
        .back-button:hover {
            background: #5a6268;
        }
        
        /* æ¦‚è¦ãƒ˜ãƒƒãƒ€ãƒ¼ */
        .activity-header {
            background: white;
            border-radius: 16px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.08);
            padding: 24px;
            margin-bottom: 20px;
        }
        
        .activity-title-row {
            display: flex;
            align-items: center;
            gap: 16px;
            margin-bottom: 16px;
        }
        
        .activity-icon {
            font-size: 2.5rem;
        }
        
        .activity-info h1 {
            font-size: 1.8rem;
            color: #1f2937;
            margin-bottom: 4px;
        }
        
        .activity-date {
            color: #6b7280;
            font-size: 0.95rem;
        }
        
        .activity-sport-badge {
            padding: 6px 14px;
            border-radius: 20px;
            font-size: 0.85rem;
            font-weight: 600;
            margin-left: auto;
        }
        
        .activity-sport-badge.swim { background: #dbeafe; color: #1d4ed8; }
        .activity-sport-badge.bike { background: #f3e8ff; color: #7c3aed; }
        .activity-sport-badge.run { background: #dcfce7; color: #16a34a; }
        .activity-sport-badge.other { background: #fef3c7; color: #b45309; }
        
        /* æ¦‚è¦ãƒ¡ãƒˆãƒªã‚¯ã‚¹ */
        .summary-metrics {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(140px, 1fr));
            gap: 16px;
        }
        
        .summary-metric {
            text-align: center;
            padding: 16px 12px;
            background: #f9fafb;
            border-radius: 12px;
        }
        
        .summary-metric-value {
            font-size: 1.8rem;
            font-weight: 700;
            color: #1f2937;
            line-height: 1.2;
        }
        
        .summary-metric-label {
            font-size: 0.75rem;
            color: #6b7280;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin-top: 4px;
        }
        
        /* ã‚°ãƒªãƒƒãƒ‰ãƒ¬ã‚¤ã‚¢ã‚¦ãƒˆ */
        .detail-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin-bottom: 20px;
        }
        
        .detail-grid.full-width {
            grid-template-columns: 1fr;
        }
        
        .panel {
            background: white;
            border-radius: 16px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.08);
            overflow: hidden;
        }
        
        .panel-header {
            padding: 16px 20px;
            border-bottom: 1px solid #f3f4f6;
            display: flex;
            align-items: center;
            justify-content: space-between;
        }
        
        .panel-title {
            font-size: 1rem;
            font-weight: 700;
            color: #1f2937;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .panel-content {
            padding: 20px;
        }
        
        /* åœ°å›³ */
        #routeMap {
            height: 350px;
            border-radius: 8px;
        }
        
        .no-map-message {
            height: 350px;
            display: flex;
            align-items: center;
            justify-content: center;
            color: #9ca3af;
            font-size: 0.95rem;
            background: #f9fafb;
            border-radius: 8px;
        }
        
        /* ã‚°ãƒ©ãƒ• */
        .chart-container {
            position: relative;
            height: 250px;
        }
        
        .chart-container.small {
            height: 180px;
        }
        
        .chart-container.wide {
            height: 300px;
            width: 100%;
        }
        
        /* ã‚¿ãƒ–ãƒœã‚¿ãƒ³ */
        .tab-buttons {
            display: flex;
            gap: 8px;
            flex-wrap: wrap;
        }
        
        .tab-btn {
            padding: 8px 16px;
            border: 2px solid #e5e7eb;
            background: white;
            border-radius: 8px;
            font-size: 0.85rem;
            font-weight: 600;
            color: #6b7280;
            cursor: pointer;
            transition: all 0.2s;
        }
        
        .tab-btn:hover {
            border-color: #667eea;
            color: #667eea;
        }
        
        .tab-btn.active {
            background: #667eea;
            border-color: #667eea;
            color: white;
        }
        
        .chart-tab-content {
            width: 100%;
        }
        
        .sport-metrics-row {
            display: flex;
            gap: 16px;
            margin-bottom: 16px;
            flex-wrap: wrap;
        }
        
        .sport-metric-item {
            background: #f3f4f6;
            padding: 12px 20px;
            border-radius: 10px;
            text-align: center;
            min-width: 120px;
        }
        
        .sport-metric-value {
            font-size: 1.4rem;
            font-weight: 700;
            color: #667eea;
        }
        
        .sport-metric-label {
            font-size: 0.75rem;
            color: #6b7280;
            margin-top: 2px;
        }
        
        /* Zoneåˆ†å¸ƒ */
        .zone-summary {
            display: grid;
            grid-template-columns: repeat(5, 1fr);
            gap: 8px;
            margin-bottom: 16px;
        }
        
        .zone-item {
            text-align: center;
            padding: 12px 8px;
            border-radius: 8px;
            color: white;
            font-size: 0.8rem;
        }
        
        .zone-item.z1 { background: #9ca3af; }
        .zone-item.z2 { background: #3b82f6; }
        .zone-item.z3 { background: #22c55e; }
        .zone-item.z4 { background: #f97316; }
        .zone-item.z5 { background: #ef4444; }
        
        .zone-time {
            font-size: 1.1rem;
            font-weight: 700;
            display: block;
        }
        
        .zone-percent {
            font-size: 0.7rem;
            opacity: 0.9;
        }
        
        /* Lapãƒ†ãƒ¼ãƒ–ãƒ« */
        .lap-table {
            width: 100%;
            border-collapse: collapse;
            font-size: 0.85rem;
        }
        
        .lap-table th {
            background: #f3f4f6;
            padding: 10px 8px;
            text-align: left;
            font-weight: 600;
            color: #4b5563;
        }
        
        .lap-table td {
            padding: 10px 8px;
            border-bottom: 1px solid #f3f4f6;
        }
        
        .lap-table tbody tr:hover {
            background: #f9fafb;
        }
        
        /* AIã‚³ãƒ¼ãƒã‚»ã‚¯ã‚·ãƒ§ãƒ³ */
        .ai-coach-panel {
            background: white;
            border-radius: 16px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.08);
            overflow: hidden;
        }
        
        .ai-coach-header {
            background: linear-gradient(135deg, #ff6b35 0%, #f7931e 100%);
            color: white;
            padding: 16px 20px;
            display: flex;
            align-items: center;
            gap: 12px;
        }
        
        .ai-coach-header h2 {
            font-size: 1.1rem;
            font-weight: 700;
        }
        
        .ai-coach-content {
            padding: 24px;
        }
        
        .ai-comment {
            font-size: 1rem;
            line-height: 1.8;
            color: #374151;
            white-space: pre-wrap;
        }
        
        .ai-loading {
            display: flex;
            align-items: center;
            gap: 12px;
            color: #6b7280;
            padding: 20px 0;
        }
        
        .ai-loading .spinner {
            width: 24px;
            height: 24px;
            border: 3px solid #e5e7eb;
            border-top-color: #f97316;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }
        
        @keyframes spin {
            to { transform: rotate(360deg); }
        }
        
        /* è³ªå•å…¥åŠ› */
        .question-section {
            margin-top: 24px;
            padding-top: 20px;
            border-top: 1px solid #e5e7eb;
        }
        
        .question-section h3 {
            font-size: 0.95rem;
            font-weight: 600;
            color: #374151;
            margin-bottom: 12px;
        }
        
        .question-input-row {
            display: flex;
            gap: 12px;
        }
        
        .question-input {
            flex: 1;
            padding: 12px 16px;
            border: 2px solid #e5e7eb;
            border-radius: 10px;
            font-size: 0.95rem;
            transition: border-color 0.2s;
        }
        
        .question-input:focus {
            outline: none;
            border-color: #f97316;
        }
        
        .question-btn {
            padding: 12px 24px;
            background: linear-gradient(135deg, #ff6b35 0%, #f7931e 100%);
            color: white;
            border: none;
            border-radius: 10px;
            font-weight: 600;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
        }
        
        .question-btn:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(249, 115, 22, 0.4);
        }
        
        .question-btn:disabled {
            opacity: 0.6;
            cursor: not-allowed;
        }
        
        /* ä¼šè©±å±¥æ­´ */
        .chat-history {
            margin-top: 20px;
            max-height: 400px;
            overflow-y: auto;
        }
        
        .chat-message {
            padding: 12px 16px;
            border-radius: 12px;
            margin-bottom: 12px;
        }
        
        .chat-message.user {
            background: #f3f4f6;
            margin-left: 40px;
        }
        
        .chat-message.coach {
            background: #fff7ed;
            margin-right: 40px;
        }
        
        .chat-message-label {
            font-size: 0.75rem;
            font-weight: 600;
            color: #6b7280;
            margin-bottom: 4px;
        }
        
        .chat-message.coach .chat-message-label {
            color: #ea580c;
        }
        
        .chat-message-content {
            font-size: 0.95rem;
            line-height: 1.6;
            white-space: pre-wrap;
        }
        
        /* ã‚»ãƒƒã‚·ãƒ§ãƒ³ã‚¿ã‚¤ãƒ—é¸æŠUI */
        .session-type-selector {
            background: #f8fafc;
            border-radius: 12px;
            padding: 20px;
            margin-bottom: 16px;
        }

        .session-type-header {
            margin-bottom: 16px;
        }

        .session-type-title {
            font-size: 1.1rem;
            font-weight: 700;
            color: #1f2937;
            margin-bottom: 4px;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .session-type-subtitle {
            font-size: 0.9rem;
            color: #6b7280;
        }

        .session-type-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(155px, 1fr));
            gap: 10px;
            margin-bottom: 16px;
        }

        .session-type-btn {
            background: white;
            border: 2px solid #e5e7eb;
            border-radius: 10px;
            padding: 12px 14px;
            text-align: left;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .session-type-btn:hover {
            border-color: #f97316;
            background: #fff7ed;
        }

        .session-type-btn.selected {
            border-color: #f97316;
            background: #ffedd5;
        }

        .session-type-btn-label {
            font-size: 0.9rem;
            font-weight: 600;
            color: #1f2937;
            display: block;
        }

        .session-type-btn-desc {
            font-size: 0.75rem;
            color: #6b7280;
            margin-top: 2px;
        }

        .session-supplement {
            margin-top: 12px;
        }

        .session-supplement-label {
            font-size: 0.85rem;
            font-weight: 600;
            color: #4b5563;
            margin-bottom: 6px;
            display: block;
        }

        .session-supplement-input {
            width: 100%;
            padding: 10px 12px;
            border: 1px solid #d1d5db;
            border-radius: 8px;
            font-size: 0.9rem;
            resize: none;
            font-family: inherit;
        }

        .session-supplement-input:focus {
            outline: none;
            border-color: #f97316;
            box-shadow: 0 0 0 3px rgba(249, 115, 22, 0.1);
        }

        .generate-comment-btn {
            width: 100%;
            background: linear-gradient(135deg, #ff6b35 0%, #f7931e 100%);
            color: white;
            border: none;
            border-radius: 10px;
            padding: 14px 20px;
            font-size: 1rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s ease;
            margin-top: 16px;
        }

        .generate-comment-btn:hover:not(:disabled) {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(249, 115, 22, 0.4);
        }

        .generate-comment-btn:disabled {
            background: #9ca3af;
            cursor: not-allowed;
        }

        .other-input-container {
            display: none;
            margin-top: 12px;
        }

        .other-input-container.visible {
            display: block;
        }

        .other-input {
            width: 100%;
            padding: 10px 12px;
            border: 1px solid #d1d5db;
            border-radius: 8px;
            font-size: 0.9rem;
            font-family: inherit;
        }

        .other-input:focus {
            outline: none;
            border-color: #f97316;
        }

        .ai-comment-result {
            background: white;
            border-radius: 12px;
            padding: 20px;
            border-left: 4px solid #f97316;
        }

        .ai-comment-result-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 12px;
        }

        .ai-comment-result-title {
            font-weight: 700;
            color: #1f2937;
        }

        .ai-comment-result-type {
            font-size: 0.8rem;
            background: #ffedd5;
            color: #ea580c;
            padding: 4px 10px;
            border-radius: 12px;
        }

        .ai-comment-text {
            color: #374151;
            line-height: 1.8;
        }

        .change-type-btn {
            background: #f3f4f6;
            color: #4b5563;
            border: none;
            border-radius: 8px;
            padding: 8px 16px;
            font-size: 0.85rem;
            cursor: pointer;
            margin-top: 16px;
            transition: all 0.2s;
        }

        .change-type-btn:hover {
            background: #e5e7eb;
        }
        
        /* ãƒ­ãƒ¼ãƒ‡ã‚£ãƒ³ã‚° */
        .loading-container {
            text-align: center;
            padding: 60px 20px;
        }
        
        .loading-spinner {
            border: 4px solid #f3f3f3;
            border-radius: 50%;
            border-top: 4px solid #667eea;
            width: 50px;
            height: 50px;
            animation: spin 1s linear infinite;
            margin: 0 auto 20px;
        }
        
        /* ã‚¨ãƒ©ãƒ¼ */
        .error-message {
            background: #fef2f2;
            color: #991b1b;
            padding: 20px;
            border-radius: 12px;
            text-align: center;
        }
        
        /* ç¨®ç›®åˆ¥ãƒ¡ãƒˆãƒªã‚¯ã‚¹ */
        .sport-specific-row {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 16px;
            margin-top: 16px;
        }
        
        .sport-metric-card {
            background: #f9fafb;
            padding: 16px;
            border-radius: 12px;
            text-align: center;
        }
        
        .sport-metric-value {
            font-size: 1.5rem;
            font-weight: 700;
            color: #667eea;
        }
        
        .sport-metric-label {
            font-size: 0.8rem;
            color: #6b7280;
            margin-top: 4px;
        }
        
        /* ãƒ¬ã‚¹ãƒãƒ³ã‚·ãƒ– */
        @media (max-width: 1024px) {
            .detail-grid {
                grid-template-columns: 1fr;
            }
        }
        
        @media (max-width: 768px) {
            body {
                flex-direction: column;
            }

            .flow-navbar {
                position: fixed;
                top: 0;
                left: 0;
                right: 0;
                bottom: auto;
                width: 100%;
                height: auto;
                padding: 12px 0;
            }

            .flow-nav-logo {
                padding: 0 20px 15px;
                margin-bottom: 10px;
                font-size: 1.1rem;
            }

            .flow-nav-steps {
                flex-direction: row;
                overflow-x: auto;
                gap: 5px;
                padding: 0 10px;
            }

            .flow-nav-step {
                padding: 8px 12px;
                font-size: 0.8rem;
            }

            .flow-nav-step span:not(.nav-icon) {
                display: none;
            }

            .content-wrapper {
                margin-left: 0;
                padding: 16px;
                padding-top: 140px;
                width: 100%;
            }
            
            .activity-title-row {
                flex-wrap: wrap;
            }
            
            .activity-sport-badge {
                margin-left: 0;
                margin-top: 8px;
            }
            
            .summary-metrics {
                grid-template-columns: repeat(3, 1fr);
            }
            
            .zone-summary {
                grid-template-columns: repeat(3, 1fr);
            }
            
            .question-input-row {
                flex-direction: column;
            }
        }
        
        /* ã‚¹ã‚¤ãƒ ãƒãƒ£ãƒ¼ãƒˆï¼ˆHTML/CSSç‰ˆï¼‰ */
        .swim-chart-container {
            width: 100%;
            height: 250px;
            display: flex;
            flex-direction: column;
        }
        
        .swim-chart-title {
            text-align: center;
            font-weight: 600;
            font-size: 14px;
            color: #374151;
            margin-bottom: 8px;
        }
        
        .swim-chart-wrapper {
            flex: 1;
            display: flex;
            min-height: 0;
        }
        
        .swim-chart-y-axis {
            width: 60px;
            position: relative;
            padding-right: 8px;
        }
        
        .swim-y-tick {
            position: absolute;
            right: 8px;
            font-size: 11px;
            color: #6b7280;
            transform: translateY(50%);
            white-space: nowrap;
        }
        
        .swim-y-label {
            position: absolute;
            left: 0;
            top: 50%;
            transform: rotate(-90deg) translateX(-50%);
            transform-origin: left center;
            font-size: 11px;
            color: #374151;
            white-space: nowrap;
        }
        
        .swim-chart-area {
            flex: 1;
            position: relative;
            border-left: 1px solid #9ca3af;
            border-bottom: 1px solid #9ca3af;
        }
        
        .swim-chart-grid {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
        }
        
        .swim-grid-line-h {
            position: absolute;
            left: 0;
            right: 0;
            height: 1px;
            background: #e5e7eb;
        }
        
        .swim-grid-line-v {
            position: absolute;
            top: 0;
            bottom: 0;
            width: 1px;
            background: #e5e7eb;
        }
        
        .swim-bars {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
        }
        
        .swim-bar {
            position: absolute;
            bottom: 0;
            background: rgba(59, 130, 246, 0.8);
            border: 1px solid rgba(59, 130, 246, 1);
            border-bottom: none;
            box-sizing: border-box;
            cursor: pointer;
            transition: background 0.15s;
        }
        
        .swim-bar:hover {
            background: rgba(59, 130, 246, 1);
        }
        
        .swim-chart-x-axis {
            height: 35px;
            position: relative;
            margin-left: 60px;
        }
        
        .swim-x-tick {
            position: absolute;
            top: 8px;
            font-size: 11px;
            color: #6b7280;
            transform: translateX(-50%);
        }
        
        .swim-x-label {
            position: absolute;
            bottom: 0;
            left: 50%;
            transform: translateX(-50%);
            font-size: 11px;
            color: #374151;
        }
        
        .swim-tooltip {
            position: fixed;
            background: rgba(0, 0, 0, 0.85);
            color: white;
            padding: 10px 14px;
            border-radius: 6px;
            font-size: 12px;
            line-height: 1.5;
            pointer-events: none;
            z-index: 10000;
            white-space: nowrap;
            display: none;
        }
    
        /* ãƒŠãƒ“ã‚²ãƒ¼ã‚·ãƒ§ãƒ³åŒºåˆ‡ã‚Šç·š */
        .nav-divider {
            height: 1px;
            background: rgba(255, 255, 255, 0.2);
            margin: 12px 16px;
        }
    </style>
</head>
<body>
    <!-- ãƒŠãƒ“ã‚²ãƒ¼ã‚·ãƒ§ãƒ³ -->
    <nav class="flow-navbar">
        <div class="flow-nav-container">
            <div class="flow-nav-logo">AI Triathlon Coach</div>
            <div class="flow-nav-steps">
                <a href="home.html" class="flow-nav-step available">
                    <span class="nav-icon">ğŸ </span>
                    <span>ãƒ›ãƒ¼ãƒ </span>
                </a>
                <a href="index.html" class="flow-nav-step available">
                    <span class="nav-icon">ğŸ¤–</span>
                    <span>AIã‚³ãƒ¼ãƒ</span>
                </a>
                <a href="news.html" class="flow-nav-step available">
                    <span class="nav-icon">ğŸ“°</span>
                    <span>ãƒ‹ãƒ¥ãƒ¼ã‚¹</span>
                </a>
                <a href="race-selection.html" class="flow-nav-step available">
                    <span class="nav-icon">ğŸ¯</span>
                    <span>ãƒ¬ãƒ¼ã‚¹é¸æŠ</span>
                </a>
                <a href="goal-setting.html" class="flow-nav-step available">
                    <span class="nav-icon">ğŸ†</span>
                    <span>ç›®æ¨™è¨­å®š</span>
                </a>
                <a href="training-plan.html" class="flow-nav-step available">
                    <span class="nav-icon">ğŸ“‹</span>
                    <span>è¨ˆç”»</span>
                </a>
                <a href="simulator.html" class="flow-nav-step available">
                    <span class="nav-icon">ğŸ”¬</span>
                    <span>ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚¿ãƒ¼</span>
                </a>
                <a href="data.html" class="flow-nav-step current">
                    <span class="nav-icon">ğŸ“Š</span>
                    <span>é€²æ—</span>
                </a>
                <a href="settings.html" class="flow-nav-step available">
                    <span class="nav-icon">âš™ï¸</span>
                    <span>è¨­å®š</span>
                </a>
                <div class="nav-divider"></div>
                <a href="help.html" class="flow-nav-step available">
                    <span class="nav-icon">â“</span>
                    <span>ãƒ˜ãƒ«ãƒ—</span>
                </a>
            </div>
        </div>
    </nav>

    <div class="content-wrapper">
        <div class="container">
            <button class="back-button" onclick="goBackToData()">â† é€²æ—ãƒšãƒ¼ã‚¸ã«æˆ»ã‚‹</button>
            
            <!-- ãƒ­ãƒ¼ãƒ‡ã‚£ãƒ³ã‚° -->
            <div id="loadingSection" class="loading-container">
                <div class="loading-spinner"></div>
                <p>ã‚¢ã‚¯ãƒ†ã‚£ãƒ“ãƒ†ã‚£ãƒ‡ãƒ¼ã‚¿ã‚’èª­ã¿è¾¼ã¿ä¸­...</p>
            </div>
            
            <!-- ãƒ¡ã‚¤ãƒ³ã‚³ãƒ³ãƒ†ãƒ³ãƒ„ -->
            <div id="mainContent" style="display: none;">
                <!-- æ¦‚è¦ãƒ˜ãƒƒãƒ€ãƒ¼ -->
                <div class="activity-header">
                    <div class="activity-title-row">
                        <span class="activity-icon" id="activityIcon">ğŸƒâ€â™‚ï¸</span>
                        <div class="activity-info">
                            <h1 id="activityName">ã‚¢ã‚¯ãƒ†ã‚£ãƒ“ãƒ†ã‚£å</h1>
                            <div class="activity-date" id="activityDate">æ—¥æ™‚</div>
                        </div>
                        <span class="activity-sport-badge run" id="sportBadge">ãƒ©ãƒ³</span>
                    </div>
                    <div class="summary-metrics" id="summaryMetrics">
                        <!-- å‹•çš„ã«ç”Ÿæˆ -->
                    </div>
                </div>
                
                <!-- åœ°å›³ã¨ã‚¾ãƒ¼ãƒ³åˆ†æ -->
                <div class="detail-grid">
                    <div class="panel">
                        <div class="panel-header">
                            <h2 class="panel-title">ğŸ—ºï¸ ãƒ«ãƒ¼ãƒˆãƒãƒƒãƒ—</h2>
                        </div>
                        <div class="panel-content">
                            <div id="mapContainer">
                                <div id="routeMap"></div>
                            </div>
                        </div>
                    </div>
                    
                    <div class="panel">
                        <div class="panel-header">
                            <h2 class="panel-title">ğŸ’“ å¿ƒæ‹ã‚¾ãƒ¼ãƒ³åˆ†å¸ƒ</h2>
                        </div>
                        <div class="panel-content">
                            <div class="zone-summary" id="zoneSummary">
                                <!-- å‹•çš„ã«ç”Ÿæˆ -->
                            </div>
                            <div class="chart-container small">
                                <canvas id="zoneChart"></canvas>
                            </div>
                        </div>
                    </div>
                </div>
                
                <!-- æ™‚ç³»åˆ—ã‚°ãƒ©ãƒ•ï¼ˆã‚¿ãƒ–åˆ‡ã‚Šæ›¿ãˆï¼‰ -->
                <div class="detail-grid full-width">
                    <div class="panel">
                        <div class="panel-header">
                            <h2 class="panel-title">ğŸ“ˆ æ™‚ç³»åˆ—ãƒ‡ãƒ¼ã‚¿</h2>
                            <div class="tab-buttons" id="chartTabs">
                                <button class="tab-btn" data-tab="hr">ğŸ’“ å¿ƒæ‹æ•°</button>
                                <button class="tab-btn active" data-tab="pace">â±ï¸ ãƒšãƒ¼ã‚¹</button>
                                <button class="tab-btn" data-tab="gap" id="gapTab" style="display: none;">ğŸ“ GAP</button>
                                <button class="tab-btn" data-tab="cadence" id="cadenceTab" style="display: none;">ğŸ”„ ã‚±ã‚¤ãƒ‡ãƒ³ã‚¹</button>
                                <button class="tab-btn" data-tab="power" id="powerTab" style="display: none;">âš¡ ãƒ‘ãƒ¯ãƒ¼</button>
                            </div>
                        </div>
                        <div class="panel-content">
                            <div class="chart-tab-content" id="hrTabContent" style="display: none;">
                                <div class="chart-container wide">
                                    <canvas id="hrChart"></canvas>
                                </div>
                            </div>
                            <div class="chart-tab-content" id="paceTabContent">
                                <div class="chart-container wide">
                                    <canvas id="paceChart"></canvas>
                                </div>
                            </div>
                            <div class="chart-tab-content" id="gapTabContent" style="display: none;">
                                <div class="sport-metrics-row" id="gapMetrics"></div>
                                <div class="chart-container wide">
                                    <canvas id="gapChart"></canvas>
                                </div>
                            </div>
                            <div class="chart-tab-content" id="cadenceTabContent" style="display: none;">
                                <div class="sport-metrics-row" id="cadenceMetrics"></div>
                                <div class="chart-container wide">
                                    <canvas id="cadenceChart"></canvas>
                                </div>
                            </div>
                            <div class="chart-tab-content" id="powerTabContent" style="display: none;">
                                <div class="sport-metrics-row" id="powerMetrics"></div>
                                <div class="chart-container wide">
                                    <canvas id="powerChart"></canvas>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
                
                <!-- Lapãƒ‡ãƒ¼ã‚¿ -->
                <div class="detail-grid full-width" id="lapSection" style="display: none;">
                    <div class="panel">
                        <div class="panel-header">
                            <h2 class="panel-title">ğŸ“‹ Lapè©³ç´°</h2>
                        </div>
                        <div class="panel-content">
                            <div style="max-height: 300px; overflow-y: auto;">
                                <table class="lap-table" id="lapTable">
                                    <!-- å‹•çš„ã«ç”Ÿæˆ -->
                                </table>
                            </div>
                        </div>
                    </div>
                </div>
                
                <!-- AIã‚³ãƒ¼ãƒã‚³ãƒ¡ãƒ³ãƒˆ -->
                <div class="ai-coach-panel">
                    <div class="ai-coach-header">
                        <span style="font-size: 1.5rem;">ğŸ¤–</span>
                        <h2>AIã‚³ãƒ¼ãƒ</h2>
                    </div>
                    <div class="ai-coach-content">
                        
                        <!-- ã‚»ãƒƒã‚·ãƒ§ãƒ³ã‚¿ã‚¤ãƒ—é¸æŠ -->
                        <div class="session-type-selector" id="sessionTypeSelector">
                            <div class="session-type-header">
                                <div class="session-type-title">ğŸ¯ ä»Šæ—¥ã®ãƒˆãƒ¬ãƒ¼ãƒ‹ãƒ³ã‚°ã®ç›®çš„ã¯ï¼Ÿ</div>
                                <div class="session-type-subtitle">æ•™ãˆã¦ã„ãŸã ã‘ã‚Œã°ã€AIã‚³ãƒ¼ãƒãŒã‚ˆã‚Šçš„ç¢ºãªã‚³ãƒ¡ãƒ³ãƒˆã‚’ãŠå±Šã‘ã—ã¾ã™</div>
                            </div>
                            
                            <div class="session-type-grid" id="sessionTypeGrid">
                                <!-- JavaScriptã§å‹•çš„ã«ç”Ÿæˆ -->
                            </div>
                            
                            <!-- ãã®ä»–é¸æŠæ™‚ã®å…¥åŠ›æ¬„ -->
                            <div class="other-input-container" id="otherInputContainer">
                                <input type="text" class="other-input" id="otherInput" 
                                       placeholder="ä¾‹ï¼šå‰åŠã‚­ãƒƒã‚¯ç·´ç¿’ã€å¾ŒåŠãƒ—ãƒ«ãƒ–ã‚¤ã§1500m">
                            </div>
                            
                            <!-- è£œè¶³å…¥åŠ› -->
                            <div class="session-supplement">
                                <label class="session-supplement-label">ğŸ’¬ è£œè¶³ï¼ˆä»»æ„ï¼‰</label>
                                <textarea class="session-supplement-input" id="sessionSupplement" rows="2"
                                          placeholder="ä¾‹ï¼šå¾ŒåŠãƒ“ãƒ«ãƒ‰ã‚¢ãƒƒãƒ—ã‚’æ„è­˜ã—ãŸã€æš‘ãã¦ãƒšãƒ¼ã‚¹ã‚’æŠ‘ãˆãŸã€ãªã©"></textarea>
                            </div>
                            
                            <button class="generate-comment-btn" id="generateCommentBtn" disabled>
                                AIã‚³ãƒ¼ãƒã®ã‚³ãƒ¡ãƒ³ãƒˆã‚’è¦‹ã‚‹
                            </button>
                        </div>
                        
                        <!-- ãƒ­ãƒ¼ãƒ‡ã‚£ãƒ³ã‚° -->
                        <div id="aiCommentLoading" class="ai-loading" style="display: none;">
                            <div class="spinner"></div>
                            <span>AIã‚³ãƒ¼ãƒãŒã‚¢ã‚¯ãƒ†ã‚£ãƒ“ãƒ†ã‚£ã‚’åˆ†æä¸­...</span>
                        </div>
                        
                        <!-- ã‚³ãƒ¡ãƒ³ãƒˆçµæœ -->
                        <div id="aiCommentResult" style="display: none;">
                            <div class="ai-comment-result">
                                <div class="ai-comment-result-header">
                                    <span class="ai-comment-result-title">AIã‚³ãƒ¼ãƒã®ã‚³ãƒ¡ãƒ³ãƒˆ</span>
                                    <span class="ai-comment-result-type" id="commentSessionType"></span>
                                </div>
                                <div class="ai-comment-text" id="aiCommentText"></div>
                                <button class="change-type-btn" onclick="changeSessionType()">ğŸ”„ ã‚»ãƒƒã‚·ãƒ§ãƒ³ã‚¿ã‚¤ãƒ—ã‚’å¤‰æ›´</button>
                            </div>
                            
                            <!-- è³ªå•ã‚»ã‚¯ã‚·ãƒ§ãƒ³ -->
                            <div class="question-section">
                                <h3>ğŸ’¬ ã‚³ãƒ¼ãƒã«è³ªå•ã™ã‚‹</h3>
                                <div class="question-input-row">
                                    <input type="text" class="question-input" id="questionInput" 
                                        placeholder="ä¾‹: æ¬¡å›ã®ãƒˆãƒ¬ãƒ¼ãƒ‹ãƒ³ã‚°ã§ã¯ã©ã“ã‚’æ„è­˜ã™ã¹ãï¼Ÿ">
                                    <button class="question-btn" id="askBtn" onclick="askQuestion()">è³ªå•ã™ã‚‹</button>
                                </div>
                                <div class="chat-history" id="chatHistory" style="display: none;">
                                    <!-- ä¼šè©±å±¥æ­´ -->
                                </div>
                            </div>
                        </div>
                        
                    </div>
                </div>
            </div>
            
            <!-- ã‚¨ãƒ©ãƒ¼ -->
            <div id="errorSection" style="display: none;">
                <div class="error-message">
                    <h3>âŒ ãƒ‡ãƒ¼ã‚¿ã®å–å¾—ã«å¤±æ•—ã—ã¾ã—ãŸ</h3>
                    <p id="errorMessage">ã‚¨ãƒ©ãƒ¼ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸</p>
                </div>
            </div>
        </div>
    </div>

    <!-- Scripts -->
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.0/dist/chart.umd.min.js"></script>
    
    <script>
        // ===== ã‚°ãƒ­ãƒ¼ãƒãƒ«å¤‰æ•° =====
        let currentActivity = null;
        let streamData = null;
        let trainingStatus = null;
        let map = null;
        let charts = {};
        let selectedSessionType = null;
        let conversationHistory = [];
        
        // ===== ã‚»ãƒƒã‚·ãƒ§ãƒ³ã‚¿ã‚¤ãƒ—å®šç¾© =====
        const SESSION_TYPES = {
            swim: [
                { id: 'swim_drill_focus', label: 'ãƒ†ã‚¯ãƒ‹ãƒƒã‚¯é‡è¦–', description: 'ãƒ‰ãƒªãƒ«ä¸­å¿ƒ' },
                { id: 'swim_drill_endurance', label: 'ãƒ‰ãƒªãƒ«ï¼‹æœ‰é…¸ç´ ', description: 'ãƒ‰ãƒªãƒ«å¾Œã«Z2' },
                { id: 'swim_drill_speed', label: 'ãƒ‰ãƒªãƒ«ï¼‹ã‚¹ãƒ”ãƒ¼ãƒ‰', description: 'ãƒ‰ãƒªãƒ«å¾Œã«é«˜å¼·åº¦' },
                { id: 'swim_endurance', label: 'æœ‰é…¸ç´ ï¼ˆæ³³ãè¾¼ã¿ï¼‰', description: 'è·é›¢é‡è¦–' },
                { id: 'swim_threshold', label: 'é–¾å€¤/CSSãƒšãƒ¼ã‚¹', description: 'ãƒ†ãƒ³ãƒã‚¹ã‚¤ãƒ ' },
                { id: 'swim_interval', label: 'é«˜å¼·åº¦ã‚¤ãƒ³ã‚¿ãƒ¼ãƒãƒ«', description: 'ã‚¹ãƒ—ãƒªãƒ³ãƒˆç­‰' },
                { id: 'swim_ow', label: 'ã‚ªãƒ¼ãƒ—ãƒ³ã‚¦ã‚©ãƒ¼ã‚¿ãƒ¼', description: 'æµ·ãƒ»æ¹–' },
                { id: 'swim_recovery', label: 'ãƒªã‚«ãƒãƒªãƒ¼', description: 'è»½ãæµã™' },
                { id: 'swim_test', label: 'ãƒ†ã‚¹ãƒˆ/TT', description: 'CSSæ¸¬å®šç­‰' }
            ],
            bike: [
                { id: 'bike_endurance', label: 'æœ‰é…¸ç´ ã‚¨ãƒ³ãƒ‡ãƒ¥ãƒ©ãƒ³ã‚¹', description: 'Z2ä¸­å¿ƒ' },
                { id: 'bike_tempo', label: 'ãƒ†ãƒ³ãƒ/SST', description: 'FTP88-94%' },
                { id: 'bike_threshold', label: 'é–¾å€¤/FTPèµ°', description: 'FTPä»˜è¿‘æŒç¶š' },
                { id: 'bike_vo2max', label: 'VO2max/é«˜å¼·åº¦', description: 'é«˜å¼·åº¦ã‚¤ãƒ³ã‚¿ãƒ¼ãƒãƒ«' },
                { id: 'bike_technique_interval', label: 'ãƒ†ã‚¯ãƒ‹ãƒƒã‚¯ï¼‹ã‚¤ãƒ³ã‚¿ãƒ¼ãƒãƒ«', description: 'ãƒ‰ãƒªãƒ«ï¼‹é«˜å¼·åº¦' },
                { id: 'bike_zwift_workout', label: 'Zwiftãƒ¯ãƒ¼ã‚¯ã‚¢ã‚¦ãƒˆ', description: 'æ§‹é€ åŒ–ãƒ¡ãƒ‹ãƒ¥ãƒ¼' },
                { id: 'bike_hill', label: 'ãƒ’ãƒ«ã‚¯ãƒ©ã‚¤ãƒ ', description: 'ç™»å‚' },
                { id: 'bike_brick', label: 'ãƒ–ãƒªãƒƒã‚¯ï¼ˆâ†’ãƒ©ãƒ³ï¼‰', description: 'ãƒã‚¤ã‚¯å¾Œãƒ©ãƒ³' },
                { id: 'bike_recovery', label: 'ãƒªã‚«ãƒãƒªãƒ¼', description: 'è»½ãå›ã™' },
                { id: 'bike_test', label: 'ãƒ†ã‚¹ãƒˆ/TT', description: 'FTPæ¸¬å®šç­‰' }
            ],
            run: [
                { id: 'run_easy', label: 'ã‚¤ãƒ¼ã‚¸ãƒ¼/ã‚¸ãƒ§ã‚°', description: 'ä¼šè©±ãƒšãƒ¼ã‚¹' },
                { id: 'run_long', label: 'ãƒ­ãƒ³ã‚°èµ°', description: 'é•·è·é›¢' },
                { id: 'run_tempo', label: 'ãƒ†ãƒ³ãƒ/é–¾å€¤èµ°', description: 'LTãƒšãƒ¼ã‚¹' },
                { id: 'run_interval', label: 'ã‚¤ãƒ³ã‚¿ãƒ¼ãƒãƒ«', description: 'é«˜å¼·åº¦åå¾©' },
                { id: 'run_fartlek', label: 'ãƒ•ã‚¡ãƒ«ãƒˆãƒ¬ã‚¯', description: 'ãƒšãƒ¼ã‚¹å¤‰åŒ–' },
                { id: 'run_hill', label: 'å‚é“ãƒˆãƒ¬ãƒ¼ãƒ‹ãƒ³ã‚°', description: 'å‚ãƒ€ãƒƒã‚·ãƒ¥ç­‰' },
                { id: 'run_brick', label: 'ãƒ–ãƒªãƒƒã‚¯ï¼ˆãƒã‚¤ã‚¯å¾Œï¼‰', description: 'ãƒã‚¤ã‚¯ç›´å¾Œ' },
                { id: 'run_recovery', label: 'ãƒªã‚«ãƒãƒªãƒ¼', description: 'éå¸¸ã«è»½ã' },
                { id: 'run_test', label: 'ãƒ†ã‚¹ãƒˆ/TT', description: 'ã‚¿ã‚¤ãƒ è¨ˆæ¸¬' }
            ],
            common: [
                { id: 'race', label: 'ãƒ¬ãƒ¼ã‚¹/å¤§ä¼š', description: 'æœ¬ç•ª' },
                { id: 'other', label: 'ãã®ä»–', description: 'ä¸Šè¨˜ä»¥å¤–' }
            ]
        };
        
        // ===== ãƒˆãƒ¼ã‚¯ãƒ³ç®¡ç† =====
        async function ensureValidToken() {
            const authData = localStorage.getItem('strava_auth');
            if (!authData) {
                console.error('No auth data found');
                return null;
            }
            
            const auth = JSON.parse(authData);
            
            // æœ‰åŠ¹æœŸé™ã‚’ãƒã‚§ãƒƒã‚¯ï¼ˆ5åˆ†ã®ä½™è£•ã‚’æŒãŸã›ã‚‹ï¼‰
            const now = Math.floor(Date.now() / 1000);
            const expiresAt = auth.expires_at || 0;
            
            if (now < expiresAt - 300) {
                // ã¾ã æœ‰åŠ¹
                return auth.access_token;
            }
            
            // æœŸé™åˆ‡ã‚Œã¾ãŸã¯é–“ã‚‚ãªãåˆ‡ã‚Œã‚‹ - ãƒªãƒ•ãƒ¬ãƒƒã‚·ãƒ¥ãŒå¿…è¦
            console.log('Token expired or expiring soon, refreshing...');
            
            if (!auth.refresh_token) {
                console.error('No refresh token found');
                alert('ã‚»ãƒƒã‚·ãƒ§ãƒ³ã®æœ‰åŠ¹æœŸé™ãŒåˆ‡ã‚Œã¾ã—ãŸã€‚å†åº¦ãƒ­ã‚°ã‚¤ãƒ³ã—ã¦ãã ã•ã„ã€‚');
                window.location.href = 'index.html';
                return null;
            }
            
            try {
                const response = await fetch('/.netlify/functions/strava-refresh-token', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        refresh_token: auth.refresh_token
                    })
                });
                
                if (!response.ok) {
                    throw new Error('Token refresh failed');
                }
                
                const newTokenData = await response.json();
                
                // æ–°ã—ã„ãƒˆãƒ¼ã‚¯ãƒ³ã‚’ä¿å­˜
                const updatedAuth = {
                    ...auth,
                    access_token: newTokenData.access_token,
                    refresh_token: newTokenData.refresh_token,
                    expires_at: newTokenData.expires_at
                };
                localStorage.setItem('strava_auth', JSON.stringify(updatedAuth));
                
                console.log('Token refreshed successfully');
                return newTokenData.access_token;
                
            } catch (error) {
                console.error('Token refresh error:', error);
                alert('ã‚»ãƒƒã‚·ãƒ§ãƒ³ã®æ›´æ–°ã«å¤±æ•—ã—ã¾ã—ãŸã€‚å†åº¦ãƒ­ã‚°ã‚¤ãƒ³ã—ã¦ãã ã•ã„ã€‚');
                window.location.href = 'index.html';
                return null;
            }
        }

        // 401ã‚¨ãƒ©ãƒ¼æ™‚ã«ãƒªãƒ•ãƒ¬ãƒƒã‚·ãƒ¥ã—ã¦å†è©¦è¡Œã™ã‚‹ãƒ©ãƒƒãƒ‘ãƒ¼
        async function fetchWithTokenRefresh(url, options, bodyWithoutToken) {
            let response = await fetch(url, options);
            
            if (response.status === 401) {
                console.log('Got 401, attempting token refresh...');
                
                const authData = localStorage.getItem('strava_auth');
                if (authData) {
                    const auth = JSON.parse(authData);
                    
                    if (auth.refresh_token) {
                        try {
                            const refreshResponse = await fetch('/.netlify/functions/strava-refresh-token', {
                                method: 'POST',
                                headers: { 'Content-Type': 'application/json' },
                                body: JSON.stringify({ refresh_token: auth.refresh_token })
                            });
                            
                            if (refreshResponse.ok) {
                                const newTokenData = await refreshResponse.json();
                                
                                // æ–°ã—ã„ãƒˆãƒ¼ã‚¯ãƒ³ã‚’ä¿å­˜
                                localStorage.setItem('strava_auth', JSON.stringify({
                                    ...auth,
                                    access_token: newTokenData.access_token,
                                    refresh_token: newTokenData.refresh_token,
                                    expires_at: newTokenData.expires_at
                                }));
                                
                                // æ–°ã—ã„ãƒˆãƒ¼ã‚¯ãƒ³ã§å†è©¦è¡Œ
                                const newBody = { ...bodyWithoutToken, token: newTokenData.access_token };
                                response = await fetch(url, {
                                    ...options,
                                    body: JSON.stringify(newBody)
                                });
                                
                                console.log('Retry with new token successful');
                            }
                        } catch (error) {
                            console.error('Retry after refresh failed:', error);
                        }
                    }
                }
            }
            
            return response;
        }

        
        // ===== åˆæœŸåŒ– =====
        document.addEventListener('DOMContentLoaded', async () => {
            const activityId = getActivityId();
            
            if (!activityId) {
                showError('ã‚¢ã‚¯ãƒ†ã‚£ãƒ“ãƒ†ã‚£IDãŒæŒ‡å®šã•ã‚Œã¦ã„ã¾ã›ã‚“');
                return;
            }
            
            try {
                await loadActivityData(activityId);
            } catch (error) {
                console.error('Error loading activity:', error);
                showError(error.message);
            }
        });
        
        function getActivityId() {
            const urlParams = new URLSearchParams(window.location.search);
            return urlParams.get('id');
        }
        
        // ===== ãƒ‡ãƒ¼ã‚¿èª­ã¿è¾¼ã¿ =====
        async function loadActivityData(activityId) {
            // ã‚­ãƒ£ãƒƒã‚·ãƒ¥ã‹ã‚‰ã‚¢ã‚¯ãƒ†ã‚£ãƒ“ãƒ†ã‚£ã‚’å–å¾—
            const cachedActivities = localStorage.getItem('strava_activities');
            if (!cachedActivities) {
                throw new Error('ã‚¢ã‚¯ãƒ†ã‚£ãƒ“ãƒ†ã‚£ãƒ‡ãƒ¼ã‚¿ãŒã‚ã‚Šã¾ã›ã‚“ã€‚é€²æ—ãƒšãƒ¼ã‚¸ã§ãƒ‡ãƒ¼ã‚¿ã‚’åŒæœŸã—ã¦ãã ã•ã„ã€‚');
            }
            
            const activities = JSON.parse(cachedActivities);
            currentActivity = activities.find(a => a.id.toString() === activityId.toString());
            
            if (!currentActivity) {
                throw new Error('æŒ‡å®šã•ã‚ŒãŸã‚¢ã‚¯ãƒ†ã‚£ãƒ“ãƒ†ã‚£ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“');
            }
            
            // ãƒˆãƒ¬ãƒ¼ãƒ‹ãƒ³ã‚°ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ã‚’è¨ˆç®—
            trainingStatus = calculateTrainingStatus(activities);
            
            // åŸºæœ¬æƒ…å ±ã‚’è¡¨ç¤º
            renderActivityHeader();
            renderSummaryMetrics();
            
            // Streams APIã§ãƒ‡ãƒ¼ã‚¿ã‚’å–å¾—
            await loadStreamData(activityId);
            
            // Laps APIã§ãƒ©ãƒƒãƒ—ãƒ‡ãƒ¼ã‚¿ã‚’å–å¾—ï¼ˆã‚¹ã‚¤ãƒ ãªã©ï¼‰
            await loadLapData(activityId);
            
            // ã‚¹ã‚¤ãƒ ã®å ´åˆã€ã‚¹ãƒˆãƒ­ãƒ¼ã‚¯ãƒ¡ãƒˆãƒªãƒƒã‚¯ã‚’æ¦‚è¦ã«è¿½åŠ 
            addSwimStrokeMetrics();
            
            // UIã‚’è¡¨ç¤º
            document.getElementById('loadingSection').style.display = 'none';
            document.getElementById('mainContent').style.display = 'block';
            
            // ã‚°ãƒ©ãƒ•ã‚’æç”»
            renderCharts();
            
            // AIã‚³ãƒ¼ãƒã®ã‚»ãƒƒã‚·ãƒ§ãƒ³ã‚¿ã‚¤ãƒ—é¸æŠUIã‚’åˆæœŸåŒ–
            initSessionTypeSelector();
        }
        
        async function loadStreamData(activityId) {
            const authData = localStorage.getItem('strava_auth');
            if (!authData) {
                console.log('No auth data, skipping streams');
                return;
            }
            
            try {
                // ã¾ãšãƒˆãƒ¼ã‚¯ãƒ³ãŒæœ‰åŠ¹ã‹ç¢ºèª
                const token = await ensureValidToken();
                if (!token) return;
                
                const bodyData = { activityId: activityId };
                
                const response = await fetchWithTokenRefresh(
                    '/.netlify/functions/strava-streams',
                    {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ token: token, ...bodyData })
                    },
                    bodyData
                );
                
                if (response.ok) {
                    const data = await response.json();
                    if (data.hasStreams) {
                        streamData = data.streams;
                        console.log('Stream data loaded:', Object.keys(streamData));
                    }
                } else {
                    console.error('Stream API error:', response.status);
                }
            } catch (error) {
                console.error('Failed to load streams:', error);
            }
        }
        
        // ãƒ©ãƒƒãƒ—ãƒ‡ãƒ¼ã‚¿ã‚’å–å¾—ï¼ˆFORM/Garminãªã©ã‹ã‚‰ã®ã‚¹ã‚¤ãƒ ãƒ‡ãƒ¼ã‚¿ç”¨ï¼‰
        async function loadLapData(activityId) {
            const authData = localStorage.getItem('strava_auth');
            if (!authData) {
                console.log('No auth data, skipping laps');
                return;
            }
            
            try {
                // ã¾ãšãƒˆãƒ¼ã‚¯ãƒ³ãŒæœ‰åŠ¹ã‹ç¢ºèª
                const token = await ensureValidToken();
                if (!token) return;
                
                const bodyData = { activityId: activityId };
                
                const response = await fetchWithTokenRefresh(
                    '/.netlify/functions/strava-laps',
                    {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ token: token, ...bodyData })
                    },
                    bodyData
                );
                
                if (response.ok) {
                    const data = await response.json();
                    console.log('Lap API response:', data);
                    
                    if (data.laps && data.laps.length > 0) {
                        currentActivity.laps = data.laps;
                        console.log('Lap data loaded:', data.laps.length, 'laps');
                        if (data.analysis) {
                            console.log('Lap analysis:', data.analysis);
                        }
                    } else {
                        console.log('No laps in response');
                    }
                } else {
                    console.error('Lap API error:', response.status);
                }
            } catch (error) {
                console.error('Failed to load laps:', error);
            }
        }
        
        // ===== ãƒˆãƒ¬ãƒ¼ãƒ‹ãƒ³ã‚°ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹è¨ˆç®— =====
        function calculateTrainingStatus(activities) {
            if (activities.length === 0) return null;
            
            const dailyTss = {};
            activities.forEach(activity => {
                const date = activity.start_date.split('T')[0];
                if (!dailyTss[date]) dailyTss[date] = 0;
                dailyTss[date] += activity.tss || 0;
            });
            
            const today = new Date();
            const days = [];
            for (let i = 89; i >= 0; i--) {
                const d = new Date(today);
                d.setDate(d.getDate() - i);
                const dateStr = d.toISOString().split('T')[0];
                days.push({ date: dateStr, tss: dailyTss[dateStr] || 0 });
            }
            
            const ctlFactor = 1 - Math.exp(-1 / 42);
            const atlFactor = 1 - Math.exp(-1 / 7);
            
            let ctl = 0, atl = 0, prevCtl = 0;
            
            days.forEach((day, i) => {
                ctl = ctl + (day.tss - ctl) * ctlFactor;
                atl = atl + (day.tss - atl) * atlFactor;
                if (i === days.length - 8) prevCtl = ctl;
            });
            
            return {
                ctl: Math.round(ctl * 10) / 10,
                atl: Math.round(atl * 10) / 10,
                tsb: Math.round((ctl - atl) * 10) / 10,
                ctlTrend: Math.round((ctl - prevCtl) * 10) / 10
            };
        }
        
        // ===== ãƒ˜ãƒƒãƒ€ãƒ¼æç”» =====
        function renderActivityHeader() {
            const sportType = currentActivity.sport_type || currentActivity.type;
            const sportCategory = getSportCategory(sportType);
            
            document.getElementById('activityIcon').textContent = getActivityIcon(sportType);
            document.getElementById('activityName').textContent = currentActivity.name || 'ç„¡é¡Œã®ã‚¢ã‚¯ãƒ†ã‚£ãƒ“ãƒ†ã‚£';
            document.getElementById('activityDate').textContent = new Date(currentActivity.start_date).toLocaleString('ja-JP', {
                year: 'numeric', month: 'long', day: 'numeric',
                weekday: 'short', hour: '2-digit', minute: '2-digit'
            });
            
            const badge = document.getElementById('sportBadge');
            badge.textContent = getSportLabel(sportType);
            badge.className = `activity-sport-badge ${sportCategory}`;
        }
        
        function renderSummaryMetrics() {
            const sportType = currentActivity.sport_type || currentActivity.type;
            const sportCategory = getSportCategory(sportType);
            
            let html = '';
            
            // è·é›¢
            if (currentActivity.distance) {
                html += createMetricCard((currentActivity.distance / 1000).toFixed(2), 'km', 'è·é›¢');
            }
            
            // æ™‚é–“
            html += createMetricCard(formatDuration(currentActivity.moving_time), '', 'æ™‚é–“');
            
            // ãƒšãƒ¼ã‚¹/é€Ÿåº¦
            if (currentActivity.average_speed) {
                if (sportCategory === 'swim') {
                    html += createMetricCard(formatSwimPace(currentActivity.average_speed), '/100m', 'ãƒšãƒ¼ã‚¹');
                } else if (sportCategory === 'bike') {
                    html += createMetricCard((currentActivity.average_speed * 3.6).toFixed(1), 'km/h', 'å¹³å‡é€Ÿåº¦');
                } else {
                    html += createMetricCard(formatRunPace(currentActivity.average_speed), '/km', 'ãƒšãƒ¼ã‚¹');
                }
            }
            
            // å¿ƒæ‹
            if (currentActivity.average_heartrate) {
                html += createMetricCard(Math.round(currentActivity.average_heartrate), 'bpm', 'å¹³å‡å¿ƒæ‹');
            }
            
            // ãƒã‚¤ã‚¯: ãƒ‘ãƒ¯ãƒ¼ãƒ¡ãƒˆãƒªãƒƒã‚¯ï¼ˆå¿ƒæ‹ã¨ç²å¾—æ¨™é«˜ã®é–“ï¼‰
            if (sportCategory === 'bike') {
                if (currentActivity.average_watts) {
                    html += createMetricCard(Math.round(currentActivity.average_watts), 'W', 'å¹³å‡ãƒ‘ãƒ¯ãƒ¼');
                }
                if (currentActivity.weighted_average_watts) {
                    html += createMetricCard(Math.round(currentActivity.weighted_average_watts), 'W', 'NP');
                }
                if (currentActivity.average_watts && currentActivity.weighted_average_watts) {
                    const vi = (currentActivity.weighted_average_watts / currentActivity.average_watts).toFixed(2);
                    html += createMetricCard(vi, '', 'VI');
                }
            }
            
            // ãƒ©ãƒ³: ãƒ”ãƒƒãƒã¨ã‚¹ãƒˆãƒ©ã‚¤ãƒ‰ï¼ˆå¿ƒæ‹ã¨ç²å¾—æ¨™é«˜ã®é–“ï¼‰
            if (sportCategory === 'run' && currentActivity.average_cadence) {
                // ãƒ”ãƒƒãƒï¼ˆStravaã¯ç‰‡è¶³åˆ†ãªã®ã§2å€ï¼‰
                const avgPitch = Math.round(currentActivity.average_cadence * 2);
                html += createMetricCard(avgPitch, 'spm', 'ãƒ”ãƒƒãƒ');
                
                // ã‚¹ãƒˆãƒ©ã‚¤ãƒ‰é•· = é€Ÿåº¦(m/min) / ãƒ”ãƒƒãƒ(steps/min)
                // é€Ÿåº¦ = average_speed (m/s) * 60 = m/min
                if (currentActivity.average_speed) {
                    const speedMPerMin = currentActivity.average_speed * 60;
                    const stride = speedMPerMin / avgPitch;
                    html += createMetricCard(stride.toFixed(2), 'm', 'ã‚¹ãƒˆãƒ©ã‚¤ãƒ‰');
                }
            }
            
            // ç²å¾—æ¨™é«˜ï¼ˆTSSã®å‰ï¼‰
            if (currentActivity.total_elevation_gain && currentActivity.total_elevation_gain > 10) {
                html += createMetricCard(Math.round(currentActivity.total_elevation_gain), 'm', 'ç²å¾—æ¨™é«˜');
            }
            
            // TSS
            if (currentActivity.tss) {
                html += createMetricCard(currentActivity.tss, '', 'TSS');
            }
            
            document.getElementById('summaryMetrics').innerHTML = html;
        }
        
        function createMetricCard(value, unit, label) {
            return `
                <div class="summary-metric">
                    <div class="summary-metric-value">${value}<small style="font-size: 0.6em; font-weight: 400;">${unit}</small></div>
                    <div class="summary-metric-label">${label}</div>
                </div>
            `;
        }
        
        // ã‚¹ã‚¤ãƒ ç”¨ã®ã‚¹ãƒˆãƒ­ãƒ¼ã‚¯ãƒ¡ãƒˆãƒªãƒƒã‚¯ã‚’æ¦‚è¦ã«è¿½åŠ 
        function addSwimStrokeMetrics() {
            const sportCategory = getSportCategory(currentActivity.sport_type || currentActivity.type);
            if (sportCategory !== 'swim' || !currentActivity.laps || currentActivity.laps.length === 0) {
                console.log('addSwimStrokeMetrics: ã‚¹ã‚¤ãƒ ã§ã¯ãªã„ã‹ãƒ©ãƒƒãƒ—ãƒ‡ãƒ¼ã‚¿ãŒã‚ã‚Šã¾ã›ã‚“');
                return;
            }
            
            console.log('addSwimStrokeMetrics: è¨ˆç®—é–‹å§‹', currentActivity.laps.length, 'ãƒ©ãƒƒãƒ—');
            
            // æœ‰åŠ¹ãªãƒ©ãƒƒãƒ—ã‚’æŠ½å‡ºï¼ˆRESTã‚’é™¤ãï¼‰
            let totalDistance = 0;
            let totalStrokes = 0;
            let totalTime = 0; // ç§’
            
            currentActivity.laps.forEach((lap, i) => {
                const distance = lap.distance || 0;
                const movingTime = lap.moving_time || 0;
                const cadence = lap.average_cadence;
                
                // ãƒšãƒ¼ã‚¹è¨ˆç®—
                let paceSeconds = null;
                if (lap.average_speed && lap.average_speed > 0) {
                    paceSeconds = 100 / lap.average_speed;
                } else if (movingTime > 0 && distance > 0) {
                    paceSeconds = (movingTime / distance) * 100;
                }
                
                // ãƒ¬ã‚¹ãƒˆåˆ¤å®š
                const isRest = distance === 0 ||
                               movingTime === 0 || 
                               movingTime < 10 ||
                               (paceSeconds && paceSeconds > 300) ||
                               (paceSeconds && paceSeconds < 60);
                
                if (!isRest && distance > 0 && movingTime > 0) {
                    // ã‚¹ãƒˆãƒ­ãƒ¼ã‚¯æ•°ã‚’è¨ˆç®—ï¼ˆcadenceãŒãªãã¦ã‚‚total_strokesãŒã‚ã‚Œã°ä½¿ã†ï¼‰
                    let strokes = lap.total_strokes;
                    if (!strokes && cadence && movingTime) {
                        strokes = Math.round(cadence * movingTime / 60);
                    }
                    
                    if (strokes && strokes > 0) {
                        totalDistance += distance;
                        totalStrokes += strokes;
                        totalTime += movingTime;
                    }
                }
            });
            
            console.log('addSwimStrokeMetrics: è¨ˆç®—çµæœ', { totalDistance, totalStrokes, totalTime });
            
            if (totalStrokes === 0 || totalDistance === 0 || totalTime === 0) {
                console.log('addSwimStrokeMetrics: ãƒ‡ãƒ¼ã‚¿ä¸è¶³ã§ã‚¹ã‚­ãƒƒãƒ—');
                return;
            }
            
            // åŠ é‡å¹³å‡ã‚’è¨ˆç®—
            const avgStrokeRate = Math.round(totalStrokes / totalTime * 60); // spm
            const avgDPS = (totalDistance / totalStrokes).toFixed(2); // m/stroke
            
            console.log('addSwimStrokeMetrics: å¹³å‡å€¤', { avgStrokeRate, avgDPS });
            
            // æ¦‚è¦ãƒ¡ãƒˆãƒªãƒƒã‚¯ã‚’å†æ§‹ç¯‰
            const sportType = currentActivity.sport_type || currentActivity.type;
            let html = '';
            
            // è·é›¢
            if (currentActivity.distance) {
                html += createMetricCard((currentActivity.distance / 1000).toFixed(2), 'km', 'è·é›¢');
            }
            
            // æ™‚é–“
            html += createMetricCard(formatDuration(currentActivity.moving_time), '', 'æ™‚é–“');
            
            // ãƒšãƒ¼ã‚¹
            if (currentActivity.average_speed) {
                html += createMetricCard(formatSwimPace(currentActivity.average_speed), '/100m', 'ãƒšãƒ¼ã‚¹');
            }
            
            // å¿ƒæ‹
            if (currentActivity.average_heartrate) {
                html += createMetricCard(Math.round(currentActivity.average_heartrate), 'bpm', 'å¹³å‡å¿ƒæ‹');
            }
            
            // ã‚¹ãƒˆãƒ­ãƒ¼ã‚¯ãƒ¬ãƒ¼ãƒˆã¨DPSï¼ˆå¿ƒæ‹ã®å¾Œã€TSSã®å‰ï¼‰
            html += createMetricCard(avgStrokeRate, 'spm', 'Stroke Rate');
            html += createMetricCard(avgDPS, 'm', 'DPS');
            
            // ç²å¾—æ¨™é«˜ï¼ˆTSSã®å‰ï¼‰
            if (currentActivity.total_elevation_gain && currentActivity.total_elevation_gain > 10) {
                html += createMetricCard(Math.round(currentActivity.total_elevation_gain), 'm', 'ç²å¾—æ¨™é«˜');
            }
            
            // TSS
            if (currentActivity.tss) {
                html += createMetricCard(currentActivity.tss, '', 'TSS');
            }
            
            document.getElementById('summaryMetrics').innerHTML = html;
            console.log('addSwimStrokeMetrics: æ¦‚è¦ãƒ¡ãƒˆãƒªãƒƒã‚¯æ›´æ–°å®Œäº†');
        }
        
        // ===== ã‚°ãƒ©ãƒ•æç”» =====
        function renderCharts() {
            renderMap();
            renderZoneChart();
            setupChartTabs();
            renderHeartRateChart();
            renderPaceChart();
            renderGAPChart();
            renderSportSpecificCharts();
            renderLapTable();
        }
        
        function setupChartTabs() {
            const sportCategory = getSportCategory(currentActivity.sport_type || currentActivity.type);
            
            // ãƒã‚¤ã‚¯ã®å ´åˆã¯ãƒšãƒ¼ã‚¹ã‚¿ãƒ–ã‚’ã€Œé€Ÿåº¦ã€ã«å¤‰æ›´
            const paceTabBtn = document.querySelector('.tab-btn[data-tab="pace"]');
            if (sportCategory === 'bike' && paceTabBtn) {
                paceTabBtn.textContent = 'ğŸš´ é€Ÿåº¦';
            }
            
            // ç¨®ç›®åˆ¥ã‚¿ãƒ–ã®è¡¨ç¤ºåˆ¶å¾¡
            if (sportCategory === 'bike') {
                document.getElementById('cadenceTab').style.display = 'inline-block';
                document.getElementById('cadenceTab').textContent = 'ğŸ”„ ã‚±ã‚¤ãƒ‡ãƒ³ã‚¹';
                if (currentActivity.average_watts || (streamData && streamData.watts)) {
                    document.getElementById('powerTab').style.display = 'inline-block';
                }
            } else if (sportCategory === 'run') {
                if (currentActivity.average_cadence || (streamData && streamData.cadence)) {
                    document.getElementById('cadenceTab').style.display = 'inline-block';
                    document.getElementById('cadenceTab').textContent = 'ğŸ‘Ÿ ãƒ”ãƒƒãƒ';
                }
                // GAPï¼ˆGrade Adjusted Paceï¼‰ã‚¿ãƒ– - æ¨™é«˜ãƒ‡ãƒ¼ã‚¿ãŒã‚ã‚‹å ´åˆã®ã¿
                if (streamData && streamData.altitude && streamData.altitude.data && 
                    streamData.grade_smooth && streamData.grade_smooth.data) {
                    document.getElementById('gapTab').style.display = 'inline-block';
                }
            }
            
            // ã‚¿ãƒ–ã‚¯ãƒªãƒƒã‚¯ã‚¤ãƒ™ãƒ³ãƒˆ
            document.querySelectorAll('.tab-btn').forEach(btn => {
                btn.addEventListener('click', (e) => {
                    const tabId = e.target.dataset.tab;
                    switchChartTab(tabId);
                });
            });
        }
        
        function switchChartTab(tabId) {
            // ã‚¿ãƒ–ãƒœã‚¿ãƒ³ã®ã‚¢ã‚¯ãƒ†ã‚£ãƒ–çŠ¶æ…‹ã‚’æ›´æ–°
            document.querySelectorAll('.tab-btn').forEach(btn => {
                btn.classList.remove('active');
                if (btn.dataset.tab === tabId) {
                    btn.classList.add('active');
                }
            });
            
            // ã‚¿ãƒ–ã‚³ãƒ³ãƒ†ãƒ³ãƒ„ã®è¡¨ç¤ºã‚’åˆ‡ã‚Šæ›¿ãˆ
            document.querySelectorAll('.chart-tab-content').forEach(content => {
                content.style.display = 'none';
            });
            document.getElementById(`${tabId}TabContent`).style.display = 'block';
            
            // ã‚°ãƒ©ãƒ•ã®ãƒªã‚µã‚¤ã‚ºã‚’ãƒˆãƒªã‚¬ãƒ¼ï¼ˆè¡¨ç¤ºå¾Œã«æç”»ã‚’æ›´æ–°ï¼‰
            if (charts[tabId]) {
                charts[tabId].resize();
            }
        }
        
        function renderMap() {
            const mapContainer = document.getElementById('mapContainer');
            
            if (!streamData || !streamData.latlng || !streamData.latlng.data || streamData.latlng.data.length === 0) {
                mapContainer.innerHTML = '<div class="no-map-message">ğŸ—ºï¸ GPSãƒ‡ãƒ¼ã‚¿ãŒã‚ã‚Šã¾ã›ã‚“ï¼ˆã‚¤ãƒ³ãƒ‰ã‚¢ã‚¢ã‚¯ãƒ†ã‚£ãƒ“ãƒ†ã‚£ã®å¯èƒ½æ€§ï¼‰</div>';
                return;
            }
            
            const coords = streamData.latlng.data;
            
            map = L.map('routeMap');
            
            // CartoDB Positron - è–„ã„ã‚°ãƒ¬ãƒ¼ç³»ã§ãƒ«ãƒ¼ãƒˆãŒè¦‹ã‚„ã™ã„
            L.tileLayer('https://{s}.basemaps.cartocdn.com/light_all/{z}/{x}/{y}{r}.png', {
                attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> &copy; <a href="https://carto.com/attributions">CARTO</a>',
                maxZoom: 19,
                subdomains: 'abcd'
            }).addTo(map);
            
            // ãƒ«ãƒ¼ãƒˆãƒ©ã‚¤ãƒ³ã®ã‚¹ã‚¿ã‚¤ãƒ«
            const polyline = L.polyline(coords, { 
                color: '#667eea', 
                weight: 5, 
                opacity: 0.9,
                lineJoin: 'round'
            }).addTo(map);
            
            map.fitBounds(polyline.getBounds(), { padding: [30, 30] });
            
            // ã‚¹ã‚¿ãƒ¼ãƒˆãƒ»ã‚´ãƒ¼ãƒ«ãƒãƒ¼ã‚«ãƒ¼
            const startIcon = L.divIcon({ 
                className: 'custom-marker', 
                html: '<div style="background: #22c55e; width: 14px; height: 14px; border-radius: 50%; border: 3px solid white; box-shadow: 0 2px 6px rgba(0,0,0,0.3);"></div>',
                iconSize: [20, 20],
                iconAnchor: [10, 10]
            });
            const endIcon = L.divIcon({ 
                className: 'custom-marker', 
                html: '<div style="background: #ef4444; width: 14px; height: 14px; border-radius: 50%; border: 3px solid white; box-shadow: 0 2px 6px rgba(0,0,0,0.3);"></div>',
                iconSize: [20, 20],
                iconAnchor: [10, 10]
            });
            
            L.marker(coords[0], { icon: startIcon }).addTo(map).bindPopup('ã‚¹ã‚¿ãƒ¼ãƒˆ');
            L.marker(coords[coords.length - 1], { icon: endIcon }).addTo(map).bindPopup('ã‚´ãƒ¼ãƒ«');
        }
        
        function renderZoneChart() {
            const zones = calculateHeartRateZones();
            
            // Zone ã‚µãƒãƒªãƒ¼
            const zoneSummaryHtml = zones.map((z, i) => `
                <div class="zone-item z${i + 1}">
                    <span class="zone-time">${formatDurationShort(z.time)}</span>
                    <span class="zone-percent">${z.percent.toFixed(0)}%</span>
                </div>
            `).join('');
            document.getElementById('zoneSummary').innerHTML = zoneSummaryHtml;
            
            // Zone ãƒãƒ£ãƒ¼ãƒˆ
            const ctx = document.getElementById('zoneChart').getContext('2d');
            if (charts.zone) charts.zone.destroy();
            
            charts.zone = new Chart(ctx, {
                type: 'bar',
                data: {
                    labels: ['Z1', 'Z2', 'Z3', 'Z4', 'Z5'],
                    datasets: [{
                        data: zones.map(z => z.percent),
                        backgroundColor: ['#9ca3af', '#3b82f6', '#22c55e', '#f97316', '#ef4444']
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: { legend: { display: false } },
                    scales: {
                        y: { beginAtZero: true, max: 100, title: { display: true, text: '%' } }
                    }
                }
            });
        }
        
        function calculateHeartRateZones() {
            const thresholds = getUserThresholds();
            const maxHr = thresholds.maxHr || 190;
            const totalTime = currentActivity.moving_time || 0;
            
            // Streamãƒ‡ãƒ¼ã‚¿ãŒã‚ã‚‹å ´åˆã¯è©³ç´°è¨ˆç®—
            if (streamData && streamData.heartrate && streamData.heartrate.data && streamData.time) {
                const hrData = streamData.heartrate.data;
                const timeData = streamData.time.data;
                
                const zoneTimes = [0, 0, 0, 0, 0];
                
                for (let i = 1; i < hrData.length; i++) {
                    const hr = hrData[i];
                    const duration = timeData[i] - timeData[i - 1];
                    const hrPercent = (hr / maxHr) * 100;
                    
                    if (hrPercent < 60) zoneTimes[0] += duration;
                    else if (hrPercent < 70) zoneTimes[1] += duration;
                    else if (hrPercent < 80) zoneTimes[2] += duration;
                    else if (hrPercent < 90) zoneTimes[3] += duration;
                    else zoneTimes[4] += duration;
                }
                
                const total = zoneTimes.reduce((a, b) => a + b, 0) || 1;
                return zoneTimes.map(t => ({ time: t, percent: (t / total) * 100 }));
            }
            
            // å¹³å‡å¿ƒæ‹ã‹ã‚‰æ¨å®š
            const avgHr = currentActivity.average_heartrate;
            if (!avgHr) return [0, 1, 2, 3, 4].map(() => ({ time: 0, percent: 0 }));
            
            const hrPercent = (avgHr / maxHr) * 100;
            const zones = [0, 0, 0, 0, 0];
            
            if (hrPercent < 60) zones[0] = 100;
            else if (hrPercent < 70) zones[1] = 100;
            else if (hrPercent < 80) zones[2] = 100;
            else if (hrPercent < 90) zones[3] = 100;
            else zones[4] = 100;
            
            return zones.map((p, i) => ({ time: p > 0 ? totalTime : 0, percent: p }));
        }
        
        function renderHeartRateChart() {
            const ctx = document.getElementById('hrChart').getContext('2d');
            if (charts.hr) charts.hr.destroy();
            
            if (!streamData || !streamData.heartrate || !streamData.heartrate.data) {
                ctx.canvas.parentElement.innerHTML = '<div class="no-map-message">å¿ƒæ‹ãƒ‡ãƒ¼ã‚¿ãŒã‚ã‚Šã¾ã›ã‚“</div>';
                return;
            }
            
            const sportCategory = getSportCategory(currentActivity.sport_type || currentActivity.type);
            const hrData = streamData.heartrate.data;
            const timeData = streamData.time?.data || hrData.map((_, i) => i);
            const distanceData = streamData.distance?.data;
            const altitudeData = streamData.altitude?.data;
            
            // ãƒ‡ãƒ¼ã‚¿ã‚’ã‚µãƒ³ãƒ—ãƒªãƒ³ã‚°ï¼ˆå¤šã™ãã‚‹å ´åˆï¼‰
            const maxPoints = 500;
            const step = Math.max(1, Math.floor(hrData.length / maxPoints));
            
            const labels = [];
            const data = [];
            const altData = [];
            
            for (let i = 0; i < hrData.length; i += step) {
                if (distanceData) {
                    // ã‚¹ã‚¤ãƒ ã¯må˜ä½ã€ãã‚Œä»¥å¤–ã¯kmå˜ä½
                    if (sportCategory === 'swim') {
                        labels.push(Math.round(distanceData[i]));
                    } else {
                        labels.push((distanceData[i] / 1000).toFixed(1));
                    }
                } else {
                    labels.push(formatDurationShort(timeData[i]));
                }
                data.push(hrData[i]);
                if (altitudeData) {
                    altData.push(altitudeData[i]);
                }
            }
            
            // ãƒ‡ãƒ¼ã‚¿ã‚»ãƒƒãƒˆ
            const datasets = [{
                label: 'å¿ƒæ‹æ•°',
                data: data,
                borderColor: '#ef4444',
                borderWidth: 1.5,
                fill: false,
                tension: 0.2,
                pointRadius: 0,
                yAxisID: 'y'
            }];
            
            // æ¨™é«˜ãƒ‡ãƒ¼ã‚¿ãŒã‚ã‚Œã°èƒŒæ™¯ã¨ã—ã¦è¿½åŠ 
            if (altData.length > 0 && sportCategory !== 'swim') {
                datasets.unshift({
                    label: 'æ¨™é«˜',
                    data: altData,
                    borderColor: 'rgba(156, 163, 175, 0.3)',
                    backgroundColor: 'rgba(156, 163, 175, 0.15)',
                    borderWidth: 1,
                    fill: true,
                    tension: 0.2,
                    pointRadius: 0,
                    yAxisID: 'y1'
                });
            }
            
            const scales = {
                x: { 
                    title: { display: true, text: distanceData ? (sportCategory === 'swim' ? 'è·é›¢ (m)' : 'è·é›¢ (km)') : 'æ™‚é–“' },
                    ticks: {
                        maxTicksLimit: sportCategory === 'swim' ? 10 : 12,
                        callback: function(value, index) {
                            const label = this.getLabelForValue(value);
                            if (sportCategory === 'swim' && distanceData) {
                                const dist = parseFloat(label);
                                if (dist % 200 === 0 || index === 0) {
                                    return label;
                                }
                                return '';
                            }
                            return label;
                        }
                    }
                },
                y: { 
                    type: 'linear',
                    position: 'left',
                    title: { display: true, text: 'bpm' }
                }
            };
            
            // æ¨™é«˜ç”¨ã®å³Yè»¸
            if (altData.length > 0 && sportCategory !== 'swim') {
                scales.y1 = {
                    type: 'linear',
                    position: 'right',
                    title: { display: true, text: 'æ¨™é«˜ (m)' },
                    grid: { drawOnChartArea: false },
                    min: Math.min(...altData) - 10,
                    max: Math.max(...altData) + 10
                };
            }
            
            charts.hr = new Chart(ctx, {
                type: 'line',
                data: { labels: labels, datasets: datasets },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: { legend: { display: altData.length > 0 && sportCategory !== 'swim' } },
                    scales: scales,
                    interaction: {
                        intersect: false,
                        mode: 'index'
                    }
                }
            });
        }
        
        function renderPaceChart() {
            const ctx = document.getElementById('paceChart').getContext('2d');
            if (charts.pace) charts.pace.destroy();
            
            const sportCategory = getSportCategory(currentActivity.sport_type || currentActivity.type);
            
            // ã‚¹ã‚¤ãƒ ã®å ´åˆï¼šãƒ©ãƒƒãƒ—ãƒ‡ãƒ¼ã‚¿ãŒã‚ã‚Œã°æ£’ã‚°ãƒ©ãƒ•ã‚’ä½¿ç”¨ï¼ˆFORMãªã©ã‹ã‚‰ã®ãƒ‡ãƒ¼ã‚¿ï¼‰
            if (sportCategory === 'swim' && currentActivity.laps && currentActivity.laps.length > 0) {
                console.log('ã‚¹ã‚¤ãƒ : ãƒ©ãƒƒãƒ—ãƒ‡ãƒ¼ã‚¿ã‚’ä½¿ç”¨ã—ã¦æ£’ã‚°ãƒ©ãƒ•ã‚’æç”»');
                renderSwimLapBarChart();
                return;
            }
            
            if (!streamData || !streamData.velocity_smooth || !streamData.velocity_smooth.data) {
                ctx.canvas.parentElement.innerHTML = '<div class="no-map-message">ãƒšãƒ¼ã‚¹/é€Ÿåº¦ãƒ‡ãƒ¼ã‚¿ãŒã‚ã‚Šã¾ã›ã‚“</div>';
                return;
            }
            
            const velData = streamData.velocity_smooth.data;
            const distanceData = streamData.distance?.data;
            const timeData = streamData.time?.data || velData.map((_, i) => i);
            const altitudeData = streamData.altitude?.data;
            
            // é€Ÿåº¦ã®é–¾å€¤ã‚’è¨­å®šï¼ˆåœæ­¢ã‚„æ­©è¡Œã‚’é™¤å¤–ï¼‰
            const minVelocity = getMinVelocityThreshold(sportCategory);
            
            let labels = [];
            let data = [];
            let altData = [];
            let rawPaceValues = [];
            
            // ã‚¹ã‚¤ãƒ ã®å ´åˆã¯ã‚¿ãƒ¼ãƒ³å˜ä½ï¼ˆ25m/50mï¼‰ã®å¹³å‡ãƒšãƒ¼ã‚¹ã‚’ä½¿ç”¨ï¼ˆãƒ©ãƒƒãƒ—ãƒ‡ãƒ¼ã‚¿ãŒãªã„å ´åˆã®ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯ï¼‰
            if (sportCategory === 'swim' && distanceData) {
                const poolLength = detectPoolLength();
                const lapData = calculateSwimLapPaces(velData, distanceData, poolLength);
                labels = lapData.labels;
                data = lapData.paces;
                rawPaceValues = lapData.paces.filter(p => p && p > 0);
            } else {
                // é€šå¸¸ã®å‡¦ç†ï¼ˆãƒ©ãƒ³ã€ãƒã‚¤ã‚¯ç­‰ï¼‰
                const maxPoints = 500;
                const step = Math.max(1, Math.floor(velData.length / maxPoints));
                
                for (let i = 0; i < velData.length; i += step) {
                    if (distanceData) {
                        labels.push((distanceData[i] / 1000).toFixed(1));
                    } else {
                        labels.push(formatDurationShort(timeData[i]));
                    }
                    
                    const vel = velData[i];
                    
                    if (sportCategory === 'bike') {
                        const speed = vel * 3.6; // km/h
                        data.push(speed);
                        if (vel >= minVelocity) rawPaceValues.push(speed);
                    } else {
                        // ãƒ©ãƒ³: min/km
                        const pace = vel > 0 ? 1000 / vel / 60 : null;
                        data.push(pace);
                        if (vel >= minVelocity && pace) rawPaceValues.push(pace);
                    }
                    
                    // æ¨™é«˜ãƒ‡ãƒ¼ã‚¿
                    if (altitudeData) {
                        altData.push(altitudeData[i]);
                    }
                }
            }
            
            // Yè»¸ã®ç¯„å›²ã‚’è¨ˆç®—ï¼ˆå¤–ã‚Œå€¤ã‚’é™¤å¤–ï¼‰
            const yAxisRange = calculateYAxisRange(rawPaceValues, sportCategory);
            
            const xLabel = sportCategory === 'swim' ? 'è·é›¢ (m)' : (distanceData ? 'è·é›¢ (km)' : 'æ™‚é–“');
            const poolLength = sportCategory === 'swim' ? detectPoolLength() : null;
            
            // ãƒ‡ãƒ¼ã‚¿ã‚»ãƒƒãƒˆ
            const datasets = [];
            
            // æ¨™é«˜èƒŒæ™¯ï¼ˆãƒ©ãƒ³ã€ãƒã‚¤ã‚¯ã®ã¿ï¼‰
            if (altData.length > 0 && sportCategory !== 'swim') {
                datasets.push({
                    label: 'æ¨™é«˜',
                    data: altData,
                    borderColor: 'rgba(156, 163, 175, 0.3)',
                    backgroundColor: 'rgba(156, 163, 175, 0.15)',
                    borderWidth: 1,
                    fill: true,
                    tension: 0.2,
                    pointRadius: 0,
                    yAxisID: 'y1'
                });
            }
            
            // ãƒ¡ã‚¤ãƒ³ã®ãƒšãƒ¼ã‚¹/é€Ÿåº¦ãƒ‡ãƒ¼ã‚¿
            datasets.push({
                label: sportCategory === 'bike' ? 'é€Ÿåº¦' : 'ãƒšãƒ¼ã‚¹',
                data: data,
                borderColor: '#3b82f6',
                borderWidth: sportCategory === 'swim' ? 2 : 1.5,
                fill: false,
                tension: 0.2,
                pointRadius: sportCategory === 'swim' ? 3 : 0,
                pointBackgroundColor: '#3b82f6',
                spanGaps: true,
                yAxisID: 'y'
            });
            
            const scales = {
                x: { 
                    title: { display: true, text: xLabel },
                    ticks: {
                        maxTicksLimit: sportCategory === 'swim' ? 15 : 12,
                        callback: function(value, index) {
                            const label = this.getLabelForValue(value);
                            if (sportCategory === 'swim') {
                                const dist = parseFloat(label);
                                if (dist % 100 === 0) {
                                    return label + 'm';
                                }
                                return '';
                            }
                            return label;
                        }
                    }
                },
                y: { 
                    type: 'linear',
                    position: 'left',
                    title: { display: true, text: sportCategory === 'bike' ? 'km/h' : 'ãƒšãƒ¼ã‚¹' },
                    reverse: sportCategory !== 'bike',
                    min: yAxisRange.min,
                    max: yAxisRange.max,
                    ticks: {
                        callback: function(value) {
                            if (sportCategory === 'bike') {
                                return value.toFixed(0);
                            } else if (sportCategory === 'swim') {
                                const min = Math.floor(value / 60);
                                const sec = Math.round(value % 60);
                                return `${min}:${String(sec).padStart(2, '0')}`;
                            } else {
                                const min = Math.floor(value);
                                const sec = Math.round((value - min) * 60);
                                return `${min}:${String(sec).padStart(2, '0')}`;
                            }
                        }
                    }
                }
            };
            
            // æ¨™é«˜ç”¨Yè»¸
            if (altData.length > 0 && sportCategory !== 'swim') {
                scales.y1 = {
                    type: 'linear',
                    position: 'right',
                    title: { display: true, text: 'æ¨™é«˜ (m)' },
                    grid: { drawOnChartArea: false },
                    min: Math.min(...altData) - 10,
                    max: Math.max(...altData) + 10
                };
            }
            
            charts.pace = new Chart(ctx, {
                type: 'line',
                data: { labels: labels, datasets: datasets },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: { legend: { display: altData.length > 0 && sportCategory !== 'swim' } },
                    scales: scales,
                    interaction: {
                        intersect: false,
                        mode: 'index'
                    },
                    plugins: {
                        tooltip: {
                            callbacks: {
                                title: function(context) {
                                    if (sportCategory === 'swim') {
                                        const dist = context[0].label;
                                        const lapNum = Math.ceil(parseFloat(dist) / poolLength);
                                        return `${dist}m (ãƒ©ãƒƒãƒ— ${lapNum})`;
                                    }
                                    return context[0].label;
                                },
                                label: function(context) {
                                    const value = context.raw;
                                    if (value === null) return `${context.dataset.label}: åœæ­¢ä¸­`;
                                    
                                    if (context.dataset.label === 'æ¨™é«˜') {
                                        return `æ¨™é«˜: ${Math.round(value)}m`;
                                    }
                                    
                                    if (sportCategory === 'bike') {
                                        return `é€Ÿåº¦: ${value.toFixed(1)} km/h`;
                                    } else if (sportCategory === 'swim') {
                                        const min = Math.floor(value / 60);
                                        const sec = Math.round(value % 60);
                                        return `ãƒšãƒ¼ã‚¹: ${min}:${String(sec).padStart(2, '0')}/100m`;
                                    } else {
                                        const min = Math.floor(value);
                                        const sec = Math.round((value - min) * 60);
                                        return `ãƒšãƒ¼ã‚¹: ${min}:${String(sec).padStart(2, '0')}/km`;
                                    }
                                }
                            }
                        }
                    }
                }
            });
        }
        
        // GAPï¼ˆGrade Adjusted Paceï¼‰ãƒãƒ£ãƒ¼ãƒˆ - ãƒ©ãƒ³ã®ã¿
        function renderGAPChart() {
            const sportCategory = getSportCategory(currentActivity.sport_type || currentActivity.type);
            
            // ãƒ©ãƒ³ã®ã¿ã€ã‹ã¤å¿…è¦ãªãƒ‡ãƒ¼ã‚¿ãŒã‚ã‚‹å ´åˆã®ã¿
            if (sportCategory !== 'run') return;
            if (!streamData || !streamData.velocity_smooth?.data || !streamData.grade_smooth?.data) {
                return;
            }
            
            const ctx = document.getElementById('gapChart').getContext('2d');
            if (charts.gap) charts.gap.destroy();
            
            const velData = streamData.velocity_smooth.data;
            const gradeData = streamData.grade_smooth.data;
            const distanceData = streamData.distance?.data;
            const altitudeData = streamData.altitude?.data;
            const timeData = streamData.time?.data || velData.map((_, i) => i);
            
            // GAPã®è¨ˆç®—
            // å‚¾æ–œä¿‚æ•°: ä¸Šã‚Š1%ã‚ãŸã‚Šç´„0.03è¿½åŠ ã€ä¸‹ã‚Š1%ã‚ãŸã‚Šç´„0.015å‰Šæ¸›
            // GAP = Pace Ã— (1 + grade * factor)
            // ãŸã ã—é€Ÿåº¦ãƒ™ãƒ¼ã‚¹ã§è¨ˆç®—: GAP_velocity = velocity / (1 + grade * factor)
            
            const maxPoints = 500;
            const step = Math.max(1, Math.floor(velData.length / maxPoints));
            
            const labels = [];
            const paceData = [];
            const gapData = [];
            const altData = [];
            const rawGapValues = [];
            
            const minVelocity = 0.5; // 0.5 m/s ä»¥ä¸‹ã¯åœæ­¢ã¨ã¿ãªã™
            
            for (let i = 0; i < velData.length; i += step) {
                if (distanceData) {
                    labels.push((distanceData[i] / 1000).toFixed(1));
                } else {
                    labels.push(formatDurationShort(timeData[i]));
                }
                
                const vel = velData[i];
                const grade = gradeData[i] || 0; // ãƒ‘ãƒ¼ã‚»ãƒ³ãƒˆ
                
                // ãƒšãƒ¼ã‚¹ï¼ˆmin/kmï¼‰
                const pace = vel > minVelocity ? 1000 / vel / 60 : null;
                paceData.push(pace);
                
                // GAPè¨ˆç®—
                // ä¸Šã‚Š: 1%ã‚ãŸã‚Š+3%ã€ä¸‹ã‚Š: 1%ã‚ãŸã‚Š-1.5%ï¼ˆä¸‹ã‚Šã¯åŠ¹æœãŒå°ã•ã„ï¼‰
                let gapFactor;
                if (grade >= 0) {
                    gapFactor = 1 + grade * 0.03; // ä¸Šã‚Š
                } else {
                    gapFactor = 1 + grade * 0.015; // ä¸‹ã‚Šï¼ˆåŠ¹æœå°ã•ã‚ï¼‰
                }
                
                // GAP = å®Ÿéš›ã®ãƒšãƒ¼ã‚¹ Ã— å‚¾æ–œä¿‚æ•°
                // ä¸Šã‚Šã§ã¯å®Ÿéš›ã‚ˆã‚Šé…ã„ãƒšãƒ¼ã‚¹ã§ã‚‚ã€GAPã¯é€Ÿããªã‚‹ï¼ˆåŠªåŠ›åº¦ãŒé«˜ã„ï¼‰
                const gap = vel > minVelocity ? (1000 / vel / 60) / gapFactor : null;
                gapData.push(gap);
                
                if (gap && gap > 2 && gap < 15) { // 2:00ã€œ15:00/kmã®ç¯„å›²å†…
                    rawGapValues.push(gap);
                }
                
                if (altitudeData) {
                    altData.push(altitudeData[i]);
                }
            }
            
            // å¹³å‡GAPè¨ˆç®—
            const validGaps = rawGapValues.filter(g => g);
            const avgGap = validGaps.length > 0 ? validGaps.reduce((a, b) => a + b, 0) / validGaps.length : 0;
            const avgGapFormatted = avgGap > 0 ? `${Math.floor(avgGap)}:${String(Math.round((avgGap % 1) * 60)).padStart(2, '0')}` : '-';
            
            // å¹³å‡ãƒšãƒ¼ã‚¹
            const validPaces = paceData.filter(p => p && p > 2 && p < 15);
            const avgPace = validPaces.length > 0 ? validPaces.reduce((a, b) => a + b, 0) / validPaces.length : 0;
            const avgPaceFormatted = avgPace > 0 ? `${Math.floor(avgPace)}:${String(Math.round((avgPace % 1) * 60)).padStart(2, '0')}` : '-';
            
            // ãƒ¡ãƒˆãƒªã‚¯ã‚¹è¡¨ç¤º
            document.getElementById('gapMetrics').innerHTML = `
                <div class="sport-metric-item">
                    <div class="sport-metric-value">${avgPaceFormatted}</div>
                    <div class="sport-metric-label">å¹³å‡ãƒšãƒ¼ã‚¹ (/km)</div>
                </div>
                <div class="sport-metric-item">
                    <div class="sport-metric-value">${avgGapFormatted}</div>
                    <div class="sport-metric-label">å¹³å‡GAP (/km)</div>
                </div>
            `;
            
            // Yè»¸ç¯„å›²
            const yAxisRange = calculateYAxisRange(rawGapValues, 'run');
            
            // ãƒ‡ãƒ¼ã‚¿ã‚»ãƒƒãƒˆ
            const datasets = [];
            
            // æ¨™é«˜èƒŒæ™¯
            if (altData.length > 0) {
                datasets.push({
                    label: 'æ¨™é«˜',
                    data: altData,
                    borderColor: 'rgba(156, 163, 175, 0.3)',
                    backgroundColor: 'rgba(156, 163, 175, 0.15)',
                    borderWidth: 1,
                    fill: true,
                    tension: 0.2,
                    pointRadius: 0,
                    yAxisID: 'y1'
                });
            }
            
            // å®Ÿéš›ã®ãƒšãƒ¼ã‚¹ï¼ˆè–„ã„è‰²ï¼‰
            datasets.push({
                label: 'ãƒšãƒ¼ã‚¹',
                data: paceData,
                borderColor: 'rgba(59, 130, 246, 0.4)',
                borderWidth: 1,
                fill: false,
                tension: 0.2,
                pointRadius: 0,
                yAxisID: 'y'
            });
            
            // GAPï¼ˆæ¿ƒã„è‰²ï¼‰
            datasets.push({
                label: 'GAP',
                data: gapData,
                borderColor: '#10b981',
                borderWidth: 1.5,
                fill: false,
                tension: 0.2,
                pointRadius: 0,
                yAxisID: 'y'
            });
            
            const scales = {
                x: { 
                    title: { display: true, text: distanceData ? 'è·é›¢ (km)' : 'æ™‚é–“' },
                    ticks: { maxTicksLimit: 12 }
                },
                y: { 
                    type: 'linear',
                    position: 'left',
                    title: { display: true, text: 'ãƒšãƒ¼ã‚¹ (min/km)' },
                    reverse: true,
                    min: yAxisRange.min,
                    max: yAxisRange.max,
                    ticks: {
                        callback: function(value) {
                            const min = Math.floor(value);
                            const sec = Math.round((value - min) * 60);
                            return `${min}:${String(sec).padStart(2, '0')}`;
                        }
                    }
                }
            };
            
            // æ¨™é«˜ç”¨Yè»¸
            if (altData.length > 0) {
                scales.y1 = {
                    type: 'linear',
                    position: 'right',
                    title: { display: true, text: 'æ¨™é«˜ (m)' },
                    grid: { drawOnChartArea: false },
                    min: Math.min(...altData) - 10,
                    max: Math.max(...altData) + 10
                };
            }
            
            charts.gap = new Chart(ctx, {
                type: 'line',
                data: { labels: labels, datasets: datasets },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: { 
                        legend: { display: true }
                    },
                    scales: scales,
                    interaction: {
                        intersect: false,
                        mode: 'index'
                    },
                    plugins: {
                        tooltip: {
                            callbacks: {
                                label: function(context) {
                                    const value = context.raw;
                                    if (value === null) return `${context.dataset.label}: åœæ­¢ä¸­`;
                                    
                                    if (context.dataset.label === 'æ¨™é«˜') {
                                        return `æ¨™é«˜: ${Math.round(value)}m`;
                                    }
                                    
                                    const min = Math.floor(value);
                                    const sec = Math.round((value - min) * 60);
                                    return `${context.dataset.label}: ${min}:${String(sec).padStart(2, '0')}/km`;
                                }
                            }
                        }
                    }
                }
            });
        }
        
        // ã‚¹ã‚¤ãƒ ãƒ©ãƒƒãƒ—æ£’ã‚°ãƒ©ãƒ•ï¼ˆHTML/CSSã§æç”»ã€Xè»¸=è·é›¢ã€æ£’å¹…ã¯è·é›¢ã«æ¯”ä¾‹ï¼‰
        function renderSwimLapBarChart() {
            if (!currentActivity.laps || currentActivity.laps.length === 0) {
                return;
            }
            
            // Chart.jsã®ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ãŒã‚ã‚Œã°ç ´æ£„
            if (charts.pace) {
                charts.pace.destroy();
                charts.pace = null;
            }
            
            const container = document.getElementById('paceChart').parentElement;
            const laps = currentActivity.laps;
            
            // æ³³ããƒ©ãƒƒãƒ—ã®ã¿æŠ½å‡ºï¼ˆRESTã‚’é™¤å¤–ï¼‰
            const swimLaps = [];
            let cumulativeDistance = 0;
            
            laps.forEach((lap, index) => {
                const distance = lap.distance || 0;
                const movingTime = lap.moving_time || 0;
                
                // ãƒšãƒ¼ã‚¹è¨ˆç®—ï¼ˆç§’/100mï¼‰
                let paceSeconds = null;
                if (lap.average_speed && lap.average_speed > 0) {
                    paceSeconds = 100 / lap.average_speed;
                } else if (movingTime > 0 && distance > 0) {
                    paceSeconds = (movingTime / distance) * 100;
                }
                
                // ãƒ¬ã‚¹ãƒˆåˆ¤å®š
                const isRest = distance === 0 ||
                               movingTime === 0 || 
                               movingTime < 10 ||
                               (paceSeconds && paceSeconds > 300) ||
                               (paceSeconds && paceSeconds < 60);
                
                if (!isRest && paceSeconds && distance > 0) {
                    // ã‚¹ãƒˆãƒ­ãƒ¼ã‚¯æ•°ã‚’è¨ˆç®—ï¼ˆtotal_strokesãŒãªã‘ã‚Œã°cadenceã¨æ™‚é–“ã‹ã‚‰è¨ˆç®—ï¼‰
                    let strokes = lap.total_strokes;
                    if (!strokes && lap.average_cadence && movingTime) {
                        strokes = Math.round(lap.average_cadence * movingTime / 60);
                    }
                    
                    swimLaps.push({
                        lapNumber: index + 1,
                        distance: distance,
                        startDistance: cumulativeDistance,
                        endDistance: cumulativeDistance + distance,
                        paceSeconds: paceSeconds,
                        movingTime: movingTime,
                        heartrate: lap.average_heartrate,
                        strokes: strokes,
                        cadence: lap.average_cadence
                    });
                    cumulativeDistance += distance;
                }
            });
            
            const totalDistance = cumulativeDistance;
            console.log(`æ³³ããƒ©ãƒƒãƒ—: ${swimLaps.length}, ç·è·é›¢: ${totalDistance}m`);
            
            if (swimLaps.length === 0) {
                container.innerHTML = '<div class="no-map-message">æœ‰åŠ¹ãªã‚¹ã‚¤ãƒ ãƒ©ãƒƒãƒ—ãƒ‡ãƒ¼ã‚¿ãŒã‚ã‚Šã¾ã›ã‚“</div>';
                return;
            }
            
            // Yè»¸ç¯„å›²ã‚’è¨ˆç®—
            const paces = swimLaps.map(d => d.paceSeconds);
            const minPace = Math.min(...paces);
            const maxPace = Math.max(...paces);
            const avgPace = paces.reduce((a,b)=>a+b,0) / paces.length;
            const paceRange = maxPace - minPace || 20;
            const padding = Math.max(paceRange * 0.15, 5);
            const yMin = Math.floor((minPace - padding) / 5) * 5;
            const yMax = Math.ceil((maxPace + padding) / 5) * 5;
            
            // Xè»¸ã®ç›®ç››ã‚Š
            const xStep = calculateXAxisStep(totalDistance);
            const xTicks = [];
            for (let d = 0; d <= totalDistance; d += xStep) {
                xTicks.push(d);
            }
            if (xTicks[xTicks.length - 1] !== totalDistance) {
                xTicks.push(totalDistance);
            }
            
            // Yè»¸ã®ç›®ç››ã‚Šï¼ˆç¯„å›²ã«å¿œã˜ã¦é–“éš”ã‚’èª¿æ•´ã€3ã€œ6å€‹ç¨‹åº¦ã«ãªã‚‹ã‚ˆã†ã«ï¼‰
            const yRange = yMax - yMin;
            let yStep;
            if (yRange <= 20) yStep = 5;        // 20ç§’ä»¥å†…ãªã‚‰5ç§’åˆ»ã¿
            else if (yRange <= 40) yStep = 10;  // 40ç§’ä»¥å†…ãªã‚‰10ç§’åˆ»ã¿
            else if (yRange <= 90) yStep = 15;  // 90ç§’ä»¥å†…ãªã‚‰15ç§’åˆ»ã¿
            else if (yRange <= 120) yStep = 20; // 2åˆ†ä»¥å†…ãªã‚‰20ç§’åˆ»ã¿
            else yStep = 30;                    // ãã‚Œä»¥ä¸Šã¯30ç§’åˆ»ã¿
            
            const yTicks = [];
            const yStart = Math.ceil(yMin / yStep) * yStep;
            for (let p = yStart; p <= yMax; p += yStep) {
                yTicks.push(p);
            }
            
            // HTMLç”Ÿæˆ
            let html = `
                <div class="swim-chart-container">
                    <div class="swim-chart-title">ãƒ©ãƒƒãƒ—ãƒšãƒ¼ã‚¹ï¼ˆ${swimLaps.length}æœ¬ã€å¹³å‡: ${formatPaceDebug(avgPace)}ï¼‰</div>
                    <div class="swim-chart-wrapper">
                        <div class="swim-chart-y-axis">
                            ${yTicks.map(p => `<div class="swim-y-tick" style="bottom: ${((yMax - p) / (yMax - yMin)) * 100}%">${Math.floor(p/60)}:${String(Math.round(p%60)).padStart(2,'0')}</div>`).join('')}
                            <div class="swim-y-label">ãƒšãƒ¼ã‚¹ (/100m)</div>
                        </div>
                        <div class="swim-chart-area">
                            <div class="swim-chart-grid">
                                ${yTicks.map(p => `<div class="swim-grid-line-h" style="bottom: ${((yMax - p) / (yMax - yMin)) * 100}%"></div>`).join('')}
                                ${xTicks.map(d => `<div class="swim-grid-line-v" style="left: ${(d / totalDistance) * 100}%"></div>`).join('')}
                            </div>
                            <div class="swim-bars">
                                ${swimLaps.map(lap => {
                                    const left = (lap.startDistance / totalDistance) * 100;
                                    const width = (lap.distance / totalDistance) * 100;
                                    // é€Ÿã„ãƒšãƒ¼ã‚¹ï¼ˆå°ã•ã„å€¤ï¼‰ã»ã©é«˜ã„æ£’ã«ãªã‚‹ã‚ˆã†ã«è¨ˆç®—
                                    const height = ((yMax - lap.paceSeconds) / (yMax - yMin)) * 100;
                                    return `<div class="swim-bar" 
                                        style="left: ${left}%; width: ${width}%; height: ${height}%;"
                                        data-lap='${JSON.stringify(lap)}'
                                        title="${lap.startDistance}m-${lap.endDistance}m: ${formatPaceDebug(lap.paceSeconds)}"></div>`;
                                }).join('')}
                            </div>
                        </div>
                    </div>
                    <div class="swim-chart-x-axis">
                        ${xTicks.map(d => `<div class="swim-x-tick" style="left: ${(d / totalDistance) * 100}%">${d}m</div>`).join('')}
                        <div class="swim-x-label">è·é›¢ (m)</div>
                    </div>
                </div>
            `;
            
            container.innerHTML = html;
            
            // ãƒ„ãƒ¼ãƒ«ãƒãƒƒãƒ—ã‚¤ãƒ™ãƒ³ãƒˆ
            container.querySelectorAll('.swim-bar').forEach(bar => {
                bar.addEventListener('mouseenter', (e) => {
                    const lap = JSON.parse(e.target.dataset.lap);
                    showSwimTooltip(e, lap);
                });
                bar.addEventListener('mousemove', (e) => {
                    moveSwimTooltip(e);
                });
                bar.addEventListener('mouseleave', hideSwimTooltip);
            });
        }
        
        // Xè»¸ã®ç›®ç››ã‚Šé–“éš”ã‚’è¨ˆç®—
        function calculateXAxisStep(totalDistance) {
            if (totalDistance <= 500) return 100;
            if (totalDistance <= 1000) return 200;
            if (totalDistance <= 2000) return 500;
            if (totalDistance <= 5000) return 500;
            return 1000;
        }
        
        // ã‚¹ã‚¤ãƒ ãƒãƒ£ãƒ¼ãƒˆã®ãƒ„ãƒ¼ãƒ«ãƒãƒƒãƒ—
        let swimTooltip = null;
        
        function showSwimTooltip(e, lap) {
            if (!swimTooltip) {
                swimTooltip = document.createElement('div');
                swimTooltip.className = 'swim-tooltip';
                document.body.appendChild(swimTooltip);
            }
            
            let html = `<strong>${lap.startDistance}m - ${lap.endDistance}m (Lap ${lap.lapNumber})</strong><br>`;
            html += `ãƒšãƒ¼ã‚¹: ${formatPaceDebug(lap.paceSeconds)}<br>`;
            html += `æ™‚é–“: ${lap.movingTime}ç§’<br>`;
            html += `è·é›¢: ${lap.distance}m`;
            if (lap.heartrate) html += `<br>å¿ƒæ‹: ${Math.round(lap.heartrate)} bpm`;
            if (lap.strokes) html += `<br>Strokes: ${lap.strokes}`;
            if (lap.cadence) html += `<br>Rate: ${lap.cadence} spm`;
            if (lap.strokes && lap.distance > 0) {
                const dps = (lap.distance / lap.strokes).toFixed(2);
                html += `<br>DPS: ${dps}m`;
            }
            
            swimTooltip.innerHTML = html;
            swimTooltip.style.display = 'block';
            swimTooltip.style.left = (e.clientX + 15) + 'px';
            swimTooltip.style.top = (e.clientY + 15) + 'px';
        }
        
        function moveSwimTooltip(e) {
            if (swimTooltip) {
                swimTooltip.style.left = (e.clientX + 15) + 'px';
                swimTooltip.style.top = (e.clientY + 15) + 'px';
            }
        }
        
        function hideSwimTooltip() {
            if (swimTooltip) {
                swimTooltip.style.display = 'none';
            }
        }
        
        // ç¨®ç›®åˆ¥ã®æœ€å°é€Ÿåº¦é–¾å€¤ï¼ˆã“ã‚Œä»¥ä¸‹ã¯åœæ­¢/æ­©è¡Œã¨ã¿ãªã™ï¼‰
        function getMinVelocityThreshold(sportCategory) {
            switch (sportCategory) {
                case 'bike':
                    return 3.0; // 10.8 km/h ä»¥ä¸‹ã¯é™¤å¤–
                case 'run':
                    return 1.5; // 5.4 km/h (ç´„11:00/km) ä»¥ä¸‹ã¯é™¤å¤–
                case 'swim':
                    return 0.3; // 3:20/100m ã‚ˆã‚Šé…ã„ã‚‚ã®ã¯é™¤å¤–
                default:
                    return 1.0;
            }
        }
        
        // Yè»¸ã®ç¯„å›²ã‚’ãƒ‘ãƒ¼ã‚»ãƒ³ã‚¿ã‚¤ãƒ«ãƒ™ãƒ¼ã‚¹ã§è¨ˆç®—
        function calculateYAxisRange(values, sportCategory) {
            if (values.length === 0) {
                return { min: undefined, max: undefined };
            }
            
            // ã‚½ãƒ¼ãƒˆã—ã¦ç¯„å›²ã‚’è¨ˆç®—
            const sorted = [...values].sort((a, b) => a - b);
            const minVal = sorted[0];
            const maxVal = sorted[sorted.length - 1];
            const range = maxVal - minVal;
            const padding = range * 0.05; // 5%ã®ä½™ç™½
            
            if (sportCategory === 'bike') {
                // ãƒã‚¤ã‚¯é€Ÿåº¦ï¼šå…¨ãƒ‡ãƒ¼ã‚¿è¡¨ç¤ºï¼ˆ0ã‹ã‚‰æœ€å¤§å€¤ï¼‰
                return {
                    min: 0,
                    max: Math.ceil(maxVal + padding)
                };
            } else if (sportCategory === 'run') {
                // ãƒ©ãƒ³ãƒšãƒ¼ã‚¹ï¼šå…¨ãƒ‡ãƒ¼ã‚¿è¡¨ç¤º
                return {
                    min: Math.max(0, Math.floor(minVal - padding)),
                    max: Math.ceil(maxVal + padding)
                };
            } else if (sportCategory === 'swim') {
                // ã‚¹ã‚¤ãƒ : ãƒ‘ãƒ¼ã‚»ãƒ³ã‚¿ã‚¤ãƒ«ãƒ™ãƒ¼ã‚¹ã§ç¯„å›²ã‚’è¨­å®š
                const p5 = sorted[Math.floor(sorted.length * 0.05)];
                const p95 = sorted[Math.floor(sorted.length * 0.95)];
                const pRange = p95 - p5;
                const pPadding = pRange * 0.15;
                console.log('ã‚¹ã‚¤ãƒ Yè»¸è¨ˆç®—: p5=', formatPaceDebug(p5), 'p95=', formatPaceDebug(p95));
                return {
                    min: Math.max(60, p5 - pPadding),   // æœ€é€Ÿã§ã‚‚1:00/100m
                    max: Math.min(300, p95 + pPadding)  // æœ€é…ã§ã‚‚5:00/100m
                };
            }
            
            // ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆ
            return { 
                min: Math.max(0, Math.floor(minVal - padding)), 
                max: Math.ceil(maxVal + padding) 
            };
        }
        
        // ã‚¹ã‚¤ãƒ ã®ã‚¿ãƒ¼ãƒ³å˜ä½ï¼ˆ25m/50mï¼‰å¹³å‡ãƒšãƒ¼ã‚¹ã‚’è¨ˆç®—
        function calculateSwimLapPaces(velocityData, distanceData, poolLength = 25) {
            if (!velocityData || !distanceData || velocityData.length === 0) {
                return { labels: [], paces: [] };
            }
            
            // ãƒ‡ãƒãƒƒã‚°: velocity_smoothã®çµ±è¨ˆã‚’å‡ºåŠ›
            const validVelocities = velocityData.filter(v => v > 0);
            console.log('=== ã‚¹ã‚¤ãƒ ãƒšãƒ¼ã‚¹ãƒ‡ãƒãƒƒã‚° ===');
            console.log('velocity_smooth ã‚µãƒ³ãƒ—ãƒ«æ•°:', velocityData.length);
            console.log('æœ‰åŠ¹ãªé€Ÿåº¦ãƒ‡ãƒ¼ã‚¿æ•°:', validVelocities.length);
            console.log('é€Ÿåº¦ æœ€å°å€¤ (m/s):', Math.min(...validVelocities).toFixed(3));
            console.log('é€Ÿåº¦ æœ€å¤§å€¤ (m/s):', Math.max(...validVelocities).toFixed(3));
            console.log('é€Ÿåº¦ å¹³å‡å€¤ (m/s):', (validVelocities.reduce((a,b)=>a+b,0)/validVelocities.length).toFixed(3));
            // ãƒšãƒ¼ã‚¹æ›ç®—
            const minVel = Math.min(...validVelocities);
            const maxVel = Math.max(...validVelocities);
            console.log('ãƒšãƒ¼ã‚¹æ›ç®— æœ€é€Ÿ (sec/100m):', (100/maxVel).toFixed(1), '=', formatPaceDebug(100/maxVel));
            console.log('ãƒšãƒ¼ã‚¹æ›ç®— æœ€é… (sec/100m):', (100/minVel).toFixed(1), '=', formatPaceDebug(100/minVel));
            
            const labels = [];
            const paces = [];
            
            let currentLapStart = 0;
            let lapNumber = 1;
            
            // å„ãƒ©ãƒƒãƒ—ã®é–‹å§‹ãƒ»çµ‚äº†ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ã‚’ç‰¹å®šã—ã¦å¹³å‡ãƒšãƒ¼ã‚¹ã‚’è¨ˆç®—
            for (let targetDist = poolLength; targetDist <= distanceData[distanceData.length - 1]; targetDist += poolLength) {
                // ã“ã®ãƒ©ãƒƒãƒ—ã®çµ‚äº†ä½ç½®ã‚’è¦‹ã¤ã‘ã‚‹
                let lapEnd = currentLapStart;
                while (lapEnd < distanceData.length && distanceData[lapEnd] < targetDist) {
                    lapEnd++;
                }
                
                if (lapEnd <= currentLapStart) {
                    currentLapStart = lapEnd;
                    continue;
                }
                
                // ã“ã®ãƒ©ãƒƒãƒ—å†…ã®æœ‰åŠ¹ãªé€Ÿåº¦ãƒ‡ãƒ¼ã‚¿ã‚’åé›†
                const lapVelocities = [];
                for (let i = currentLapStart; i < lapEnd; i++) {
                    const vel = velocityData[i];
                    // æœ‰åŠ¹ãªé€Ÿåº¦ã®ã¿ã‚’ä½¿ç”¨ï¼ˆ0.2 m/s = 8:20/100m ã‚ˆã‚Šé€Ÿã„ã‚‚ã®ï¼‰
                    if (vel && vel > 0.2) {
                        lapVelocities.push(vel);
                    }
                }
                
                if (lapVelocities.length > 0) {
                    // å¹³å‡é€Ÿåº¦ã‚’è¨ˆç®—
                    const avgVelocity = lapVelocities.reduce((a, b) => a + b, 0) / lapVelocities.length;
                    // ãƒšãƒ¼ã‚¹ï¼ˆç§’/100mï¼‰ã«å¤‰æ›
                    const paceSeconds = 100 / avgVelocity;
                    
                    labels.push(targetDist); // ãƒ©ãƒƒãƒ—çµ‚äº†åœ°ç‚¹ã®è·é›¢
                    paces.push(paceSeconds);
                    
                    // ç•°å¸¸å€¤ã®ãƒ‡ãƒãƒƒã‚°
                    if (paceSeconds < 90 || paceSeconds > 200) {
                        console.log(`ãƒ©ãƒƒãƒ—${lapNumber} (${targetDist}m): ç•°å¸¸ãƒšãƒ¼ã‚¹ ${formatPaceDebug(paceSeconds)}, å¹³å‡é€Ÿåº¦=${avgVelocity.toFixed(3)}m/s, ã‚µãƒ³ãƒ—ãƒ«æ•°=${lapVelocities.length}`);
                    }
                }
                
                currentLapStart = lapEnd;
                lapNumber++;
            }
            
            console.log('è¨ˆç®—ã•ã‚ŒãŸãƒ©ãƒƒãƒ—æ•°:', paces.length);
            console.log('ãƒšãƒ¼ã‚¹ç¯„å›²:', formatPaceDebug(Math.min(...paces)), 'ã€œ', formatPaceDebug(Math.max(...paces)));
            console.log('=========================');
            
            return { labels, paces };
        }
        
        // ãƒ‡ãƒãƒƒã‚°ç”¨ãƒšãƒ¼ã‚¹ãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆ
        function formatPaceDebug(seconds) {
            const min = Math.floor(seconds / 60);
            const sec = Math.round(seconds % 60);
            return `${min}:${String(sec).padStart(2, '0')}/100m`;
        }
        
        // ãƒ—ãƒ¼ãƒ«é•·ã‚’æ¨å®šï¼ˆã‚¢ã‚¯ãƒ†ã‚£ãƒ“ãƒ†ã‚£ãƒ‡ãƒ¼ã‚¿ã¾ãŸã¯ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆå€¤ã‹ã‚‰ï¼‰
        function detectPoolLength() {
            // Stravaã‚¢ã‚¯ãƒ†ã‚£ãƒ“ãƒ†ã‚£ã‹ã‚‰ãƒ—ãƒ¼ãƒ«é•·ã‚’å–å¾—ï¼ˆpool_lengthãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ãŒã‚ã‚‹å ´åˆï¼‰
            if (currentActivity.pool_length) {
                return currentActivity.pool_length;
            }
            // è·é›¢ã‹ã‚‰æ¨æ¸¬ï¼ˆ25mãƒ—ãƒ¼ãƒ«ã‹50mãƒ—ãƒ¼ãƒ«ã‹ï¼‰
            // é€šå¸¸ã€25mãƒ—ãƒ¼ãƒ«ãŒå¤šã„ã®ã§ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã¯25m
            return 25;
        }
        
        function renderSportSpecificCharts() {
            const sportCategory = getSportCategory(currentActivity.sport_type || currentActivity.type);
            
            if (sportCategory === 'bike') {
                renderBikeCharts();
            } else if (sportCategory === 'run') {
                renderRunCharts();
            }
        }
        
        function renderBikeCharts() {
            // ãƒ‘ãƒ¯ãƒ¼ãƒãƒ£ãƒ¼ãƒˆ
            if (streamData && streamData.watts && streamData.watts.data) {
                // ãƒ‘ãƒ¯ãƒ¼ãƒ¡ãƒˆãƒªã‚¯ã‚¹
                const avgPower = currentActivity.average_watts || 0;
                const np = currentActivity.weighted_average_watts || 0;
                const vi = avgPower > 0 ? (np / avgPower).toFixed(2) : '-';
                document.getElementById('powerMetrics').innerHTML = `
                    <div class="sport-metric-item">
                        <div class="sport-metric-value">${Math.round(avgPower)}</div>
                        <div class="sport-metric-label">å¹³å‡ãƒ‘ãƒ¯ãƒ¼ (W)</div>
                    </div>
                    <div class="sport-metric-item">
                        <div class="sport-metric-value">${Math.round(np)}</div>
                        <div class="sport-metric-label">NP (W)</div>
                    </div>
                    <div class="sport-metric-item">
                        <div class="sport-metric-value">${vi}</div>
                        <div class="sport-metric-label">VI</div>
                    </div>
                `;
                
                renderTimeSeriesChart('powerChart', streamData.watts.data, 'ãƒ‘ãƒ¯ãƒ¼', '#8b5cf6', 'W', 'power');
            }
            
            // ã‚±ã‚¤ãƒ‡ãƒ³ã‚¹ãƒãƒ£ãƒ¼ãƒˆ
            if (streamData && streamData.cadence && streamData.cadence.data) {
                const avgCadence = currentActivity.average_cadence || 0;
                document.getElementById('cadenceMetrics').innerHTML = `
                    <div class="sport-metric-item">
                        <div class="sport-metric-value">${Math.round(avgCadence)}</div>
                        <div class="sport-metric-label">å¹³å‡ã‚±ã‚¤ãƒ‡ãƒ³ã‚¹ (rpm)</div>
                    </div>
                `;
                
                renderTimeSeriesChart('cadenceChart', streamData.cadence.data, 'ã‚±ã‚¤ãƒ‡ãƒ³ã‚¹', '#22c55e', 'rpm', 'cadence');
            }
        }
        
        function renderRunCharts() {
            // ãƒ”ãƒƒãƒ/ã‚±ã‚¤ãƒ‡ãƒ³ã‚¹ãƒãƒ£ãƒ¼ãƒˆ
            if (streamData && streamData.cadence && streamData.cadence.data) {
                const avgCadence = currentActivity.average_cadence || 0;
                document.getElementById('cadenceMetrics').innerHTML = `
                    <div class="sport-metric-item">
                        <div class="sport-metric-value">${Math.round(avgCadence * 2)}</div>
                        <div class="sport-metric-label">å¹³å‡ãƒ”ãƒƒãƒ (spm)</div>
                    </div>
                `;
                
                // ãƒ©ãƒ³ã®å ´åˆã¯ã‚±ã‚¤ãƒ‡ãƒ³ã‚¹ã‚’2å€ï¼ˆå·¦å³åˆè¨ˆï¼‰
                const pitchData = streamData.cadence.data.map(c => c * 2);
                renderTimeSeriesChart('cadenceChart', pitchData, 'ãƒ”ãƒƒãƒ', '#22c55e', 'spm', 'cadence');
            }
        }
        
        function renderTimeSeriesChart(canvasId, data, label, color, unit, chartKey) {
            const ctx = document.getElementById(canvasId).getContext('2d');
            if (charts[chartKey]) charts[chartKey].destroy();
            
            const sportCategory = getSportCategory(currentActivity.sport_type || currentActivity.type);
            const distanceData = streamData?.distance?.data;
            const timeData = streamData?.time?.data || data.map((_, i) => i);
            const altitudeData = streamData?.altitude?.data;
            
            const maxPoints = 500;
            const step = Math.max(1, Math.floor(data.length / maxPoints));
            
            const labels = [];
            const chartData = [];
            const altData = [];
            const validValues = []; // Yè»¸ç¯„å›²è¨ˆç®—ç”¨
            
            // ãƒ”ãƒƒãƒ/ã‚±ã‚¤ãƒ‡ãƒ³ã‚¹ã®æœ‰åŠ¹ç¯„å›²ã‚’å®šç¾©
            const isRunPitch = chartKey === 'cadence' && sportCategory === 'run';
            const isBikeCadence = chartKey === 'cadence' && sportCategory === 'bike';
            const isPower = chartKey === 'power';
            
            // æœ‰åŠ¹å€¤ã®ç¯„å›²
            let minValid = 0, maxValid = Infinity;
            if (isRunPitch) {
                minValid = 120; // æœ€ä½120spm
                maxValid = 240; // æœ€é«˜240spm
            } else if (isBikeCadence) {
                minValid = 30;  // æœ€ä½30rpm
                maxValid = 150; // æœ€é«˜150rpm
            } else if (isPower) {
                minValid = 0;
                maxValid = 2000;
            }
            
            for (let i = 0; i < data.length; i += step) {
                if (distanceData) {
                    if (sportCategory === 'swim') {
                        labels.push(Math.round(distanceData[i]));
                    } else {
                        labels.push((distanceData[i] / 1000).toFixed(1));
                    }
                } else {
                    labels.push(formatDurationShort(timeData[i]));
                }
                
                const value = data[i];
                chartData.push(value);
                
                // æ¨™é«˜ãƒ‡ãƒ¼ã‚¿
                if (altitudeData && i < altitudeData.length) {
                    altData.push(altitudeData[i]);
                }
                
                // Yè»¸ç¯„å›²è¨ˆç®—ç”¨ã«æœ‰åŠ¹å€¤ã‚’åé›†
                if (value >= minValid && value <= maxValid) {
                    validValues.push(value);
                }
            }
            
            // Yè»¸ç¯„å›²ã‚’è¨ˆç®—ï¼ˆãƒ©ãƒ³ã¨ãƒã‚¤ã‚¯ã¯å…¨ãƒ‡ãƒ¼ã‚¿è¡¨ç¤ºã€ã‚¹ã‚¤ãƒ ã¯ãƒ‘ãƒ¼ã‚»ãƒ³ã‚¿ã‚¤ãƒ«ï¼‰
            let yMin, yMax;
            if (validValues.length > 0) {
                const sorted = [...validValues].sort((a, b) => a - b);
                const minVal = sorted[0];
                const maxVal = sorted[sorted.length - 1];
                
                if (sportCategory === 'swim') {
                    // ã‚¹ã‚¤ãƒ ã¯ãƒ‘ãƒ¼ã‚»ãƒ³ã‚¿ã‚¤ãƒ«ãƒ™ãƒ¼ã‚¹ã§è¡¨ç¤ºç¯„å›²ã‚’åˆ¶é™
                    const p5 = sorted[Math.floor(sorted.length * 0.05)];
                    const p95 = sorted[Math.floor(sorted.length * 0.95)];
                    const range = p95 - p5;
                    const padding = range * 0.1;
                    yMin = Math.max(minValid, Math.floor(p5 - padding));
                    yMax = Math.min(maxValid, Math.ceil(p95 + padding));
                } else {
                    // ãƒ©ãƒ³ã¨ãƒã‚¤ã‚¯ã¯0ã‹ã‚‰æœ€å¤§å€¤ã¾ã§å…¨ãƒ‡ãƒ¼ã‚¿è¡¨ç¤º
                    const padding = (maxVal - minVal) * 0.05;
                    yMin = Math.max(0, Math.floor(minVal - padding));
                    yMax = Math.ceil(maxVal + padding);
                }
            }
            
            // ãƒ‡ãƒ¼ã‚¿ã‚»ãƒƒãƒˆ
            const datasets = [];
            
            // æ¨™é«˜èƒŒæ™¯ï¼ˆãƒã‚¤ã‚¯ã€ãƒ©ãƒ³ã®ã¿ï¼‰
            if (altData.length > 0 && sportCategory !== 'swim') {
                datasets.push({
                    label: 'æ¨™é«˜',
                    data: altData,
                    borderColor: 'rgba(156, 163, 175, 0.3)',
                    backgroundColor: 'rgba(156, 163, 175, 0.15)',
                    borderWidth: 1,
                    fill: true,
                    tension: 0.2,
                    pointRadius: 0,
                    yAxisID: 'y1'
                });
            }
            
            // ãƒ¡ã‚¤ãƒ³ãƒ‡ãƒ¼ã‚¿
            datasets.push({
                label: label,
                data: chartData,
                borderColor: color,
                borderWidth: 1.5,
                fill: false,
                tension: 0.2,
                pointRadius: 0,
                yAxisID: 'y'
            });
            
            const scales = {
                x: { 
                    title: { display: true, text: distanceData ? (sportCategory === 'swim' ? 'è·é›¢ (m)' : 'è·é›¢ (km)') : 'æ™‚é–“' },
                    ticks: {
                        maxTicksLimit: sportCategory === 'swim' ? 10 : 12,
                        callback: function(value, index) {
                            const label = this.getLabelForValue(value);
                            if (sportCategory === 'swim' && distanceData) {
                                const dist = parseFloat(label);
                                if (dist % 200 === 0 || index === 0) {
                                    return label;
                                }
                                return '';
                            }
                            return label;
                        }
                    }
                },
                y: { 
                    type: 'linear',
                    position: 'left',
                    title: { display: true, text: unit },
                    min: yMin,
                    max: yMax
                }
            };
            
            // æ¨™é«˜ç”¨Yè»¸
            if (altData.length > 0 && sportCategory !== 'swim') {
                scales.y1 = {
                    type: 'linear',
                    position: 'right',
                    title: { display: true, text: 'æ¨™é«˜ (m)' },
                    grid: { drawOnChartArea: false },
                    min: Math.min(...altData) - 10,
                    max: Math.max(...altData) + 10
                };
            }
            
            charts[chartKey] = new Chart(ctx, {
                type: 'line',
                data: { labels: labels, datasets: datasets },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: { legend: { display: altData.length > 0 && sportCategory !== 'swim' } },
                    scales: scales,
                    interaction: {
                        intersect: false,
                        mode: 'index'
                    }
                }
            });
        }
        
        function renderLapTable() {
            if (!currentActivity.laps || currentActivity.laps.length === 0) {
                return;
            }
            
            document.getElementById('lapSection').style.display = 'block';
            const sportCategory = getSportCategory(currentActivity.sport_type || currentActivity.type);
            
            // ã‚¹ã‚¤ãƒ ã®å ´åˆã¯ãƒ©ãƒƒãƒ—ãƒ‡ãƒ¼ã‚¿ã®è©³ç´°ã‚’ãƒ‡ãƒãƒƒã‚°å‡ºåŠ›
            if (sportCategory === 'swim') {
                console.log('=== ã‚¹ã‚¤ãƒ ãƒ©ãƒƒãƒ—ãƒ‡ãƒ¼ã‚¿ (FORM/Stravaã‹ã‚‰) ===');
                console.log('ãƒ©ãƒƒãƒ—æ•°:', currentActivity.laps.length);
                currentActivity.laps.forEach((lap, i) => {
                    console.log(`Lap ${i+1}:`, {
                        distance: lap.distance,
                        elapsed_time: lap.elapsed_time,
                        moving_time: lap.moving_time,
                        average_speed: lap.average_speed,
                        average_cadence: lap.average_cadence,
                        total_strokes: lap.total_strokes,
                        average_heartrate: lap.average_heartrate,
                        lap_index: lap.lap_index,
                        start_index: lap.start_index,
                        end_index: lap.end_index,
                        // å…¨ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã‚’å‡ºåŠ›
                        raw: lap
                    });
                });
                console.log('========================================');
            }
            
            let html = `
                <thead>
                    <tr>
                        <th>Lap</th>
                        <th>è·é›¢</th>
                        ${sportCategory !== 'run' ? '<th>æ™‚é–“</th>' : ''}
                        <th>${sportCategory === 'bike' ? 'é€Ÿåº¦' : 'ãƒšãƒ¼ã‚¹'}</th>
                        <th>å¿ƒæ‹</th>
                        ${sportCategory === 'bike' ? '<th>ãƒ‘ãƒ¯ãƒ¼</th>' : ''}
                        ${sportCategory === 'run' ? '<th>ãƒ”ãƒƒãƒ</th><th>ã‚¹ãƒˆãƒ©ã‚¤ãƒ‰</th>' : ''}
                        ${sportCategory === 'swim' ? '<th>Strokes</th><th>Rate</th><th>DPS</th>' : ''}
                    </tr>
                </thead>
                <tbody>
            `;
            
            currentActivity.laps.forEach((lap, index) => {
                let pace, distance;
                
                if (sportCategory === 'bike') {
                    pace = `${(lap.average_speed * 3.6).toFixed(1)} km/h`;
                    distance = `${(lap.distance / 1000).toFixed(2)} km`;
                } else if (sportCategory === 'swim') {
                    // ã‚¹ã‚¤ãƒ : ãƒšãƒ¼ã‚¹ã‚’ç§’/100mã§è¡¨ç¤º
                    let paceSeconds = null;
                    const movingTime = lap.moving_time || 0;
                    
                    if (lap.average_speed && lap.average_speed > 0) {
                        paceSeconds = 100 / lap.average_speed;
                    } else if (movingTime > 0 && lap.distance > 0) {
                        paceSeconds = (movingTime / lap.distance) * 100;
                    }
                    
                    // ãƒ¬ã‚¹ãƒˆåˆ¤å®š: 10ç§’æœªæº€ or ç•°å¸¸ã«é€Ÿã„ãƒšãƒ¼ã‚¹(60ç§’/100mæœªæº€) or ç•°å¸¸ã«é…ã„ãƒšãƒ¼ã‚¹(300ç§’/100mè¶…)
                    const isRest = movingTime < 10 || 
                                   (paceSeconds && paceSeconds < 60) || 
                                   (paceSeconds && paceSeconds > 300) ||
                                   !paceSeconds;
                    
                    if (isRest) {
                        pace = '<span style="color: #9ca3af;">REST</span>';
                    } else {
                        pace = formatPaceDebug(paceSeconds);
                    }
                    distance = `${Math.round(lap.distance)}m`;
                } else {
                    pace = formatRunPace(lap.average_speed);
                    distance = `${(lap.distance / 1000).toFixed(2)} km`;
                }
                
                // ã‚¹ã‚¤ãƒ ç”¨ã®ã‚¹ãƒˆãƒ­ãƒ¼ã‚¯æ•°è¨ˆç®—
                // total_strokesãŒã‚ã‚Œã°ãã‚Œã‚’ä½¿ã„ã€ãªã‘ã‚Œã°average_cadenceã¨æ™‚é–“ã‹ã‚‰è¨ˆç®—
                let strokes = lap.total_strokes;
                if (!strokes && lap.average_cadence && lap.moving_time) {
                    // Strokes = Rate(spm) Ã— Time(ç§’) / 60
                    strokes = Math.round(lap.average_cadence * lap.moving_time / 60);
                }
                
                // ã‚¹ã‚¤ãƒ ç”¨ã®DPSè¨ˆç®—ï¼ˆDistance Per Strokeï¼‰
                let dps = '-';
                if (sportCategory === 'swim' && strokes && strokes > 0 && lap.distance > 0) {
                    dps = (lap.distance / strokes).toFixed(2) + 'm';
                }
                
                // ã‚¹ã‚¤ãƒ ç”¨ã®ã‚¹ãƒˆãƒ­ãƒ¼ã‚¯ãƒ¬ãƒ¼ãƒˆè¡¨ç¤º
                let strokeRate = '-';
                if (sportCategory === 'swim' && lap.average_cadence) {
                    strokeRate = Math.round(lap.average_cadence) + ' spm';
                }
                
                // ãƒ©ãƒ³ç”¨ã®ãƒ”ãƒƒãƒã¨ã‚¹ãƒˆãƒ©ã‚¤ãƒ‰é•·è¨ˆç®—
                let runPitch = '-';
                let runStride = '-';
                if (sportCategory === 'run') {
                    // ãƒ”ãƒƒãƒï¼ˆã‚±ã‚¤ãƒ‡ãƒ³ã‚¹ï¼‰- Stravaã¯ç‰‡è¶³ã®ã‚¹ãƒ†ãƒƒãƒ—æ•°ã‚’è¿”ã™ã®ã§2å€
                    if (lap.average_cadence) {
                        runPitch = Math.round(lap.average_cadence * 2) + ' spm';
                    }
                    // ã‚¹ãƒˆãƒ©ã‚¤ãƒ‰é•· = è·é›¢ / (ãƒ”ãƒƒãƒ * æ™‚é–“(åˆ†))
                    // ãƒ”ãƒƒãƒã¯steps per minuteï¼ˆä¸¡è¶³åˆè¨ˆï¼‰ã€æ™‚é–“ã¯ç§’ãªã®ã§åˆ†ã«å¤‰æ›
                    if (lap.average_cadence && lap.moving_time && lap.distance) {
                        const timeMinutes = lap.moving_time / 60;
                        const totalSteps = lap.average_cadence * 2 * timeMinutes; // ä¸¡è¶³åˆè¨ˆã‚¹ãƒ†ãƒƒãƒ—æ•°
                        const stride = lap.distance / totalSteps;
                        runStride = stride.toFixed(2) + 'm';
                    }
                }
                
                html += `
                    <tr>
                        <td>${index + 1}</td>
                        <td>${distance}</td>
                        ${sportCategory !== 'run' ? `<td>${formatDuration(lap.moving_time || lap.elapsed_time)}</td>` : ''}
                        <td>${pace}</td>
                        <td>${lap.average_heartrate ? Math.round(lap.average_heartrate) : '-'}</td>
                        ${sportCategory === 'bike' ? `<td>${lap.average_watts ? Math.round(lap.average_watts) : '-'} W</td>` : ''}
                        ${sportCategory === 'run' ? `<td>${runPitch}</td><td>${runStride}</td>` : ''}
                        ${sportCategory === 'swim' ? `<td>${strokes || '-'}</td><td>${strokeRate}</td><td>${dps}</td>` : ''}
                    </tr>
                `;
            });
            
            html += '</tbody>';
            document.getElementById('lapTable').innerHTML = html;
        }
        
        // ===== ã‚¹ãƒˆãƒªãƒ¼ãƒ ãƒ‡ãƒ¼ã‚¿åˆ†æ =====
        function analyzeStreamData() {
            if (!streamData) return null;
            
            const analysis = {};
            const sportCategory = getSportCategory(currentActivity.sport_type || currentActivity.type);
            
            // ãƒšãƒ¼ã‚¹åˆ†æ
            if (streamData.velocity_smooth && streamData.velocity_smooth.data && streamData.distance?.data) {
                const velData = streamData.velocity_smooth.data;
                const distData = streamData.distance.data;
                const totalDist = distData[distData.length - 1];
                const halfDist = totalDist / 2;
                
                // å‰åŠãƒ»å¾ŒåŠã®ãƒšãƒ¼ã‚¹ã‚’è¨ˆç®—
                let firstHalfVels = [];
                let secondHalfVels = [];
                
                for (let i = 0; i < velData.length; i++) {
                    if (velData[i] > 0.5) { // åœæ­¢ã‚’é™¤å¤–
                        if (distData[i] <= halfDist) {
                            firstHalfVels.push(velData[i]);
                        } else {
                            secondHalfVels.push(velData[i]);
                        }
                    }
                }
                
                const avgFirstHalf = firstHalfVels.length > 0 ? firstHalfVels.reduce((a, b) => a + b, 0) / firstHalfVels.length : 0;
                const avgSecondHalf = secondHalfVels.length > 0 ? secondHalfVels.reduce((a, b) => a + b, 0) / secondHalfVels.length : 0;
                
                // ãƒšãƒ¼ã‚¹å¤‰å‹•ä¿‚æ•°
                const validVels = velData.filter(v => v > 0.5);
                const meanVel = validVels.reduce((a, b) => a + b, 0) / validVels.length;
                const variance = validVels.reduce((sum, v) => sum + Math.pow(v - meanVel, 2), 0) / validVels.length;
                const stdDev = Math.sqrt(variance);
                const cv = (stdDev / meanVel) * 100;
                
                // ã‚¹ãƒ—ãƒªãƒƒãƒˆã‚¿ã‚¤ãƒ—
                const splitDiff = ((avgSecondHalf / avgFirstHalf) - 1) * 100;
                let splitType = 'å‡ç­‰';
                if (splitDiff > 3) splitType = 'ãƒã‚¬ãƒ†ã‚£ãƒ–ï¼ˆå¾ŒåŠãƒšãƒ¼ã‚¹ã‚¢ãƒƒãƒ—ï¼‰';
                else if (splitDiff < -3) splitType = 'ãƒã‚¸ãƒ†ã‚£ãƒ–ï¼ˆå¾ŒåŠãƒšãƒ¼ã‚¹ãƒ€ã‚¦ãƒ³ï¼‰';
                
                analysis.paceAnalysis = {
                    firstHalfPace: formatPaceFromSpeed(avgFirstHalf, sportCategory),
                    secondHalfPace: formatPaceFromSpeed(avgSecondHalf, sportCategory),
                    splitType: splitType,
                    splitDiff: `${splitDiff > 0 ? '+' : ''}${splitDiff.toFixed(1)}%`,
                    variability: cv.toFixed(1)
                };
                
                // æœ€é€Ÿãƒ»æœ€é…åŒºé–“ï¼ˆ1kmå˜ä½ã§åˆ†æï¼‰
                if (sportCategory !== 'swim') {
                    const kmSections = [];
                    let currentKm = 1000;
                    let sectionVels = [];
                    
                    for (let i = 0; i < distData.length; i++) {
                        if (distData[i] <= currentKm) {
                            if (velData[i] > 0.5) sectionVels.push(velData[i]);
                        } else {
                            if (sectionVels.length > 0) {
                                const avgVel = sectionVels.reduce((a, b) => a + b, 0) / sectionVels.length;
                                kmSections.push({ km: Math.floor(currentKm / 1000), pace: avgVel });
                            }
                            currentKm += 1000;
                            sectionVels = [velData[i]];
                        }
                    }
                    
                    if (kmSections.length > 0) {
                        const fastest = kmSections.reduce((max, s) => s.pace > max.pace ? s : max);
                        const slowest = kmSections.reduce((min, s) => s.pace < min.pace ? s : min);
                        analysis.paceAnalysis.fastestSection = `${fastest.km}kmç›® (${formatPaceFromSpeed(fastest.pace, sportCategory)})`;
                        analysis.paceAnalysis.slowestSection = `${slowest.km}kmç›® (${formatPaceFromSpeed(slowest.pace, sportCategory)})`;
                    }
                }
            }
            
            // å¿ƒæ‹åˆ†æ
            if (streamData.heartrate && streamData.heartrate.data) {
                const hrData = streamData.heartrate.data;
                const validHr = hrData.filter(h => h > 0);
                
                if (validHr.length > 0) {
                    const thresholds = getUserThresholds();
                    const maxHr = thresholds.maxHr || 190;
                    
                    // å‰åŠãƒ»å¾ŒåŠã®å¿ƒæ‹æ¯”è¼ƒï¼ˆãƒ‰ãƒªãƒ•ãƒˆï¼‰
                    const midPoint = Math.floor(validHr.length / 2);
                    const firstHalfHr = validHr.slice(0, midPoint);
                    const secondHalfHr = validHr.slice(midPoint);
                    
                    const avgFirstHr = firstHalfHr.reduce((a, b) => a + b, 0) / firstHalfHr.length;
                    const avgSecondHr = secondHalfHr.reduce((a, b) => a + b, 0) / secondHalfHr.length;
                    const drift = ((avgSecondHr / avgFirstHr) - 1) * 100;
                    
                    // Zoneåˆ†å¸ƒ
                    const zones = { z1: 0, z2: 0, z3: 0, z4: 0, z5: 0 };
                    validHr.forEach(hr => {
                        const percent = (hr / maxHr) * 100;
                        if (percent < 60) zones.z1++;
                        else if (percent < 70) zones.z2++;
                        else if (percent < 80) zones.z3++;
                        else if (percent < 90) zones.z4++;
                        else zones.z5++;
                    });
                    
                    const total = validHr.length;
                    Object.keys(zones).forEach(z => {
                        zones[z] = Math.round((zones[z] / total) * 100);
                    });
                    
                    // å¿ƒæ‹åŠ¹ç‡ï¼ˆãƒšãƒ¼ã‚¹ãŒã‚ã‚‹å ´åˆï¼‰
                    let efficiency = null;
                    if (currentActivity.average_speed && currentActivity.average_heartrate) {
                        // å¿ƒæ‹1bpmã‚ãŸã‚Šã®ãƒšãƒ¼ã‚¹ï¼ˆæ•°å€¤ãŒå°ã•ã„ã»ã©åŠ¹ç‡çš„ï¼‰
                        const pacePerKm = 1000 / currentActivity.average_speed / 60;
                        efficiency = (currentActivity.average_heartrate / pacePerKm).toFixed(1);
                    }
                    
                    analysis.heartRateAnalysis = {
                        drift: drift.toFixed(1),
                        zones: zones,
                        efficiency: efficiency
                    };
                }
            }
            
            // æ¨™é«˜åˆ†æ
            if (streamData.altitude && streamData.altitude.data && streamData.velocity_smooth?.data) {
                const altData = streamData.altitude.data;
                const velData = streamData.velocity_smooth.data;
                const gradeData = streamData.grade_smooth?.data;
                
                if (gradeData) {
                    // ç™»ã‚Šãƒ»å¹³åœ°ãƒ»ä¸‹ã‚Šã§ã®ãƒšãƒ¼ã‚¹æ¯”è¼ƒ
                    const climbVels = [];
                    const flatVels = [];
                    const descentVels = [];
                    
                    for (let i = 0; i < gradeData.length; i++) {
                        if (velData[i] > 0.5) {
                            if (gradeData[i] > 2) climbVels.push(velData[i]);
                            else if (gradeData[i] < -2) descentVels.push(velData[i]);
                            else flatVels.push(velData[i]);
                        }
                    }
                    
                    if (climbVels.length > 0 && flatVels.length > 0) {
                        const avgClimb = climbVels.reduce((a, b) => a + b, 0) / climbVels.length;
                        const avgFlat = flatVels.reduce((a, b) => a + b, 0) / flatVels.length;
                        const climbLoss = ((avgFlat / avgClimb) - 1) * 100;
                        
                        analysis.elevationAnalysis = {
                            climbingPaceLoss: climbLoss.toFixed(0)
                        };
                    }
                }
            }
            
            return Object.keys(analysis).length > 0 ? analysis : null;
        }
        
        function formatPaceFromSpeed(speed, sportCategory) {
            if (!speed || speed <= 0) return '-';
            if (sportCategory === 'bike') {
                return `${(speed * 3.6).toFixed(1)} km/h`;
            } else if (sportCategory === 'swim') {
                const pace = 100 / speed;
                const min = Math.floor(pace / 60);
                const sec = Math.round(pace % 60);
                return `${min}:${String(sec).padStart(2, '0')}/100m`;
            } else {
                const pace = 1000 / speed / 60;
                const min = Math.floor(pace);
                const sec = Math.round((pace - min) * 60);
                return `${min}:${String(sec).padStart(2, '0')}/km`;
            }
        }
        
        // ===== é¡ä¼¼ã‚¢ã‚¯ãƒ†ã‚£ãƒ“ãƒ†ã‚£æ¤œç´¢ =====
        function findSimilarActivities() {
            const cachedActivities = localStorage.getItem('strava_activities');
            if (!cachedActivities) return [];
            
            const activities = JSON.parse(cachedActivities);
            const currentSport = currentActivity.sport_type || currentActivity.type;
            const currentDist = currentActivity.distance || 0;
            const currentId = currentActivity.id;
            
            // åŒã˜ç¨®ç›®ã€è·é›¢ãŒÂ±30%ä»¥å†…ã®ã‚¢ã‚¯ãƒ†ã‚£ãƒ“ãƒ†ã‚£ã‚’æ¤œç´¢
            const similar = activities.filter(a => {
                if (a.id === currentId) return false;
                const sport = a.sport_type || a.type;
                if (sport !== currentSport) return false;
                
                const dist = a.distance || 0;
                const ratio = dist / currentDist;
                return ratio >= 0.7 && ratio <= 1.3;
            });
            
            // æ—¥ä»˜ã§é™é †ã‚½ãƒ¼ãƒˆã€æœ€æ–°3ä»¶ã‚’è¿”ã™
            similar.sort((a, b) => new Date(b.start_date) - new Date(a.start_date));
            return similar.slice(0, 5);
        }
        
        // ===== AIã‚³ãƒ¼ãƒï¼ˆã‚»ãƒƒã‚·ãƒ§ãƒ³ã‚¿ã‚¤ãƒ—é¸æŠç‰ˆï¼‰ =====
        
        // ã‚»ãƒƒã‚·ãƒ§ãƒ³ã‚¿ã‚¤ãƒ—é¸æŠUIã‚’åˆæœŸåŒ–
        function initSessionTypeSelector() {
            const sportType = currentActivity.sport_type || currentActivity.type;
            const sportCategory = getSportCategory(sportType);
            
            // ç¨®ç›®ã«å¿œã˜ãŸé¸æŠè‚¢ã‚’å–å¾—
            let options = [];
            if (sportCategory === 'swim') {
                options = SESSION_TYPES.swim;
            } else if (sportCategory === 'bike') {
                options = SESSION_TYPES.bike;
            } else if (sportCategory === 'run') {
                options = SESSION_TYPES.run;
            }
            // å…±é€šã‚ªãƒ—ã‚·ãƒ§ãƒ³ã‚’è¿½åŠ 
            options = options.concat(SESSION_TYPES.common);
            
            // ã‚°ãƒªãƒƒãƒ‰ã«ãƒœã‚¿ãƒ³ã‚’ç”Ÿæˆ
            const grid = document.getElementById('sessionTypeGrid');
            if (!grid) return;
            
            grid.innerHTML = '';
            
            options.forEach(function(opt) {
                const btn = document.createElement('button');
                btn.className = 'session-type-btn';
                btn.dataset.type = opt.id;
                btn.innerHTML = `
                    <span class="session-type-btn-label">${opt.label}</span>
                    <span class="session-type-btn-desc">${opt.description}</span>
                `;
                btn.addEventListener('click', function() {
                    selectSessionType(opt.id, opt.label);
                });
                grid.appendChild(btn);
            });
            
            // ãƒœã‚¿ãƒ³ã‚¤ãƒ™ãƒ³ãƒˆè¨­å®š
            const generateBtn = document.getElementById('generateCommentBtn');
            if (generateBtn) {
                generateBtn.addEventListener('click', generateAIComment);
            }
        }

        // ã‚»ãƒƒã‚·ãƒ§ãƒ³ã‚¿ã‚¤ãƒ—ã‚’é¸æŠ
        function selectSessionType(typeId, typeLabel) {
            // å‰ã®é¸æŠã‚’è§£é™¤
            document.querySelectorAll('.session-type-btn').forEach(function(btn) {
                btn.classList.remove('selected');
            });
            
            // æ–°ã—ã„é¸æŠã‚’ãƒãƒ¼ã‚¯
            const selectedBtn = document.querySelector(`.session-type-btn[data-type="${typeId}"]`);
            if (selectedBtn) {
                selectedBtn.classList.add('selected');
            }
            
            selectedSessionType = typeId;
            
            // ã€Œãã®ä»–ã€ã®å ´åˆã¯å…¥åŠ›æ¬„ã‚’è¡¨ç¤º
            const otherContainer = document.getElementById('otherInputContainer');
            if (typeId === 'other') {
                otherContainer.classList.add('visible');
            } else {
                otherContainer.classList.remove('visible');
            }
            
            // ãƒœã‚¿ãƒ³ã‚’æœ‰åŠ¹åŒ–
            document.getElementById('generateCommentBtn').disabled = false;
        }

        // ã‚³ãƒ¡ãƒ³ãƒˆç”Ÿæˆ
        async function generateAIComment() {
            if (!selectedSessionType) {
                alert('ã‚»ãƒƒã‚·ãƒ§ãƒ³ã‚¿ã‚¤ãƒ—ã‚’é¸æŠã—ã¦ãã ã•ã„');
                return;
            }
            
            const supplement = document.getElementById('sessionSupplement').value.trim();
            const otherInput = document.getElementById('otherInput').value.trim();
            
            // ã€Œãã®ä»–ã€ã®å ´åˆã¯å…¥åŠ›å†…å®¹ã‚’è£œè¶³ã«è¿½åŠ 
            let finalSupplement = supplement;
            if (selectedSessionType === 'other' && otherInput) {
                finalSupplement = otherInput + (supplement ? 'ã€‚' + supplement : '');
            }
            
            // Aãƒ¬ãƒ¼ã‚¹ç›®æ¨™ã‚’å–å¾—
            let raceGoal = null;
            try {
                const savedRace = localStorage.getItem('selected_race');
                const savedGoals = localStorage.getItem('race_goals');
                if (savedRace) {
                    const race = JSON.parse(savedRace);
                    raceGoal = {
                        raceName: race.name || race.raceName,
                        raceDate: race.date || race.raceDate,
                        raceDistance: race.distance || race.raceDistance
                    };
                    if (savedGoals) {
                        const goals = JSON.parse(savedGoals);
                        if (goals.goalTime) {
                            raceGoal.goalTime = goals.goalTime;
                        }
                    }
                }
            } catch (e) {
                console.log('Race goal not found:', e);
            }
            
            // UIæ›´æ–°
            document.getElementById('sessionTypeSelector').style.display = 'none';
            document.getElementById('aiCommentLoading').style.display = 'flex';
            document.getElementById('aiCommentResult').style.display = 'none';
            
            try {
                const streamAnalysis = analyzeStreamData();
                const similarActivities = findSimilarActivities();
                
                const response = await fetch('/.netlify/functions/ai-coach-comment', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        activity: currentActivity,
                        trainingStatus: trainingStatus,
                        streamAnalysis: streamAnalysis,
                        similarActivities: similarActivities,
                        sessionType: selectedSessionType,
                        sessionSupplement: finalSupplement,
                        raceGoal: raceGoal,
                        conversationHistory: []
                    })
                });
                
                if (!response.ok) {
                    throw new Error('ã‚³ãƒ¡ãƒ³ãƒˆç”Ÿæˆã«å¤±æ•—ã—ã¾ã—ãŸ');
                }
                
                const data = await response.json();
                
                // çµæœã‚’è¡¨ç¤º
                document.getElementById('aiCommentLoading').style.display = 'none';
                document.getElementById('aiCommentResult').style.display = 'block';
                document.getElementById('aiCommentText').innerHTML = formatAIComment(data.comment);
                document.getElementById('commentSessionType').textContent = getSessionTypeLabel(selectedSessionType);
                
                // ä¼šè©±å±¥æ­´ã«è¿½åŠ 
                conversationHistory = [
                    { role: 'assistant', content: data.comment }
                ];
                
            } catch (error) {
                console.error('AI comment error:', error);
                document.getElementById('aiCommentLoading').style.display = 'none';
                document.getElementById('sessionTypeSelector').style.display = 'block';
                alert('ã‚³ãƒ¡ãƒ³ãƒˆç”Ÿæˆã«å¤±æ•—ã—ã¾ã—ãŸ: ' + error.message);
            }
        }

        // ã‚»ãƒƒã‚·ãƒ§ãƒ³ã‚¿ã‚¤ãƒ—ã‚’å¤‰æ›´
        function changeSessionType() {
            document.getElementById('aiCommentResult').style.display = 'none';
            document.getElementById('sessionTypeSelector').style.display = 'block';
            document.getElementById('chatHistory').style.display = 'none';
            document.getElementById('chatHistory').innerHTML = '';
            conversationHistory = [];
        }

        // ã‚»ãƒƒã‚·ãƒ§ãƒ³ã‚¿ã‚¤ãƒ—ã®ãƒ©ãƒ™ãƒ«ã‚’å–å¾—
        function getSessionTypeLabel(typeId) {
            const allTypes = [
                ...SESSION_TYPES.swim,
                ...SESSION_TYPES.bike,
                ...SESSION_TYPES.run,
                ...SESSION_TYPES.common
            ];
            const found = allTypes.find(t => t.id === typeId);
            return found ? found.label : typeId;
        }

        // AIã‚³ãƒ¡ãƒ³ãƒˆã®Markdownã‚’æ•´å½¢
        function formatAIComment(text) {
            return text
                .replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>')
                .replace(/\n/g, '<br>');
        }
        
        // è³ªå•ã™ã‚‹
        async function askQuestion() {
            const input = document.getElementById('questionInput');
            const btn = document.getElementById('askBtn');
            const question = input.value.trim();
            
            if (!question) return;
            
            // å±¥æ­´ã‚’è¡¨ç¤º
            const historyEl = document.getElementById('chatHistory');
            historyEl.style.display = 'block';
            
            // ãƒ¦ãƒ¼ã‚¶ãƒ¼ã®è³ªå•ã‚’è¿½åŠ 
            addChatMessage('user', question);
            input.value = '';
            btn.disabled = true;
            btn.textContent = 'é€ä¿¡ä¸­...';
            
            try {
                const streamAnalysis = analyzeStreamData();
                
                conversationHistory.push({ role: 'user', content: question });
                
                const response = await fetch('/.netlify/functions/ai-coach-comment', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        activity: currentActivity,
                        trainingStatus: trainingStatus,
                        streamAnalysis: streamAnalysis,
                        sessionType: selectedSessionType,
                        userQuestion: question,
                        conversationHistory: conversationHistory
                    })
                });
                
                if (!response.ok) {
                    throw new Error('å›ç­”ã®ç”Ÿæˆã«å¤±æ•—ã—ã¾ã—ãŸ');
                }
                
                const data = await response.json();
                
                // å›ç­”ã‚’è¿½åŠ 
                addChatMessage('coach', data.comment);
                conversationHistory.push({ role: 'assistant', content: data.comment });
                
            } catch (error) {
                console.error('Question error:', error);
                addChatMessage('coach', 'ç”³ã—è¨³ã‚ã‚Šã¾ã›ã‚“ã€å›ç­”ã®ç”Ÿæˆã«å¤±æ•—ã—ã¾ã—ãŸã€‚ã—ã°ã‚‰ãã—ã¦ã‹ã‚‰ãŠè©¦ã—ãã ã•ã„ã€‚');
            }
            
            btn.disabled = false;
            btn.textContent = 'è³ªå•ã™ã‚‹';
        }
        
        function addChatMessage(type, content) {
            const historyEl = document.getElementById('chatHistory');
            const label = type === 'user' ? 'ğŸ‘¤ ã‚ãªãŸ' : 'ğŸ¤– AIã‚³ãƒ¼ãƒ';
            
            // ã‚³ãƒ¼ãƒã®å›ç­”ã¯Markdownãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆã‚’é©ç”¨
            const formattedContent = type === 'coach' ? formatAIComment(content) : content;
            
            const messageHtml = `
                <div class="chat-message ${type}">
                    <div class="chat-message-label">${label}</div>
                    <div class="chat-message-content">${formattedContent}</div>
                </div>
            `;
            
            historyEl.insertAdjacentHTML('beforeend', messageHtml);
            historyEl.scrollTop = historyEl.scrollHeight;
        }
        
        // Enterã‚­ãƒ¼ã§é€ä¿¡
        document.getElementById('questionInput')?.addEventListener('keypress', (e) => {
            if (e.key === 'Enter') askQuestion();
        });
        
        // ===== ãƒ¦ãƒ¼ãƒ†ã‚£ãƒªãƒ†ã‚£ =====
        function getUserThresholds() {
            const saved = localStorage.getItem('user_thresholds');
            if (saved) {
                try {
                    return JSON.parse(saved);
                } catch (e) {}
            }
            return { ftp: 200, rFtpPacePerKm: 300, sFtpPacePer100m: 100, maxHr: 190, thresholdHr: 170 };
        }
        
        function getSportCategory(sportType) {
            const swim = ['Swim'];
            const bike = ['Ride', 'VirtualRide', 'EBikeRide'];
            const run = ['Run', 'TrailRun', 'VirtualRun'];
            
            if (swim.includes(sportType)) return 'swim';
            if (bike.includes(sportType)) return 'bike';
            if (run.includes(sportType)) return 'run';
            return 'other';
        }
        
        function getSportLabel(sportType) {
            const labels = {
                'Run': 'ãƒ©ãƒ³', 'TrailRun': 'ãƒˆãƒ¬ã‚¤ãƒ«', 'VirtualRun': 'ãƒãƒ¼ãƒãƒ£ãƒ«ãƒ©ãƒ³',
                'Ride': 'ãƒã‚¤ã‚¯', 'VirtualRide': 'ãƒãƒ¼ãƒãƒ£ãƒ«ãƒ©ã‚¤ãƒ‰', 'EBikeRide': 'E-Bike',
                'Swim': 'ã‚¹ã‚¤ãƒ ', 'WeightTraining': 'ã‚¦ã‚§ã‚¤ãƒˆ', 'Yoga': 'ãƒ¨ã‚¬'
            };
            return labels[sportType] || sportType;
        }
        
        function getActivityIcon(sportType) {
            const icons = {
                'Run': 'ğŸƒâ€â™‚ï¸', 'TrailRun': 'ğŸ”ï¸', 'VirtualRun': 'ğŸƒâ€â™‚ï¸',
                'Ride': 'ğŸš´â€â™‚ï¸', 'VirtualRide': 'ğŸš´â€â™‚ï¸', 'EBikeRide': 'ğŸš´â€â™‚ï¸',
                'Swim': 'ğŸŠâ€â™‚ï¸', 'WeightTraining': 'ğŸ‹ï¸â€â™‚ï¸', 'Yoga': 'ğŸ§˜â€â™‚ï¸'
            };
            return icons[sportType] || 'ğŸƒâ€â™‚ï¸';
        }
        
        function formatDuration(seconds) {
            if (!seconds) return '0:00';
            const h = Math.floor(seconds / 3600);
            const m = Math.floor((seconds % 3600) / 60);
            const s = Math.floor(seconds % 60);
            
            if (h > 0) {
                return `${h}:${String(m).padStart(2, '0')}:${String(s).padStart(2, '0')}`;
            }
            return `${m}:${String(s).padStart(2, '0')}`;
        }
        
        function formatDurationShort(seconds) {
            if (!seconds) return '0:00';
            const m = Math.floor(seconds / 60);
            const s = Math.floor(seconds % 60);
            return `${m}:${String(s).padStart(2, '0')}`;
        }
        
        function formatRunPace(avgSpeed) {
            if (!avgSpeed || avgSpeed <= 0) return '-';
            const pace = 1000 / avgSpeed;
            const min = Math.floor(pace / 60);
            const sec = Math.round(pace % 60);
            return `${min}:${String(sec).padStart(2, '0')}`;
        }
        
        function formatSwimPace(avgSpeed) {
            if (!avgSpeed || avgSpeed <= 0) return '-';
            const pace = 100 / avgSpeed;
            const min = Math.floor(pace / 60);
            const sec = Math.round(pace % 60);
            return `${min}:${String(sec).padStart(2, '0')}`;
        }
        
        function showError(message) {
            document.getElementById('loadingSection').style.display = 'none';
            document.getElementById('errorSection').style.display = 'block';
            document.getElementById('errorMessage').textContent = message;
        }
        
        function goBackToData() {
            window.location.href = 'data.html';
        }
    </script>
</body>
</html>
