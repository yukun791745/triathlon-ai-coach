<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>„Ç¢„ÇØ„ÉÜ„Ç£„Éì„ÉÜ„Ç£Ë©≥Á¥∞ | AI Triathlon Coach</title>
    <!-- Leaflet CSS -->
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            line-height: 1.6;
            color: #333;
            background: linear-gradient(135deg, #dbeafe 0%, #ffffff 50%, #cffafe 100%);
            min-height: 100vh;
            margin: 0;
            padding: 0;
            display: flex;
        }
        
        /* „Éä„Éì„Ç≤„Éº„Ç∑„Éß„É≥ */
        .flow-navbar {
            position: fixed;
            top: 0;
            left: 0;
            bottom: 0;
            width: 240px;
            background: linear-gradient(180deg, #667eea 0%, #764ba2 100%);
            box-shadow: 4px 0 20px rgba(0, 0, 0, 0.1);
            z-index: 1000;
            display: flex;
            flex-direction: column;
            padding: 24px 0;
            overflow-y: auto;
        }

        .flow-nav-container {
            display: flex;
            flex-direction: column;
            height: 100%;
        }

        .flow-nav-logo {
            font-size: 1.3rem;
            font-weight: 700;
            color: white;
            text-align: center;
            padding: 0 20px 30px;
            margin-bottom: 20px;
            border-bottom: 2px solid rgba(255, 255, 255, 0.2);
        }

        .flow-nav-steps {
            display: flex;
            flex-direction: column;
            gap: 8px;
            padding: 0 16px;
            flex: 1;
        }

        .flow-nav-step {
            display: flex;
            align-items: center;
            gap: 12px;
            padding: 12px 16px;
            border-radius: 10px;
            font-size: 0.9rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            text-decoration: none;
            color: rgba(255, 255, 255, 0.8);
            white-space: nowrap;
        }

        .flow-nav-step .nav-icon {
            font-size: 1.4rem;
            flex-shrink: 0;
        }

        .flow-nav-step.current {
            background: rgba(255, 255, 255, 0.25);
            color: white;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
        }

        .flow-nav-step.available:hover {
            background: rgba(255, 255, 255, 0.15);
            color: white;
            transform: translateX(5px);
        }

        /* „É°„Ç§„É≥„Ç≥„É≥„ÉÜ„É≥„ÉÑ */
        .content-wrapper {
            margin-left: 240px;
            flex: 1;
            padding: 24px;
            width: calc(100% - 240px);
        }
        
        .container {
            max-width: 1400px;
            margin: 0 auto;
        }
        
        .back-button {
            background: #6c757d;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 0.9em;
            margin-bottom: 16px;
            transition: background 0.2s;
            text-decoration: none;
            display: inline-block;
        }
        
        .back-button:hover {
            background: #5a6268;
        }
        
        /* Ê¶ÇË¶Å„Éò„ÉÉ„ÉÄ„Éº */
        .activity-header {
            background: white;
            border-radius: 16px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.08);
            padding: 24px;
            margin-bottom: 20px;
        }
        
        .activity-title-row {
            display: flex;
            align-items: center;
            gap: 16px;
            margin-bottom: 16px;
        }
        
        .activity-icon {
            font-size: 2.5rem;
        }
        
        .activity-info h1 {
            font-size: 1.8rem;
            color: #1f2937;
            margin-bottom: 4px;
        }
        
        .activity-date {
            color: #6b7280;
            font-size: 0.95rem;
        }
        
        .activity-sport-badge {
            padding: 6px 14px;
            border-radius: 20px;
            font-size: 0.85rem;
            font-weight: 600;
            margin-left: auto;
        }
        
        .activity-sport-badge.swim { background: #dbeafe; color: #1d4ed8; }
        .activity-sport-badge.bike { background: #f3e8ff; color: #7c3aed; }
        .activity-sport-badge.run { background: #dcfce7; color: #16a34a; }
        .activity-sport-badge.other { background: #fef3c7; color: #b45309; }
        
        /* Ê¶ÇË¶Å„É°„Éà„É™„ÇØ„Çπ */
        .summary-metrics {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(140px, 1fr));
            gap: 16px;
        }
        
        .summary-metric {
            text-align: center;
            padding: 16px 12px;
            background: #f9fafb;
            border-radius: 12px;
        }
        
        .summary-metric-value {
            font-size: 1.8rem;
            font-weight: 700;
            color: #1f2937;
            line-height: 1.2;
        }
        
        .summary-metric-label {
            font-size: 0.75rem;
            color: #6b7280;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin-top: 4px;
        }
        
        /* „Ç∞„É™„ÉÉ„Éâ„É¨„Ç§„Ç¢„Ç¶„Éà */
        .detail-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin-bottom: 20px;
        }
        
        .detail-grid.full-width {
            grid-template-columns: 1fr;
        }
        
        .panel {
            background: white;
            border-radius: 16px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.08);
            overflow: hidden;
        }
        
        .panel-header {
            padding: 16px 20px;
            border-bottom: 1px solid #f3f4f6;
            display: flex;
            align-items: center;
            justify-content: space-between;
        }
        
        .panel-title {
            font-size: 1rem;
            font-weight: 700;
            color: #1f2937;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .panel-content {
            padding: 20px;
        }
        
        /* Âú∞Âõ≥ */
        #routeMap {
            height: 350px;
            border-radius: 8px;
        }
        
        .no-map-message {
            height: 350px;
            display: flex;
            align-items: center;
            justify-content: center;
            color: #9ca3af;
            font-size: 0.95rem;
            background: #f9fafb;
            border-radius: 8px;
        }
        
        /* „Ç∞„É©„Éï */
        .chart-container {
            position: relative;
            height: 250px;
        }
        
        .chart-container.small {
            height: 180px;
        }
        
        .chart-container.wide {
            height: 300px;
            width: 100%;
        }
        
        /* „Çø„Éñ„Éú„Çø„É≥ */
        .tab-buttons {
            display: flex;
            gap: 8px;
            flex-wrap: wrap;
        }
        
        .tab-btn {
            padding: 8px 16px;
            border: 2px solid #e5e7eb;
            background: white;
            border-radius: 8px;
            font-size: 0.85rem;
            font-weight: 600;
            color: #6b7280;
            cursor: pointer;
            transition: all 0.2s;
        }
        
        .tab-btn:hover {
            border-color: #667eea;
            color: #667eea;
        }
        
        .tab-btn.active {
            background: #667eea;
            border-color: #667eea;
            color: white;
        }
        
        .chart-tab-content {
            width: 100%;
        }
        
        .sport-metrics-row {
            display: flex;
            gap: 16px;
            margin-bottom: 16px;
            flex-wrap: wrap;
        }
        
        .sport-metric-item {
            background: #f3f4f6;
            padding: 12px 20px;
            border-radius: 10px;
            text-align: center;
            min-width: 120px;
        }
        
        .sport-metric-value {
            font-size: 1.4rem;
            font-weight: 700;
            color: #667eea;
        }
        
        .sport-metric-label {
            font-size: 0.75rem;
            color: #6b7280;
            margin-top: 2px;
        }
        
        /* ZoneÂàÜÂ∏É */
        .zone-summary {
            display: grid;
            grid-template-columns: repeat(5, 1fr);
            gap: 8px;
            margin-bottom: 16px;
        }
        
        .zone-item {
            text-align: center;
            padding: 12px 8px;
            border-radius: 8px;
            color: white;
            font-size: 0.8rem;
        }
        
        .zone-item.z1 { background: #9ca3af; }
        .zone-item.z2 { background: #3b82f6; }
        .zone-item.z3 { background: #22c55e; }
        .zone-item.z4 { background: #f97316; }
        .zone-item.z5 { background: #ef4444; }
        
        .zone-time {
            font-size: 1.1rem;
            font-weight: 700;
            display: block;
        }
        
        .zone-percent {
            font-size: 0.7rem;
            opacity: 0.9;
        }
        
        /* Lap„ÉÜ„Éº„Éñ„É´ */
        .lap-table {
            width: 100%;
            border-collapse: collapse;
            font-size: 0.85rem;
        }
        
        .lap-table th {
            background: #f3f4f6;
            padding: 10px 8px;
            text-align: left;
            font-weight: 600;
            color: #4b5563;
        }
        
        .lap-table td {
            padding: 10px 8px;
            border-bottom: 1px solid #f3f4f6;
        }
        
        .lap-table tbody tr:hover {
            background: #f9fafb;
        }
        
        /* AI„Ç≥„Éº„ÉÅ„Çª„ÇØ„Ç∑„Éß„É≥ */
        .ai-coach-panel {
            background: white;
            border-radius: 16px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.08);
            overflow: hidden;
        }
        
        .ai-coach-header {
            background: linear-gradient(135deg, #ff6b35 0%, #f7931e 100%);
            color: white;
            padding: 16px 20px;
            display: flex;
            align-items: center;
            gap: 12px;
        }
        
        .ai-coach-header h2 {
            font-size: 1.1rem;
            font-weight: 700;
        }
        
        .ai-coach-content {
            padding: 24px;
        }
        
        .ai-comment {
            font-size: 1rem;
            line-height: 1.8;
            color: #374151;
            white-space: pre-wrap;
        }
        
        .ai-loading {
            display: flex;
            align-items: center;
            gap: 12px;
            color: #6b7280;
            padding: 20px 0;
        }
        
        .ai-loading .spinner {
            width: 24px;
            height: 24px;
            border: 3px solid #e5e7eb;
            border-top-color: #f97316;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }
        
        @keyframes spin {
            to { transform: rotate(360deg); }
        }
        
        /* Ë≥™ÂïèÂÖ•Âäõ */
        .question-section {
            margin-top: 24px;
            padding-top: 20px;
            border-top: 1px solid #e5e7eb;
        }
        
        .question-section h3 {
            font-size: 0.95rem;
            font-weight: 600;
            color: #374151;
            margin-bottom: 12px;
        }
        
        .question-input-row {
            display: flex;
            gap: 12px;
            margin-top: 16px;
        }
        
        .question-input {
            flex: 1;
            padding: 12px 16px;
            border: 2px solid #e5e7eb;
            border-radius: 10px;
            font-size: 0.95rem;
            transition: border-color 0.2s;
        }
        
        .question-input:focus {
            outline: none;
            border-color: #f97316;
        }
        
        .question-btn {
            padding: 12px 24px;
            background: linear-gradient(135deg, #ff6b35 0%, #f7931e 100%);
            color: white;
            border: none;
            border-radius: 10px;
            font-weight: 600;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
            min-width: 80px;
        }
        
        .question-btn:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(249, 115, 22, 0.4);
        }
        
        .question-btn:disabled {
            opacity: 0.6;
            cursor: not-allowed;
        }
        
        .chat-hint {
            font-size: 0.8rem;
            color: #9ca3af;
            margin-top: 8px;
            text-align: center;
        }
        
        /* ‰ºöË©±Â±•Ê≠¥ */
        .chat-history {
            margin-bottom: 16px;
            max-height: 500px;
            overflow-y: auto;
            scroll-behavior: smooth;
        }
        
        .chat-history:empty {
            display: none;
        }
        
        .chat-message {
            padding: 14px 18px;
            border-radius: 16px;
            margin-bottom: 12px;
            animation: fadeIn 0.3s ease;
        }
        
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }
        
        .chat-message.user {
            background: linear-gradient(135deg, #f3f4f6 0%, #e5e7eb 100%);
            margin-left: 60px;
            border-bottom-right-radius: 4px;
        }
        
        .chat-message.coach {
            background: linear-gradient(135deg, #fff7ed 0%, #ffedd5 100%);
            margin-right: 60px;
            border-bottom-left-radius: 4px;
            border-left: 3px solid #f97316;
        }
        
        .chat-message-label {
            font-size: 0.75rem;
            font-weight: 600;
            color: #6b7280;
            margin-bottom: 6px;
            display: flex;
            align-items: center;
            gap: 6px;
        }
        
        .chat-message.coach .chat-message-label {
            color: #ea580c;
        }
        
        .chat-message-content {
            font-size: 0.95rem;
            line-height: 1.7;
            color: #374151;
        }
        
        /* „Çø„Ç§„Éî„É≥„Ç∞„Ç®„Éï„Çß„ÇØ„Éà */
        .typing-indicator {
            display: inline-flex;
            align-items: center;
            gap: 4px;
            padding: 8px 12px;
            background: #f3f4f6;
            border-radius: 12px;
            margin-bottom: 8px;
        }
        
        .typing-indicator span {
            width: 8px;
            height: 8px;
            background: #9ca3af;
            border-radius: 50%;
            animation: typing 1.4s infinite ease-in-out;
        }
        
        .typing-indicator span:nth-child(1) { animation-delay: -0.32s; }
        .typing-indicator span:nth-child(2) { animation-delay: -0.16s; }
        .typing-indicator span:nth-child(3) { animation-delay: 0s; }
        
        @keyframes typing {
            0%, 80%, 100% { transform: scale(0.8); opacity: 0.5; }
            40% { transform: scale(1); opacity: 1; }
        }
        
        .streaming-text {
            border-right: 2px solid #f97316;
            animation: blink 0.7s infinite;
        }
        
        @keyframes blink {
            0%, 50% { border-color: #f97316; }
            51%, 100% { border-color: transparent; }
        }
        
        /* „Çª„ÉÉ„Ç∑„Éß„É≥„Çø„Ç§„ÉóÈÅ∏ÊäûUI */
        .session-type-selector {
            background: #f8fafc;
            border-radius: 12px;
            padding: 20px;
            margin-bottom: 16px;
        }

        .session-type-header {
            margin-bottom: 16px;
        }

        .session-type-title {
            font-size: 1.1rem;
            font-weight: 700;
            color: #1f2937;
            margin-bottom: 4px;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .session-type-subtitle {
            font-size: 0.9rem;
            color: #6b7280;
        }

        .session-type-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(155px, 1fr));
            gap: 10px;
            margin-bottom: 16px;
        }

        .session-type-btn {
            background: white;
            border: 2px solid #e5e7eb;
            border-radius: 10px;
            padding: 12px 14px;
            text-align: left;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .session-type-btn:hover {
            border-color: #f97316;
            background: #fff7ed;
        }

        .session-type-btn.selected {
            border-color: #f97316;
            background: #ffedd5;
        }

        .session-type-btn-label {
            font-size: 0.9rem;
            font-weight: 600;
            color: #1f2937;
            display: block;
        }

        .session-type-btn-desc {
            font-size: 0.75rem;
            color: #6b7280;
            margin-top: 2px;
        }

        .session-supplement {
            margin-top: 12px;
        }

        .session-supplement-label {
            font-size: 0.85rem;
            font-weight: 600;
            color: #4b5563;
            margin-bottom: 6px;
            display: block;
        }

        .session-supplement-input {
            width: 100%;
            padding: 10px 12px;
            border: 1px solid #d1d5db;
            border-radius: 8px;
            font-size: 0.9rem;
            resize: none;
            font-family: inherit;
        }

        .session-supplement-input:focus {
            outline: none;
            border-color: #f97316;
            box-shadow: 0 0 0 3px rgba(249, 115, 22, 0.1);
        }

        .generate-comment-btn {
            width: 100%;
            background: linear-gradient(135deg, #ff6b35 0%, #f7931e 100%);
            color: white;
            border: none;
            border-radius: 10px;
            padding: 14px 20px;
            font-size: 1rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s ease;
            margin-top: 16px;
        }

        .generate-comment-btn:hover:not(:disabled) {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(249, 115, 22, 0.4);
        }

        .generate-comment-btn:disabled {
            background: #9ca3af;
            cursor: not-allowed;
        }

        .other-input-container {
            display: none;
            margin-top: 12px;
        }

        .other-input-container.visible {
            display: block;
        }

        .other-input {
            width: 100%;
            padding: 10px 12px;
            border: 1px solid #d1d5db;
            border-radius: 8px;
            font-size: 0.9rem;
            font-family: inherit;
        }

        .other-input:focus {
            outline: none;
            border-color: #f97316;
        }

        .ai-comment-result {
            background: white;
            border-radius: 12px;
            padding: 20px;
            border-left: 4px solid #f97316;
        }

        .ai-comment-result-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 12px;
        }

        .ai-comment-result-title {
            font-weight: 700;
            color: #1f2937;
        }

        .ai-comment-result-type {
            font-size: 0.8rem;
            background: #ffedd5;
            color: #ea580c;
            padding: 4px 10px;
            border-radius: 12px;
        }

        .ai-comment-text {
            color: #374151;
            line-height: 1.8;
        }

        .change-type-btn {
            background: #f3f4f6;
            color: #4b5563;
            border: none;
            border-radius: 8px;
            padding: 8px 16px;
            font-size: 0.85rem;
            cursor: pointer;
            margin-top: 16px;
            transition: all 0.2s;
        }

        .change-type-btn:hover {
            background: #e5e7eb;
        }
        
        /* „É≠„Éº„Éá„Ç£„É≥„Ç∞ */
        .loading-container {
            text-align: center;
            padding: 60px 20px;
        }
        
        .loading-spinner {
            border: 4px solid #f3f3f3;
            border-radius: 50%;
            border-top: 4px solid #667eea;
            width: 50px;
            height: 50px;
            animation: spin 1s linear infinite;
            margin: 0 auto 20px;
        }
        
        /* „Ç®„É©„Éº */
        .error-message {
            background: #fef2f2;
            color: #991b1b;
            padding: 20px;
            border-radius: 12px;
            text-align: center;
        }
        
        /* Á®ÆÁõÆÂà•„É°„Éà„É™„ÇØ„Çπ */
        .sport-specific-row {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 16px;
            margin-top: 16px;
        }
        
        .sport-metric-card {
            background: #f9fafb;
            padding: 16px;
            border-radius: 12px;
            text-align: center;
        }
        
        .sport-metric-value {
            font-size: 1.5rem;
            font-weight: 700;
            color: #667eea;
        }
        
        .sport-metric-label {
            font-size: 0.8rem;
            color: #6b7280;
            margin-top: 4px;
        }
        
        /* „É¨„Çπ„Éù„É≥„Ç∑„Éñ */
        @media (max-width: 1024px) {
            .detail-grid {
                grid-template-columns: 1fr;
            }
        }
        
        @media (max-width: 768px) {
            body {
                flex-direction: column;
            }

            .flow-navbar {
                position: fixed;
                top: 0;
                left: 0;
                right: 0;
                bottom: auto;
                width: 100%;
                height: auto;
                padding: 12px 0;
            }

            .flow-nav-logo {
                padding: 0 20px 15px;
                margin-bottom: 10px;
                font-size: 1.1rem;
            }

            .flow-nav-steps {
                flex-direction: row;
                overflow-x: auto;
                gap: 5px;
                padding: 0 10px;
            }

            .flow-nav-step {
                padding: 8px 12px;
                font-size: 0.8rem;
            }

            .flow-nav-step span:not(.nav-icon) {
                display: none;
            }

            .content-wrapper {
                margin-left: 0;
                padding: 16px;
                padding-top: 140px;
                width: 100%;
            }
            
            .activity-title-row {
                flex-wrap: wrap;
            }
            
            .activity-sport-badge {
                margin-left: 0;
                margin-top: 8px;
            }
            
            .summary-metrics {
                grid-template-columns: repeat(3, 1fr);
            }
            
            .zone-summary {
                grid-template-columns: repeat(3, 1fr);
            }
            
            .question-input-row {
                flex-direction: column;
            }
        }
        
        /* „Çπ„Ç§„É†„ÉÅ„É£„Éº„ÉàÔºàHTML/CSSÁâàÔºâ */
        .swim-chart-container {
            width: 100%;
            height: 250px;
            display: flex;
            flex-direction: column;
        }
        
        .swim-chart-title {
            text-align: center;
            font-weight: 600;
            font-size: 14px;
            color: #374151;
            margin-bottom: 8px;
        }
        
        .swim-chart-wrapper {
            flex: 1;
            display: flex;
            min-height: 0;
        }
        
        .swim-chart-y-axis {
            width: 60px;
            position: relative;
            padding-right: 8px;
        }
        
        .swim-y-tick {
            position: absolute;
            right: 8px;
            font-size: 11px;
            color: #6b7280;
            transform: translateY(50%);
            white-space: nowrap;
        }
        
        .swim-y-label {
            position: absolute;
            left: 0;
            top: 50%;
            transform: rotate(-90deg) translateX(-50%);
            transform-origin: left center;
            font-size: 11px;
            color: #374151;
            white-space: nowrap;
        }
        
        .swim-chart-area {
            flex: 1;
            position: relative;
            border-left: 1px solid #9ca3af;
            border-bottom: 1px solid #9ca3af;
        }
        
        .swim-chart-grid {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
        }
        
        .swim-grid-line-h {
            position: absolute;
            left: 0;
            right: 0;
            height: 1px;
            background: #e5e7eb;
        }
        
        .swim-grid-line-v {
            position: absolute;
            top: 0;
            bottom: 0;
            width: 1px;
            background: #e5e7eb;
        }
        
        .swim-bars {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
        }
        
        .swim-bar {
            position: absolute;
            bottom: 0;
            background: rgba(59, 130, 246, 0.8);
            border: 1px solid rgba(59, 130, 246, 1);
            border-bottom: none;
            box-sizing: border-box;
            cursor: pointer;
            transition: background 0.15s;
        }
        
        .swim-bar:hover {
            background: rgba(59, 130, 246, 1);
        }
        
        .swim-chart-x-axis {
            height: 35px;
            position: relative;
            margin-left: 60px;
        }
        
        .swim-x-tick {
            position: absolute;
            top: 8px;
            font-size: 11px;
            color: #6b7280;
            transform: translateX(-50%);
        }
        
        .swim-x-label {
            position: absolute;
            bottom: 0;
            left: 50%;
            transform: translateX(-50%);
            font-size: 11px;
            color: #374151;
        }
        
        .swim-tooltip {
            position: fixed;
            background: rgba(0, 0, 0, 0.85);
            color: white;
            padding: 10px 14px;
            border-radius: 6px;
            font-size: 12px;
            line-height: 1.5;
            pointer-events: none;
            z-index: 10000;
            white-space: nowrap;
            display: none;
        }
    
        /* „Éä„Éì„Ç≤„Éº„Ç∑„Éß„É≥Âå∫Âàá„ÇäÁ∑ö */
        .nav-divider {
            height: 1px;
            background: rgba(255, 255, 255, 0.2);
            margin: 12px 16px;
        }
    </style>
</head>
<body>
    <!-- „Éä„Éì„Ç≤„Éº„Ç∑„Éß„É≥ -->
    <nav class="flow-navbar">
        <div class="flow-nav-container">
            <div class="flow-nav-logo">AI Triathlon Coach</div>
            <div class="flow-nav-steps">
                <a href="home.html" class="flow-nav-step available">
                    <span class="nav-icon">üè†</span>
                    <span>„Éõ„Éº„É†</span>
                </a>
                <a href="index.html" class="flow-nav-step available">
                    <span class="nav-icon">ü§ñ</span>
                    <span>AI„Ç≥„Éº„ÉÅ</span>
                </a>
                <a href="news.html" class="flow-nav-step available">
                    <span class="nav-icon">üì∞</span>
                    <span>„Éã„É•„Éº„Çπ</span>
                </a>
                <a href="race-selection.html" class="flow-nav-step available">
                    <span class="nav-icon">üéØ</span>
                    <span>„É¨„Éº„ÇπÈÅ∏Êäû</span>
                </a>
                <a href="goal-setting.html" class="flow-nav-step available">
                    <span class="nav-icon">üèÜ</span>
                    <span>ÁõÆÊ®ôË®≠ÂÆö</span>
                </a>
                <a href="training-plan.html" class="flow-nav-step available">
                    <span class="nav-icon">üìã</span>
                    <span>Ë®àÁîª</span>
                </a>
                <a href="simulator.html" class="flow-nav-step available">
                    <span class="nav-icon">üî¨</span>
                    <span>„Ç∑„Éü„É•„É¨„Éº„Çø„Éº</span>
                </a>
                <a href="data.html" class="flow-nav-step current">
                    <span class="nav-icon">üìä</span>
                    <span>ÈÄ≤Êçó</span>
                </a>
                <a href="settings.html" class="flow-nav-step available">
                    <span class="nav-icon">‚öôÔ∏è</span>
                    <span>Ë®≠ÂÆö</span>
                </a>
                <div class="nav-divider"></div>
                <a href="help.html" class="flow-nav-step available">
                    <span class="nav-icon">‚ùì</span>
                    <span>„Éò„É´„Éó</span>
                </a>
            </div>
        </div>
    </nav>

    <div class="content-wrapper">
        <div class="container">
            <button class="back-button" onclick="goBackToData()">‚Üê ÈÄ≤Êçó„Éö„Éº„Ç∏„Å´Êàª„Çã</button>
            
            <!-- „É≠„Éº„Éá„Ç£„É≥„Ç∞ -->
            <div id="loadingSection" class="loading-container">
                <div class="loading-spinner"></div>
                <p>„Ç¢„ÇØ„ÉÜ„Ç£„Éì„ÉÜ„Ç£„Éá„Éº„Çø„ÇíË™≠„ÅøËæº„Åø‰∏≠...</p>
            </div>
            
            <!-- „É°„Ç§„É≥„Ç≥„É≥„ÉÜ„É≥„ÉÑ -->
            <div id="mainContent" style="display: none;">
                <!-- Ê¶ÇË¶Å„Éò„ÉÉ„ÉÄ„Éº -->
                <div class="activity-header">
                    <div class="activity-title-row">
                        <span class="activity-icon" id="activityIcon">üèÉ‚Äç‚ôÇÔ∏è</span>
                        <div class="activity-info">
                            <h1 id="activityName">„Ç¢„ÇØ„ÉÜ„Ç£„Éì„ÉÜ„Ç£Âêç</h1>
                            <div class="activity-date" id="activityDate">Êó•ÊôÇ</div>
                        </div>
                        <span class="activity-sport-badge run" id="sportBadge">„É©„É≥</span>
                    </div>
                    <div class="summary-metrics" id="summaryMetrics">
                        <!-- ÂãïÁöÑ„Å´ÁîüÊàê -->
                    </div>
                </div>
                
                <!-- Âú∞Âõ≥„Å®„Çæ„Éº„É≥ÂàÜÊûê -->
                <div class="detail-grid">
                    <div class="panel">
                        <div class="panel-header">
                            <h2 class="panel-title">üó∫Ô∏è „É´„Éº„Éà„Éû„ÉÉ„Éó</h2>
                        </div>
                        <div class="panel-content">
                            <div id="mapContainer">
                                <div id="routeMap"></div>
                            </div>
                        </div>
                    </div>
                    
                    <div class="panel">
                        <div class="panel-header">
                            <h2 class="panel-title">üíì ÂøÉÊãç„Çæ„Éº„É≥ÂàÜÂ∏É</h2>
                        </div>
                        <div class="panel-content">
                            <div class="zone-summary" id="zoneSummary">
                                <!-- ÂãïÁöÑ„Å´ÁîüÊàê -->
                            </div>
                            <div class="chart-container small">
                                <canvas id="zoneChart"></canvas>
                            </div>
                        </div>
                    </div>
                </div>
                
                <!-- ÊôÇÁ≥ªÂàó„Ç∞„É©„ÉïÔºà„Çø„ÉñÂàá„ÇäÊõø„ÅàÔºâ -->
                <div class="detail-grid full-width">
                    <div class="panel">
                        <div class="panel-header">
                            <h2 class="panel-title">üìà ÊôÇÁ≥ªÂàó„Éá„Éº„Çø</h2>
                            <div class="tab-buttons" id="chartTabs">
                                <button class="tab-btn" data-tab="hr">üíì ÂøÉÊãçÊï∞</button>
                                <button class="tab-btn active" data-tab="pace">‚è±Ô∏è „Éö„Éº„Çπ</button>
                                <button class="tab-btn" data-tab="gap" id="gapTab" style="display: none;">üìê GAP</button>
                                <button class="tab-btn" data-tab="cadence" id="cadenceTab" style="display: none;">üîÑ „Ç±„Ç§„Éá„É≥„Çπ</button>
                                <button class="tab-btn" data-tab="power" id="powerTab" style="display: none;">‚ö° „Éë„ÉØ„Éº</button>
                            </div>
                        </div>
                        <div class="panel-content">
                            <div class="chart-tab-content" id="hrTabContent" style="display: none;">
                                <div class="chart-container wide">
                                    <canvas id="hrChart"></canvas>
                                </div>
                            </div>
                            <div class="chart-tab-content" id="paceTabContent">
                                <div class="chart-container wide">
                                    <canvas id="paceChart"></canvas>
                                </div>
                            </div>
                            <div class="chart-tab-content" id="gapTabContent" style="display: none;">
                                <div class="sport-metrics-row" id="gapMetrics"></div>
                                <div class="chart-container wide">
                                    <canvas id="gapChart"></canvas>
                                </div>
                            </div>
                            <div class="chart-tab-content" id="cadenceTabContent" style="display: none;">
                                <div class="sport-metrics-row" id="cadenceMetrics"></div>
                                <div class="chart-container wide">
                                    <canvas id="cadenceChart"></canvas>
                                </div>
                            </div>
                            <div class="chart-tab-content" id="powerTabContent" style="display: none;">
                                <div class="sport-metrics-row" id="powerMetrics"></div>
                                <div class="chart-container wide">
                                    <canvas id="powerChart"></canvas>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
                
                <!-- Lap„Éá„Éº„Çø -->
                <div class="detail-grid full-width" id="lapSection" style="display: none;">
                    <div class="panel">
                        <div class="panel-header">
                            <h2 class="panel-title">üìã LapË©≥Á¥∞</h2>
                        </div>
                        <div class="panel-content">
                            <div style="max-height: 300px; overflow-y: auto;">
                                <table class="lap-table" id="lapTable">
                                    <!-- ÂãïÁöÑ„Å´ÁîüÊàê -->
                                </table>
                            </div>
                        </div>
                    </div>
                </div>
                
                <!-- AI„Ç≥„Éº„ÉÅ„Ç≥„É°„É≥„Éà -->
                <div class="ai-coach-panel">
                    <div class="ai-coach-header">
                        <span style="font-size: 1.5rem;">ü§ñ</span>
                        <h2>AI„Ç≥„Éº„ÉÅ</h2>
                    </div>
                    <div class="ai-coach-content">
                        
                        <!-- „Çª„ÉÉ„Ç∑„Éß„É≥„Çø„Ç§„ÉóÈÅ∏Êäû -->
                        <div class="session-type-selector" id="sessionTypeSelector">
                            <div class="session-type-header">
                                <div class="session-type-title">üéØ ‰ªäÊó•„ÅÆ„Éà„É¨„Éº„Éã„É≥„Ç∞„ÅÆÁõÆÁöÑ„ÅØÔºü</div>
                                <div class="session-type-subtitle">Êïô„Åà„Å¶„ÅÑ„Åü„Å†„Åë„Çå„Å∞„ÄÅAI„Ç≥„Éº„ÉÅ„Åå„Çà„ÇäÁöÑÁ¢∫„Å™„Ç≥„É°„É≥„Éà„Çí„ÅäÂ±ä„Åë„Åó„Åæ„Åô</div>
                            </div>
                            
                            <div class="session-type-grid" id="sessionTypeGrid">
                                <!-- JavaScript„ÅßÂãïÁöÑ„Å´ÁîüÊàê -->
                            </div>
                            
                            <!-- „Åù„ÅÆ‰ªñÈÅ∏ÊäûÊôÇ„ÅÆÂÖ•ÂäõÊ¨Ñ -->
                            <div class="other-input-container" id="otherInputContainer">
                                <input type="text" class="other-input" id="otherInput" 
                                       placeholder="‰æãÔºöÂâçÂçä„Ç≠„ÉÉ„ÇØÁ∑¥Áøí„ÄÅÂæåÂçä„Éó„É´„Éñ„Ç§„Åß1500m">
                            </div>
                            
                            <!-- Ë£úË∂≥ÂÖ•Âäõ -->
                            <div class="session-supplement">
                                <label class="session-supplement-label">üí¨ Ë£úË∂≥Ôºà‰ªªÊÑèÔºâ</label>
                                <textarea class="session-supplement-input" id="sessionSupplement" rows="2"
                                          placeholder="‰æãÔºöÂæåÂçä„Éì„É´„Éâ„Ç¢„ÉÉ„Éó„ÇíÊÑèË≠ò„Åó„Åü„ÄÅÊöë„Åè„Å¶„Éö„Éº„Çπ„ÇíÊäë„Åà„Åü„ÄÅ„Å™„Å©"></textarea>
                            </div>
                            
                            <button class="generate-comment-btn" id="generateCommentBtn" disabled>
                                AI„Ç≥„Éº„ÉÅ„ÅÆ„Ç≥„É°„É≥„Éà„ÇíË¶ã„Çã
                            </button>
                        </div>
                        
                        <!-- „É≠„Éº„Éá„Ç£„É≥„Ç∞ -->
                        <div id="aiCommentLoading" class="ai-loading" style="display: none;">
                            <div class="spinner"></div>
                            <span>AI„Ç≥„Éº„ÉÅ„Åå„Ç¢„ÇØ„ÉÜ„Ç£„Éì„ÉÜ„Ç£„ÇíÂàÜÊûê‰∏≠...</span>
                        </div>
                        
                        <!-- „Ç≥„É°„É≥„ÉàÁµêÊûú -->
                        <div id="aiCommentResult" style="display: none;">
                            <div class="ai-comment-result">
                                <div class="ai-comment-result-header">
                                    <span class="ai-comment-result-title">AI„Ç≥„Éº„ÉÅ„ÅÆ„Ç≥„É°„É≥„Éà</span>
                                    <span class="ai-comment-result-type" id="commentSessionType"></span>
                                </div>
                                <div class="ai-comment-text" id="aiCommentText"></div>
                                <button class="change-type-btn" onclick="changeSessionType()">üîÑ „Çª„ÉÉ„Ç∑„Éß„É≥„Çø„Ç§„Éó„ÇíÂ§âÊõ¥</button>
                            </div>
                            
                            <!-- Ë≥™Âïè„Çª„ÇØ„Ç∑„Éß„É≥Ôºà„ÉÅ„É£„ÉÉ„ÉàÂΩ¢ÂºèÔºâ -->
                            <div class="question-section" id="questionSection">
                                <h3>üí¨ „Ç≥„Éº„ÉÅ„Å´Ë≥™Âïè„Åô„Çã</h3>
                                
                                <!-- ‰ºöË©±Â±•Ê≠¥„Ç®„É™„Ç¢ -->
                                <div class="chat-history" id="chatHistory">
                                    <!-- ‰ºöË©±Â±•Ê≠¥„Åå„Åì„Åì„Å´Ë°®Á§∫„Åï„Çå„Çã -->
                                </div>
                                
                                <!-- Ë≥™ÂïèÂÖ•ÂäõÔºàÂ∏∏„Å´Ë°®Á§∫Ôºâ -->
                                <div class="question-input-row">
                                    <input type="text" class="question-input" id="questionInput" 
                                        placeholder="Ë≥™Âïè„ÇíÂÖ•Âäõ... Ôºà‰æã: Ê¨°Âõû„ÅÆ„Éà„É¨„Éº„Éã„É≥„Ç∞„Åß„ÅØ„Å©„Åì„ÇíÊÑèË≠ò„Åô„Åπ„ÅçÔºüÔºâ">
                                    <button class="question-btn" id="askBtn" onclick="askQuestion()">
                                        <span id="askBtnText">ÈÄÅ‰ø°</span>
                                    </button>
                                </div>
                                <div class="chat-hint" id="chatHint">
                                    üí° „Éà„É¨„Éº„Éã„É≥„Ç∞„Å´„Å§„ÅÑ„Å¶‰Ωï„Åß„ÇÇË≥™Âïè„Åß„Åç„Åæ„Åô
                                </div>
                            </div>
                        </div>
                        
                    </div>
                </div>
            </div>
            
            <!-- „Ç®„É©„Éº -->
            <div id="errorSection" style="display: none;">
                <div class="error-message">
                    <h3>‚ùå „Éá„Éº„Çø„ÅÆÂèñÂæó„Å´Â§±Êïó„Åó„Åæ„Åó„Åü</h3>
                    <p id="errorMessage">„Ç®„É©„Éº„É°„ÉÉ„Çª„Éº„Ç∏</p>
                </div>
            </div>
        </div>
    </div>

    <!-- Scripts -->
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.0/dist/chart.umd.min.js"></script>
    
    <script>
        // ===== „Ç∞„É≠„Éº„Éê„É´Â§âÊï∞ =====
        let currentActivity = null;
        let streamData = null;
        let trainingStatus = null;
        let map = null;
        let charts = {};
        let selectedSessionType = null;
        let conversationHistory = [];
        let currentRaceGoal = null;  // A„É¨„Éº„ÇπÁõÆÊ®ô„Çí‰øùÊåÅ
        
        // ===== „Çª„ÉÉ„Ç∑„Éß„É≥„Çø„Ç§„ÉóÂÆöÁæ© =====
        const SESSION_TYPES = {
            swim: [
                { id: 'swim_drill_focus', label: '„ÉÜ„ÇØ„Éã„ÉÉ„ÇØÈáçË¶ñ', description: '„Éâ„É™„É´‰∏≠ÂøÉ' },
                { id: 'swim_drill_endurance', label: '„Éâ„É™„É´ÔºãÊúâÈÖ∏Á¥†', description: '„Éâ„É™„É´Âæå„Å´Z2' },
                { id: 'swim_drill_speed', label: '„Éâ„É™„É´Ôºã„Çπ„Éî„Éº„Éâ', description: '„Éâ„É™„É´Âæå„Å´È´òÂº∑Â∫¶' },
                { id: 'swim_endurance', label: 'ÊúâÈÖ∏Á¥†ÔºàÊ≥≥„ÅéËæº„ÅøÔºâ', description: 'Ë∑ùÈõ¢ÈáçË¶ñ' },
                { id: 'swim_threshold', label: 'ÈñæÂÄ§/CSS„Éö„Éº„Çπ', description: '„ÉÜ„É≥„Éù„Çπ„Ç§„É†' },
                { id: 'swim_interval', label: 'È´òÂº∑Â∫¶„Ç§„É≥„Çø„Éº„Éê„É´', description: '„Çπ„Éó„É™„É≥„ÉàÁ≠â' },
                { id: 'swim_ow', label: '„Ç™„Éº„Éó„É≥„Ç¶„Ç©„Éº„Çø„Éº', description: 'Êµ∑„ÉªÊπñ' },
                { id: 'swim_recovery', label: '„É™„Ç´„Éê„É™„Éº', description: 'ËªΩ„ÅèÊµÅ„Åô' },
                { id: 'swim_test', label: '„ÉÜ„Çπ„Éà/TT', description: 'CSSÊ∏¨ÂÆöÁ≠â' }
            ],
            bike: [
                { id: 'bike_endurance', label: 'ÊúâÈÖ∏Á¥†„Ç®„É≥„Éá„É•„É©„É≥„Çπ', description: 'Z2‰∏≠ÂøÉ' },
                { id: 'bike_tempo', label: '„ÉÜ„É≥„Éù/SST', description: 'FTP88-94%' },
                { id: 'bike_threshold', label: 'ÈñæÂÄ§/FTPËµ∞', description: 'FTP‰ªòËøëÊåÅÁ∂ö' },
                { id: 'bike_vo2max', label: 'VO2max/È´òÂº∑Â∫¶', description: 'È´òÂº∑Â∫¶„Ç§„É≥„Çø„Éº„Éê„É´' },
                { id: 'bike_technique_interval', label: '„ÉÜ„ÇØ„Éã„ÉÉ„ÇØÔºã„Ç§„É≥„Çø„Éº„Éê„É´', description: '„Éâ„É™„É´ÔºãÈ´òÂº∑Â∫¶' },
                { id: 'bike_zwift_workout', label: 'Zwift„ÉØ„Éº„ÇØ„Ç¢„Ç¶„Éà', description: 'ÊßãÈÄ†Âåñ„É°„Éã„É•„Éº' },
                { id: 'bike_hill', label: '„Éí„É´„ÇØ„É©„Ç§„É†', description: 'ÁôªÂùÇ' },
                { id: 'bike_brick', label: '„Éñ„É™„ÉÉ„ÇØÔºà‚Üí„É©„É≥Ôºâ', description: '„Éê„Ç§„ÇØÂæå„É©„É≥' },
                { id: 'bike_recovery', label: '„É™„Ç´„Éê„É™„Éº', description: 'ËªΩ„ÅèÂõû„Åô' },
                { id: 'bike_test', label: '„ÉÜ„Çπ„Éà/TT', description: 'FTPÊ∏¨ÂÆöÁ≠â' }
            ],
            run: [
                { id: 'run_easy', label: '„Ç§„Éº„Ç∏„Éº/„Ç∏„Éß„Ç∞', description: '‰ºöË©±„Éö„Éº„Çπ' },
                { id: 'run_long', label: '„É≠„É≥„Ç∞Ëµ∞', description: 'Èï∑Ë∑ùÈõ¢' },
                { id: 'run_tempo', label: '„ÉÜ„É≥„Éù/ÈñæÂÄ§Ëµ∞', description: 'LT„Éö„Éº„Çπ' },
                { id: 'run_interval', label: '„Ç§„É≥„Çø„Éº„Éê„É´', description: 'È´òÂº∑Â∫¶ÂèçÂæ©' },
                { id: 'run_fartlek', label: '„Éï„Ç°„É´„Éà„É¨„ÇØ', description: '„Éö„Éº„ÇπÂ§âÂåñ' },
                { id: 'run_hill', label: 'ÂùÇÈÅì„Éà„É¨„Éº„Éã„É≥„Ç∞', description: 'ÂùÇ„ÉÄ„ÉÉ„Ç∑„É•Á≠â' },
                { id: 'run_brick', label: '„Éñ„É™„ÉÉ„ÇØÔºà„Éê„Ç§„ÇØÂæåÔºâ', description: '„Éê„Ç§„ÇØÁõ¥Âæå' },
                { id: 'run_recovery', label: '„É™„Ç´„Éê„É™„Éº', description: 'ÈùûÂ∏∏„Å´ËªΩ„Åè' },
                { id: 'run_test', label: '„ÉÜ„Çπ„Éà/TT', description: '„Çø„Ç§„É†Ë®àÊ∏¨' }
            ],
            common: [
                { id: 'race', label: '„É¨„Éº„Çπ/Â§ß‰ºö', description: 'Êú¨Áï™' },
                { id: 'other', label: '„Åù„ÅÆ‰ªñ', description: '‰∏äË®ò‰ª•Â§ñ' }
            ]
        };
        
        // ===== „Éà„Éº„ÇØ„É≥ÁÆ°ÁêÜ =====
        async function ensureValidToken() {
            const authData = localStorage.getItem('strava_auth');
            if (!authData) {
                console.error('No auth data found');
                return null;
            }
            
            const auth = JSON.parse(authData);
            
            // ÊúâÂäπÊúüÈôê„Çí„ÉÅ„Çß„ÉÉ„ÇØÔºà5ÂàÜ„ÅÆ‰ΩôË£ï„ÇíÊåÅ„Åü„Åõ„ÇãÔºâ
            const now = Math.floor(Date.now() / 1000);
            const expiresAt = auth.expires_at || 0;
            
            if (now < expiresAt - 300) {
                // „Åæ„Å†ÊúâÂäπ
                return auth.access_token;
            }
            
            // ÊúüÈôêÂàá„Çå„Åæ„Åü„ÅØÈñì„ÇÇ„Å™„ÅèÂàá„Çå„Çã - „É™„Éï„É¨„ÉÉ„Ç∑„É•„ÅåÂøÖË¶Å
            console.log('Token expired or expiring soon, refreshing...');
            
            if (!auth.refresh_token) {
                console.error('No refresh token found');
                alert('„Çª„ÉÉ„Ç∑„Éß„É≥„ÅÆÊúâÂäπÊúüÈôê„ÅåÂàá„Çå„Åæ„Åó„Åü„ÄÇÂÜçÂ∫¶„É≠„Ç∞„Ç§„É≥„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ');
                window.location.href = 'index.html';
                return null;
            }
            
            try {
                const response = await fetch('/.netlify/functions/strava-refresh-token', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        refresh_token: auth.refresh_token
                    })
                });
                
                if (!response.ok) {
                    throw new Error('Token refresh failed');
                }
                
                const newTokenData = await response.json();
                
                // Êñ∞„Åó„ÅÑ„Éà„Éº„ÇØ„É≥„Çí‰øùÂ≠ò
                const updatedAuth = {
                    ...auth,
                    access_token: newTokenData.access_token,
                    refresh_token: newTokenData.refresh_token,
                    expires_at: newTokenData.expires_at
                };
                localStorage.setItem('strava_auth', JSON.stringify(updatedAuth));
                
                console.log('Token refreshed successfully');
                return newTokenData.access_token;
                
            } catch (error) {
                console.error('Token refresh error:', error);
                alert('„Çª„ÉÉ„Ç∑„Éß„É≥„ÅÆÊõ¥Êñ∞„Å´Â§±Êïó„Åó„Åæ„Åó„Åü„ÄÇÂÜçÂ∫¶„É≠„Ç∞„Ç§„É≥„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ');
                window.location.href = 'index.html';
                return null;
            }
        }

        // 401„Ç®„É©„ÉºÊôÇ„Å´„É™„Éï„É¨„ÉÉ„Ç∑„É•„Åó„Å¶ÂÜçË©¶Ë°å„Åô„Çã„É©„ÉÉ„Éë„Éº
        async function fetchWithTokenRefresh(url, options, bodyWithoutToken) {
            let response = await fetch(url, options);
            
            if (response.status === 401) {
                console.log('Got 401, attempting token refresh...');
                
                const authData = localStorage.getItem('strava_auth');
                if (authData) {
                    const auth = JSON.parse(authData);
                    
                    if (auth.refresh_token) {
                        try {
                            const refreshResponse = await fetch('/.netlify/functions/strava-refresh-token', {
                                method: 'POST',
                                headers: { 'Content-Type': 'application/json' },
                                body: JSON.stringify({ refresh_token: auth.refresh_token })
                            });
                            
                            if (refreshResponse.ok) {
                                const newTokenData = await refreshResponse.json();
                                
                                // Êñ∞„Åó„ÅÑ„Éà„Éº„ÇØ„É≥„Çí‰øùÂ≠ò
                                localStorage.setItem('strava_auth', JSON.stringify({
                                    ...auth,
                                    access_token: newTokenData.access_token,
                                    refresh_token: newTokenData.refresh_token,
                                    expires_at: newTokenData.expires_at
                                }));
                                
                                // Êñ∞„Åó„ÅÑ„Éà„Éº„ÇØ„É≥„ÅßÂÜçË©¶Ë°å
                                const newBody = { ...bodyWithoutToken, token: newTokenData.access_token };
                                response = await fetch(url, {
                                    ...options,
                                    body: JSON.stringify(newBody)
                                });
                                
                                console.log('Retry with new token successful');
                            }
                        } catch (error) {
                            console.error('Retry after refresh failed:', error);
                        }
                    }
                }
            }
            
            return response;
        }

        
        // ===== ÂàùÊúüÂåñ =====
        document.addEventListener('DOMContentLoaded', async () => {
            const activityId = getActivityId();
            
            if (!activityId) {
                showError('„Ç¢„ÇØ„ÉÜ„Ç£„Éì„ÉÜ„Ç£ID„ÅåÊåáÂÆö„Åï„Çå„Å¶„ÅÑ„Åæ„Åõ„Çì');
                return;
            }
            
            try {
                await loadActivityData(activityId);
            } catch (error) {
                console.error('Error loading activity:', error);
                showError(error.message);
            }
        });
        
        function getActivityId() {
            const urlParams = new URLSearchParams(window.location.search);
            return urlParams.get('id');
        }
        
        // ===== „Éá„Éº„ÇøË™≠„ÅøËæº„Åø =====
        async function loadActivityData(activityId) {
            // „Ç≠„É£„ÉÉ„Ç∑„É•„Åã„Çâ„Ç¢„ÇØ„ÉÜ„Ç£„Éì„ÉÜ„Ç£„ÇíÂèñÂæó
            const cachedActivities = localStorage.getItem('strava_activities');
            if (!cachedActivities) {
                throw new Error('„Ç¢„ÇØ„ÉÜ„Ç£„Éì„ÉÜ„Ç£„Éá„Éº„Çø„Åå„ÅÇ„Çä„Åæ„Åõ„Çì„ÄÇÈÄ≤Êçó„Éö„Éº„Ç∏„Åß„Éá„Éº„Çø„ÇíÂêåÊúü„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ');
            }
            
            const activities = JSON.parse(cachedActivities);
            currentActivity = activities.find(a => a.id.toString() === activityId.toString());
            
            if (!currentActivity) {
                throw new Error('ÊåáÂÆö„Åï„Çå„Åü„Ç¢„ÇØ„ÉÜ„Ç£„Éì„ÉÜ„Ç£„ÅåË¶ã„Å§„Åã„Çä„Åæ„Åõ„Çì');
            }
            
            // „Éà„É¨„Éº„Éã„É≥„Ç∞„Çπ„ÉÜ„Éº„Çø„Çπ„ÇíË®àÁÆó
            trainingStatus = calculateTrainingStatus(activities);
            
            // Âü∫Êú¨ÊÉÖÂ†±„ÇíË°®Á§∫
            renderActivityHeader();
            renderSummaryMetrics();
            
            // Streams API„Åß„Éá„Éº„Çø„ÇíÂèñÂæó
            await loadStreamData(activityId);
            
            // Laps API„Åß„É©„ÉÉ„Éó„Éá„Éº„Çø„ÇíÂèñÂæóÔºà„Çπ„Ç§„É†„Å™„Å©Ôºâ
            await loadLapData(activityId);
            
            // „Çπ„Ç§„É†„ÅÆÂ†¥Âêà„ÄÅ„Çπ„Éà„É≠„Éº„ÇØ„É°„Éà„É™„ÉÉ„ÇØ„ÇíÊ¶ÇË¶Å„Å´ËøΩÂä†
            addSwimStrokeMetrics();
            
            // UI„ÇíË°®Á§∫
            document.getElementById('loadingSection').style.display = 'none';
            document.getElementById('mainContent').style.display = 'block';
            
            // „Ç∞„É©„Éï„ÇíÊèèÁîª
            renderCharts();
            
            // AI„Ç≥„Éº„ÉÅ„ÅÆ„Çª„ÉÉ„Ç∑„Éß„É≥„Çø„Ç§„ÉóÈÅ∏ÊäûUI„ÇíÂàùÊúüÂåñ
            initSessionTypeSelector();
        }
        
        async function loadStreamData(activityId) {
            const authData = localStorage.getItem('strava_auth');
            if (!authData) {
                console.log('No auth data, skipping streams');
                return;
            }
            
            try {
                // „Åæ„Åö„Éà„Éº„ÇØ„É≥„ÅåÊúâÂäπ„ÅãÁ¢∫Ë™ç
                const token = await ensureValidToken();
                if (!token) return;
                
                const bodyData = { activityId: activityId };
                
                const response = await fetchWithTokenRefresh(
                    '/.netlify/functions/strava-streams',
                    {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ token: token, ...bodyData })
                    },
                    bodyData
                );
                
                if (response.ok) {
                    const data = await response.json();
                    if (data.hasStreams) {
                        streamData = data.streams;
                        console.log('Stream data loaded:', Object.keys(streamData));
                    }
                } else {
                    console.error('Stream API error:', response.status);
                }
            } catch (error) {
                console.error('Failed to load streams:', error);
            }
        }
        
        // „É©„ÉÉ„Éó„Éá„Éº„Çø„ÇíÂèñÂæóÔºàFORM/Garmin„Å™„Å©„Åã„Çâ„ÅÆ„Çπ„Ç§„É†„Éá„Éº„ÇøÁî®Ôºâ
        async function loadLapData(activityId) {
            const authData = localStorage.getItem('strava_auth');
            if (!authData) {
                console.log('No auth data, skipping laps');
                return;
            }
            
            try {
                // „Åæ„Åö„Éà„Éº„ÇØ„É≥„ÅåÊúâÂäπ„ÅãÁ¢∫Ë™ç
                const token = await ensureValidToken();
                if (!token) return;
                
                const bodyData = { activityId: activityId };
                
                const response = await fetchWithTokenRefresh(
                    '/.netlify/functions/strava-laps',
                    {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ token: token, ...bodyData })
                    },
                    bodyData
                );
                
                if (response.ok) {
                    const data = await response.json();
                    console.log('Lap API response:', data);
                    
                    if (data.laps && data.laps.length > 0) {
                        currentActivity.laps = data.laps;
                        console.log('Lap data loaded:', data.laps.length, 'laps');
                        if (data.analysis) {
                            console.log('Lap analysis:', data.analysis);
                        }
                    } else {
                        console.log('No laps in response');
                    }
                } else {
                    console.error('Lap API error:', response.status);
                }
            } catch (error) {
                console.error('Failed to load laps:', error);
            }
        }
        
        // ===== „Éà„É¨„Éº„Éã„É≥„Ç∞„Çπ„ÉÜ„Éº„Çø„ÇπË®àÁÆó =====
        function calculateTrainingStatus(activities) {
            if (activities.length === 0) return null;
            
            const dailyTss = {};
            activities.forEach(activity => {
                const date = activity.start_date.split('T')[0];
                if (!dailyTss[date]) dailyTss[date] = 0;
                dailyTss[date] += activity.tss || 0;
            });
            
            const today = new Date();
            const days = [];
            for (let i = 89; i >= 0; i--) {
                const d = new Date(today);
                d.setDate(d.getDate() - i);
                const dateStr = d.toISOString().split('T')[0];
                days.push({ date: dateStr, tss: dailyTss[dateStr] || 0 });
            }
            
            const ctlFactor = 1 - Math.exp(-1 / 42);
            const atlFactor = 1 - Math.exp(-1 / 7);
            
            let ctl = 0, atl = 0, prevCtl = 0;
            
            days.forEach((day, i) => {
                ctl = ctl + (day.tss - ctl) * ctlFactor;
                atl = atl + (day.tss - atl) * atlFactor;
                if (i === days.length - 8) prevCtl = ctl;
            });
            
            return {
                ctl: Math.round(ctl * 10) / 10,
                atl: Math.round(atl * 10) / 10,
                tsb: Math.round((ctl - atl) * 10) / 10,
                ctlTrend: Math.round((ctl - prevCtl) * 10) / 10
            };
        }
        
        // ===== „Éò„ÉÉ„ÉÄ„ÉºÊèèÁîª =====
        function renderActivityHeader() {
            const sportType = currentActivity.sport_type || currentActivity.type;
            const sportCategory = getSportCategory(sportType);
            
            document.getElementById('activityIcon').textContent = getActivityIcon(sportType);
            document.getElementById('activityName').textContent = currentActivity.name || 'ÁÑ°È°å„ÅÆ„Ç¢„ÇØ„ÉÜ„Ç£„Éì„ÉÜ„Ç£';
            document.getElementById('activityDate').textContent = new Date(currentActivity.start_date).toLocaleString('ja-JP', {
                year: 'numeric', month: 'long', day: 'numeric',
                weekday: 'short', hour: '2-digit', minute: '2-digit'
            });
            
            const badge = document.getElementById('sportBadge');
            badge.textContent = getSportLabel(sportType);
            badge.className = `activity-sport-badge ${sportCategory}`;
        }
        
        function renderSummaryMetrics() {
            const sportType = currentActivity.sport_type || currentActivity.type;
            const sportCategory = getSportCategory(sportType);
            
            let html = '';
            
            // Ë∑ùÈõ¢
            if (currentActivity.distance) {
                html += createMetricCard((currentActivity.distance / 1000).toFixed(2), 'km', 'Ë∑ùÈõ¢');
            }
            
            // ÊôÇÈñì
            html += createMetricCard(formatDuration(currentActivity.moving_time), '', 'ÊôÇÈñì');
            
            // „Éö„Éº„Çπ/ÈÄüÂ∫¶
            if (currentActivity.average_speed) {
                if (sportCategory === 'swim') {
                    html += createMetricCard(formatSwimPace(currentActivity.average_speed), '/100m', '„Éö„Éº„Çπ');
                } else if (sportCategory === 'bike') {
                    html += createMetricCard((currentActivity.average_speed * 3.6).toFixed(1), 'km/h', 'Âπ≥ÂùáÈÄüÂ∫¶');
                } else {
                    html += createMetricCard(formatRunPace(currentActivity.average_speed), '/km', '„Éö„Éº„Çπ');
                }
            }
            
            // ÂøÉÊãç
            if (currentActivity.average_heartrate) {
                html += createMetricCard(Math.round(currentActivity.average_heartrate), 'bpm', 'Âπ≥ÂùáÂøÉÊãç');
            }
            
            // „Éê„Ç§„ÇØ: „Éë„ÉØ„Éº„É°„Éà„É™„ÉÉ„ÇØÔºàÂøÉÊãç„Å®Áç≤ÂæóÊ®ôÈ´ò„ÅÆÈñìÔºâ
            if (sportCategory === 'bike') {
                if (currentActivity.average_watts) {
                    html += createMetricCard(Math.round(currentActivity.average_watts), 'W', 'Âπ≥Âùá„Éë„ÉØ„Éº');
                }
                if (currentActivity.weighted_average_watts) {
                    html += createMetricCard(Math.round(currentActivity.weighted_average_watts), 'W', 'NP');
                }
                if (currentActivity.average_watts && currentActivity.weighted_average_watts) {
                    const vi = (currentActivity.weighted_average_watts / currentActivity.average_watts).toFixed(2);
                    html += createMetricCard(vi, '', 'VI');
                }
            }
            
            // „É©„É≥: „Éî„ÉÉ„ÉÅ„Å®„Çπ„Éà„É©„Ç§„ÉâÔºàÂøÉÊãç„Å®Áç≤ÂæóÊ®ôÈ´ò„ÅÆÈñìÔºâ
            if (sportCategory === 'run' && currentActivity.average_cadence) {
                // „Éî„ÉÉ„ÉÅÔºàStrava„ÅØÁâáË∂≥ÂàÜ„Å™„ÅÆ„Åß2ÂÄçÔºâ
                const avgPitch = Math.round(currentActivity.average_cadence * 2);
                html += createMetricCard(avgPitch, 'spm', '„Éî„ÉÉ„ÉÅ');
                
                // „Çπ„Éà„É©„Ç§„ÉâÈï∑ = ÈÄüÂ∫¶(m/min) / „Éî„ÉÉ„ÉÅ(steps/min)
                // ÈÄüÂ∫¶ = average_speed (m/s) * 60 = m/min
                if (currentActivity.average_speed) {
                    const speedMPerMin = currentActivity.average_speed * 60;
                    const stride = speedMPerMin / avgPitch;
                    html += createMetricCard(stride.toFixed(2), 'm', '„Çπ„Éà„É©„Ç§„Éâ');
                }
            }
            
            // Áç≤ÂæóÊ®ôÈ´òÔºàTSS„ÅÆÂâçÔºâ
            if (currentActivity.total_elevation_gain && currentActivity.total_elevation_gain > 10) {
                html += createMetricCard(Math.round(currentActivity.total_elevation_gain), 'm', 'Áç≤ÂæóÊ®ôÈ´ò');
            }
            
            // TSS
            if (currentActivity.tss) {
                html += createMetricCard(currentActivity.tss, '', 'TSS');
            }
            
            document.getElementById('summaryMetrics').innerHTML = html;
        }
        
        function createMetricCard(value, unit, label) {
            return `
                <div class="summary-metric">
                    <div class="summary-metric-value">${value}<small style="font-size: 0.6em; font-weight: 400;">${unit}</small></div>
                    <div class="summary-metric-label">${label}</div>
                </div>
            `;
        }
        
        // „Çπ„Ç§„É†Áî®„ÅÆ„Çπ„Éà„É≠„Éº„ÇØ„É°„Éà„É™„ÉÉ„ÇØ„ÇíÊ¶ÇË¶Å„Å´ËøΩÂä†
        function addSwimStrokeMetrics() {
            const sportCategory = getSportCategory(currentActivity.sport_type || currentActivity.type);
            if (sportCategory !== 'swim' || !currentActivity.laps || currentActivity.laps.length === 0) {
                console.log('addSwimStrokeMetrics: „Çπ„Ç§„É†„Åß„ÅØ„Å™„ÅÑ„Åã„É©„ÉÉ„Éó„Éá„Éº„Çø„Åå„ÅÇ„Çä„Åæ„Åõ„Çì');
                return;
            }
            
            console.log('addSwimStrokeMetrics: Ë®àÁÆóÈñãÂßã', currentActivity.laps.length, '„É©„ÉÉ„Éó');
            
            // ÊúâÂäπ„Å™„É©„ÉÉ„Éó„ÇíÊäΩÂá∫ÔºàREST„ÇíÈô§„ÅèÔºâ
            let totalDistance = 0;
            let totalStrokes = 0;
            let totalTime = 0; // Áßí
            
            currentActivity.laps.forEach((lap, i) => {
                const distance = lap.distance || 0;
                const movingTime = lap.moving_time || 0;
                const cadence = lap.average_cadence;
                
                // „Éö„Éº„ÇπË®àÁÆó
                let paceSeconds = null;
                if (lap.average_speed && lap.average_speed > 0) {
                    paceSeconds = 100 / lap.average_speed;
                } else if (movingTime > 0 && distance > 0) {
                    paceSeconds = (movingTime / distance) * 100;
                }
                
                // „É¨„Çπ„ÉàÂà§ÂÆö
                const isRest = distance === 0 ||
                               movingTime === 0 || 
                               movingTime < 10 ||
                               (paceSeconds && paceSeconds > 300) ||
                               (paceSeconds && paceSeconds < 60);
                
                if (!isRest && distance > 0 && movingTime > 0) {
                    // „Çπ„Éà„É≠„Éº„ÇØÊï∞„ÇíË®àÁÆóÔºàcadence„Åå„Å™„Åè„Å¶„ÇÇtotal_strokes„Åå„ÅÇ„Çå„Å∞‰Ωø„ÅÜÔºâ
                    let strokes = lap.total_strokes;
                    if (!strokes && cadence && movingTime) {
                        strokes = Math.round(cadence * movingTime / 60);
                    }
                    
                    if (strokes && strokes > 0) {
                        totalDistance += distance;
                        totalStrokes += strokes;
                        totalTime += movingTime;
                    }
                }
            });
            
            console.log('addSwimStrokeMetrics: Ë®àÁÆóÁµêÊûú', { totalDistance, totalStrokes, totalTime });
            
            if (totalStrokes === 0 || totalDistance === 0 || totalTime === 0) {
                console.log('addSwimStrokeMetrics: „Éá„Éº„Çø‰∏çË∂≥„Åß„Çπ„Ç≠„ÉÉ„Éó');
                return;
            }
            
            // Âä†ÈáçÂπ≥Âùá„ÇíË®àÁÆó
            const avgStrokeRate = Math.round(totalStrokes / totalTime * 60); // spm
            const avgDPS = (totalDistance / totalStrokes).toFixed(2); // m/stroke
            
            console.log('addSwimStrokeMetrics: Âπ≥ÂùáÂÄ§', { avgStrokeRate, avgDPS });
            
            // Ê¶ÇË¶Å„É°„Éà„É™„ÉÉ„ÇØ„ÇíÂÜçÊßãÁØâ
            const sportType = currentActivity.sport_type || currentActivity.type;
            let html = '';
            
            // Ë∑ùÈõ¢
            if (currentActivity.distance) {
                html += createMetricCard((currentActivity.distance / 1000).toFixed(2), 'km', 'Ë∑ùÈõ¢');
            }
            
            // ÊôÇÈñì
            html += createMetricCard(formatDuration(currentActivity.moving_time), '', 'ÊôÇÈñì');
            
            // „Éö„Éº„Çπ
            if (currentActivity.average_speed) {
                html += createMetricCard(formatSwimPace(currentActivity.average_speed), '/100m', '„Éö„Éº„Çπ');
            }
            
            // ÂøÉÊãç
            if (currentActivity.average_heartrate) {
                html += createMetricCard(Math.round(currentActivity.average_heartrate), 'bpm', 'Âπ≥ÂùáÂøÉÊãç');
            }
            
            // „Çπ„Éà„É≠„Éº„ÇØ„É¨„Éº„Éà„Å®DPSÔºàÂøÉÊãç„ÅÆÂæå„ÄÅTSS„ÅÆÂâçÔºâ
            html += createMetricCard(avgStrokeRate, 'spm', 'Stroke Rate');
            html += createMetricCard(avgDPS, 'm', 'DPS');
            
            // Áç≤ÂæóÊ®ôÈ´òÔºàTSS„ÅÆÂâçÔºâ
            if (currentActivity.total_elevation_gain && currentActivity.total_elevation_gain > 10) {
                html += createMetricCard(Math.round(currentActivity.total_elevation_gain), 'm', 'Áç≤ÂæóÊ®ôÈ´ò');
            }
            
            // TSS
            if (currentActivity.tss) {
                html += createMetricCard(currentActivity.tss, '', 'TSS');
            }
            
            document.getElementById('summaryMetrics').innerHTML = html;
            console.log('addSwimStrokeMetrics: Ê¶ÇË¶Å„É°„Éà„É™„ÉÉ„ÇØÊõ¥Êñ∞ÂÆå‰∫Ü');
        }
        
        // ===== „Ç∞„É©„ÉïÊèèÁîª =====
        function renderCharts() {
            renderMap();
            renderZoneChart();
            setupChartTabs();
            renderHeartRateChart();
            renderPaceChart();
            renderGAPChart();
            renderSportSpecificCharts();
            renderLapTable();
        }
        
        function setupChartTabs() {
            const sportCategory = getSportCategory(currentActivity.sport_type || currentActivity.type);
            
            // „Éê„Ç§„ÇØ„ÅÆÂ†¥Âêà„ÅØ„Éö„Éº„Çπ„Çø„Éñ„Çí„ÄåÈÄüÂ∫¶„Äç„Å´Â§âÊõ¥
            const paceTabBtn = document.querySelector('.tab-btn[data-tab="pace"]');
            if (sportCategory === 'bike' && paceTabBtn) {
                paceTabBtn.textContent = 'üö¥ ÈÄüÂ∫¶';
            }
            
            // Á®ÆÁõÆÂà•„Çø„Éñ„ÅÆË°®Á§∫Âà∂Âæ°
            if (sportCategory === 'bike') {
                document.getElementById('cadenceTab').style.display = 'inline-block';
                document.getElementById('cadenceTab').textContent = 'üîÑ „Ç±„Ç§„Éá„É≥„Çπ';
                if (currentActivity.average_watts || (streamData && streamData.watts)) {
                    document.getElementById('powerTab').style.display = 'inline-block';
                }
            } else if (sportCategory === 'run') {
                if (currentActivity.average_cadence || (streamData && streamData.cadence)) {
                    document.getElementById('cadenceTab').style.display = 'inline-block';
                    document.getElementById('cadenceTab').textContent = 'üëü „Éî„ÉÉ„ÉÅ';
                }
                // GAPÔºàGrade Adjusted PaceÔºâ„Çø„Éñ - Ê®ôÈ´ò„Éá„Éº„Çø„Åå„ÅÇ„ÇãÂ†¥Âêà„ÅÆ„Åø
                if (streamData && streamData.altitude && streamData.altitude.data && 
                    streamData.grade_smooth && streamData.grade_smooth.data) {
                    document.getElementById('gapTab').style.display = 'inline-block';
                }
            }
            
            // „Çø„Éñ„ÇØ„É™„ÉÉ„ÇØ„Ç§„Éô„É≥„Éà
            document.querySelectorAll('.tab-btn').forEach(btn => {
                btn.addEventListener('click', (e) => {
                    const tabId = e.target.dataset.tab;
                    switchChartTab(tabId);
                });
            });
        }
        
        function switchChartTab(tabId) {
            // „Çø„Éñ„Éú„Çø„É≥„ÅÆ„Ç¢„ÇØ„ÉÜ„Ç£„ÉñÁä∂ÊÖã„ÇíÊõ¥Êñ∞
            document.querySelectorAll('.tab-btn').forEach(btn => {
                btn.classList.remove('active');
                if (btn.dataset.tab === tabId) {
                    btn.classList.add('active');
                }
            });
            
            // „Çø„Éñ„Ç≥„É≥„ÉÜ„É≥„ÉÑ„ÅÆË°®Á§∫„ÇíÂàá„ÇäÊõø„Åà
            document.querySelectorAll('.chart-tab-content').forEach(content => {
                content.style.display = 'none';
            });
            document.getElementById(`${tabId}TabContent`).style.display = 'block';
            
            // „Ç∞„É©„Éï„ÅÆ„É™„Çµ„Ç§„Ç∫„Çí„Éà„É™„Ç¨„ÉºÔºàË°®Á§∫Âæå„Å´ÊèèÁîª„ÇíÊõ¥Êñ∞Ôºâ
            if (charts[tabId]) {
                charts[tabId].resize();
            }
        }
        
        function renderMap() {
            const mapContainer = document.getElementById('mapContainer');
            
            if (!streamData || !streamData.latlng || !streamData.latlng.data || streamData.latlng.data.length === 0) {
                mapContainer.innerHTML = '<div class="no-map-message">üó∫Ô∏è GPS„Éá„Éº„Çø„Åå„ÅÇ„Çä„Åæ„Åõ„ÇìÔºà„Ç§„É≥„Éâ„Ç¢„Ç¢„ÇØ„ÉÜ„Ç£„Éì„ÉÜ„Ç£„ÅÆÂèØËÉΩÊÄßÔºâ</div>';
                return;
            }
            
            const coords = streamData.latlng.data;
            
            map = L.map('routeMap');
            
            // CartoDB Positron - ËñÑ„ÅÑ„Ç∞„É¨„ÉºÁ≥ª„Åß„É´„Éº„Éà„ÅåË¶ã„ÇÑ„Åô„ÅÑ
            L.tileLayer('https://{s}.basemaps.cartocdn.com/light_all/{z}/{x}/{y}{r}.png', {
                attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> &copy; <a href="https://carto.com/attributions">CARTO</a>',
                maxZoom: 19,
                subdomains: 'abcd'
            }).addTo(map);
            
            // „É´„Éº„Éà„É©„Ç§„É≥„ÅÆ„Çπ„Çø„Ç§„É´
            const polyline = L.polyline(coords, { 
                color: '#667eea', 
                weight: 5, 
                opacity: 0.9,
                lineJoin: 'round'
            }).addTo(map);
            
            map.fitBounds(polyline.getBounds(), { padding: [30, 30] });
            
            // „Çπ„Çø„Éº„Éà„Éª„Ç¥„Éº„É´„Éû„Éº„Ç´„Éº
            const startIcon = L.divIcon({ 
                className: 'custom-marker', 
                html: '<div style="background: #22c55e; width: 14px; height: 14px; border-radius: 50%; border: 3px solid white; box-shadow: 0 2px 6px rgba(0,0,0,0.3);"></div>',
                iconSize: [20, 20],
                iconAnchor: [10, 10]
            });
            const endIcon = L.divIcon({ 
                className: 'custom-marker', 
                html: '<div style="background: #ef4444; width: 14px; height: 14px; border-radius: 50%; border: 3px solid white; box-shadow: 0 2px 6px rgba(0,0,0,0.3);"></div>',
                iconSize: [20, 20],
                iconAnchor: [10, 10]
            });
            
            L.marker(coords[0], { icon: startIcon }).addTo(map).bindPopup('„Çπ„Çø„Éº„Éà');
            L.marker(coords[coords.length - 1], { icon: endIcon }).addTo(map).bindPopup('„Ç¥„Éº„É´');
        }
        
        function renderZoneChart() {
            const zones = calculateHeartRateZones();
            
            // Zone „Çµ„Éû„É™„Éº
            const zoneSummaryHtml = zones.map((z, i) => `
                <div class="zone-item z${i + 1}">
                    <span class="zone-time">${formatDurationShort(z.time)}</span>
                    <span class="zone-percent">${z.percent.toFixed(0)}%</span>
                </div>
            `).join('');
            document.getElementById('zoneSummary').innerHTML = zoneSummaryHtml;
            
            // Zone „ÉÅ„É£„Éº„Éà
            const ctx = document.getElementById('zoneChart').getContext('2d');
            if (charts.zone) charts.zone.destroy();
            
            charts.zone = new Chart(ctx, {
                type: 'bar',
                data: {
                    labels: ['Z1', 'Z2', 'Z3', 'Z4', 'Z5'],
                    datasets: [{
                        data: zones.map(z => z.percent),
                        backgroundColor: ['#9ca3af', '#3b82f6', '#22c55e', '#f97316', '#ef4444']
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: { legend: { display: false } },
                    scales: {
                        y: { beginAtZero: true, max: 100, title: { display: true, text: '%' } }
                    }
                }
            });
        }
        
        function calculateHeartRateZones() {
            const thresholds = getUserThresholds();
            const maxHr = thresholds.maxHr || 190;
            const totalTime = currentActivity.moving_time || 0;
            
            // Stream„Éá„Éº„Çø„Åå„ÅÇ„ÇãÂ†¥Âêà„ÅØË©≥Á¥∞Ë®àÁÆó
            if (streamData && streamData.heartrate && streamData.heartrate.data && streamData.time) {
                const hrData = streamData.heartrate.data;
                const timeData = streamData.time.data;
                
                const zoneTimes = [0, 0, 0, 0, 0];
                
                for (let i = 1; i < hrData.length; i++) {
                    const hr = hrData[i];
                    const duration = timeData[i] - timeData[i - 1];
                    const hrPercent = (hr / maxHr) * 100;
                    
                    if (hrPercent < 60) zoneTimes[0] += duration;
                    else if (hrPercent < 70) zoneTimes[1] += duration;
                    else if (hrPercent < 80) zoneTimes[2] += duration;
                    else if (hrPercent < 90) zoneTimes[3] += duration;
                    else zoneTimes[4] += duration;
                }
                
                const total = zoneTimes.reduce((a, b) => a + b, 0) || 1;
                return zoneTimes.map(t => ({ time: t, percent: (t / total) * 100 }));
            }
            
            // Âπ≥ÂùáÂøÉÊãç„Åã„ÇâÊé®ÂÆö
            const avgHr = currentActivity.average_heartrate;
            if (!avgHr) return [0, 1, 2, 3, 4].map(() => ({ time: 0, percent: 0 }));
            
            const hrPercent = (avgHr / maxHr) * 100;
            const zones = [0, 0, 0, 0, 0];
            
            if (hrPercent < 60) zones[0] = 100;
            else if (hrPercent < 70) zones[1] = 100;
            else if (hrPercent < 80) zones[2] = 100;
            else if (hrPercent < 90) zones[3] = 100;
            else zones[4] = 100;
            
            return zones.map((p, i) => ({ time: p > 0 ? totalTime : 0, percent: p }));
        }
        
        function renderHeartRateChart() {
            const ctx = document.getElementById('hrChart').getContext('2d');
            if (charts.hr) charts.hr.destroy();
            
            if (!streamData || !streamData.heartrate || !streamData.heartrate.data) {
                ctx.canvas.parentElement.innerHTML = '<div class="no-map-message">ÂøÉÊãç„Éá„Éº„Çø„Åå„ÅÇ„Çä„Åæ„Åõ„Çì</div>';
                return;
            }
            
            const sportCategory = getSportCategory(currentActivity.sport_type || currentActivity.type);
            const hrData = streamData.heartrate.data;
            const timeData = streamData.time?.data || hrData.map((_, i) => i);
            const distanceData = streamData.distance?.data;
            const altitudeData = streamData.altitude?.data;
            
            // „Éá„Éº„Çø„Çí„Çµ„É≥„Éó„É™„É≥„Ç∞ÔºàÂ§ö„Åô„Åé„ÇãÂ†¥ÂêàÔºâ
            const maxPoints = 500;
            const step = Math.max(1, Math.floor(hrData.length / maxPoints));
            
            const labels = [];
            const data = [];
            const altData = [];
            
            for (let i = 0; i < hrData.length; i += step) {
                if (distanceData) {
                    // „Çπ„Ç§„É†„ÅØmÂçò‰Ωç„ÄÅ„Åù„Çå‰ª•Â§ñ„ÅØkmÂçò‰Ωç
                    if (sportCategory === 'swim') {
                        labels.push(Math.round(distanceData[i]));
                    } else {
                        labels.push((distanceData[i] / 1000).toFixed(1));
                    }
                } else {
                    labels.push(formatDurationShort(timeData[i]));
                }
                data.push(hrData[i]);
                if (altitudeData) {
                    altData.push(altitudeData[i]);
                }
            }
            
            // „Éá„Éº„Çø„Çª„ÉÉ„Éà
            const datasets = [{
                label: 'ÂøÉÊãçÊï∞',
                data: data,
                borderColor: '#ef4444',
                borderWidth: 1.5,
                fill: false,
                tension: 0.2,
                pointRadius: 0,
                yAxisID: 'y'
            }];
            
            // Ê®ôÈ´ò„Éá„Éº„Çø„Åå„ÅÇ„Çå„Å∞ËÉåÊôØ„Å®„Åó„Å¶ËøΩÂä†
            if (altData.length > 0 && sportCategory !== 'swim') {
                datasets.unshift({
                    label: 'Ê®ôÈ´ò',
                    data: altData,
                    borderColor: 'rgba(156, 163, 175, 0.3)',
                    backgroundColor: 'rgba(156, 163, 175, 0.15)',
                    borderWidth: 1,
                    fill: true,
                    tension: 0.2,
                    pointRadius: 0,
                    yAxisID: 'y1'
                });
            }
            
            const scales = {
                x: { 
                    title: { display: true, text: distanceData ? (sportCategory === 'swim' ? 'Ë∑ùÈõ¢ (m)' : 'Ë∑ùÈõ¢ (km)') : 'ÊôÇÈñì' },
                    ticks: {
                        maxTicksLimit: sportCategory === 'swim' ? 10 : 12,
                        callback: function(value, index) {
                            const label = this.getLabelForValue(value);
                            if (sportCategory === 'swim' && distanceData) {
                                const dist = parseFloat(label);
                                if (dist % 200 === 0 || index === 0) {
                                    return label;
                                }
                                return '';
                            }
                            return label;
                        }
                    }
                },
                y: { 
                    type: 'linear',
                    position: 'left',
                    title: { display: true, text: 'bpm' }
                }
            };
            
            // Ê®ôÈ´òÁî®„ÅÆÂè≥YËª∏
            if (altData.length > 0 && sportCategory !== 'swim') {
                scales.y1 = {
                    type: 'linear',
                    position: 'right',
                    title: { display: true, text: 'Ê®ôÈ´ò (m)' },
                    grid: { drawOnChartArea: false },
                    min: Math.min(...altData) - 10,
                    max: Math.max(...altData) + 10
                };
            }
            
            charts.hr = new Chart(ctx, {
                type: 'line',
                data: { labels: labels, datasets: datasets },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: { legend: { display: altData.length > 0 && sportCategory !== 'swim' } },
                    scales: scales,
                    interaction: {
                        intersect: false,
                        mode: 'index'
                    }
                }
            });
        }
        
        function renderPaceChart() {
            const ctx = document.getElementById('paceChart').getContext('2d');
            if (charts.pace) charts.pace.destroy();
            
            const sportCategory = getSportCategory(currentActivity.sport_type || currentActivity.type);
            
            // „Çπ„Ç§„É†„ÅÆÂ†¥ÂêàÔºö„É©„ÉÉ„Éó„Éá„Éº„Çø„Åå„ÅÇ„Çå„Å∞Ê£í„Ç∞„É©„Éï„Çí‰ΩøÁî®ÔºàFORM„Å™„Å©„Åã„Çâ„ÅÆ„Éá„Éº„ÇøÔºâ
            if (sportCategory === 'swim' && currentActivity.laps && currentActivity.laps.length > 0) {
                console.log('„Çπ„Ç§„É†: „É©„ÉÉ„Éó„Éá„Éº„Çø„Çí‰ΩøÁî®„Åó„Å¶Ê£í„Ç∞„É©„Éï„ÇíÊèèÁîª');
                renderSwimLapBarChart();
                return;
            }
            
            if (!streamData || !streamData.velocity_smooth || !streamData.velocity_smooth.data) {
                ctx.canvas.parentElement.innerHTML = '<div class="no-map-message">„Éö„Éº„Çπ/ÈÄüÂ∫¶„Éá„Éº„Çø„Åå„ÅÇ„Çä„Åæ„Åõ„Çì</div>';
                return;
            }
            
            const velData = streamData.velocity_smooth.data;
            const distanceData = streamData.distance?.data;
            const timeData = streamData.time?.data || velData.map((_, i) => i);
            const altitudeData = streamData.altitude?.data;
            
            // ÈÄüÂ∫¶„ÅÆÈñæÂÄ§„ÇíË®≠ÂÆöÔºàÂÅúÊ≠¢„ÇÑÊ≠©Ë°å„ÇíÈô§Â§ñÔºâ
            const minVelocity = getMinVelocityThreshold(sportCategory);
            
            let labels = [];
            let data = [];
            let altData = [];
            let rawPaceValues = [];
            
            // „Çπ„Ç§„É†„ÅÆÂ†¥Âêà„ÅØ„Çø„Éº„É≥Âçò‰ΩçÔºà25m/50mÔºâ„ÅÆÂπ≥Âùá„Éö„Éº„Çπ„Çí‰ΩøÁî®Ôºà„É©„ÉÉ„Éó„Éá„Éº„Çø„Åå„Å™„ÅÑÂ†¥Âêà„ÅÆ„Éï„Ç©„Éº„É´„Éê„ÉÉ„ÇØÔºâ
            if (sportCategory === 'swim' && distanceData) {
                const poolLength = detectPoolLength();
                const lapData = calculateSwimLapPaces(velData, distanceData, poolLength);
                labels = lapData.labels;
                data = lapData.paces;
                rawPaceValues = lapData.paces.filter(p => p && p > 0);
            } else {
                // ÈÄöÂ∏∏„ÅÆÂá¶ÁêÜÔºà„É©„É≥„ÄÅ„Éê„Ç§„ÇØÁ≠âÔºâ
                const maxPoints = 500;
                const step = Math.max(1, Math.floor(velData.length / maxPoints));
                
                for (let i = 0; i < velData.length; i += step) {
                    if (distanceData) {
                        labels.push((distanceData[i] / 1000).toFixed(1));
                    } else {
                        labels.push(formatDurationShort(timeData[i]));
                    }
                    
                    const vel = velData[i];
                    
                    if (sportCategory === 'bike') {
                        const speed = vel * 3.6; // km/h
                        data.push(speed);
                        if (vel >= minVelocity) rawPaceValues.push(speed);
                    } else {
                        // „É©„É≥: min/km
                        const pace = vel > 0 ? 1000 / vel / 60 : null;
                        data.push(pace);
                        if (vel >= minVelocity && pace) rawPaceValues.push(pace);
                    }
                    
                    // Ê®ôÈ´ò„Éá„Éº„Çø
                    if (altitudeData) {
                        altData.push(altitudeData[i]);
                    }
                }
            }
            
            // YËª∏„ÅÆÁØÑÂõ≤„ÇíË®àÁÆóÔºàÂ§ñ„ÇåÂÄ§„ÇíÈô§Â§ñÔºâ
            const yAxisRange = calculateYAxisRange(rawPaceValues, sportCategory);
            
            const xLabel = sportCategory === 'swim' ? 'Ë∑ùÈõ¢ (m)' : (distanceData ? 'Ë∑ùÈõ¢ (km)' : 'ÊôÇÈñì');
            const poolLength = sportCategory === 'swim' ? detectPoolLength() : null;
            
            // „Éá„Éº„Çø„Çª„ÉÉ„Éà
            const datasets = [];
            
            // Ê®ôÈ´òËÉåÊôØÔºà„É©„É≥„ÄÅ„Éê„Ç§„ÇØ„ÅÆ„ÅøÔºâ
            if (altData.length > 0 && sportCategory !== 'swim') {
                datasets.push({
                    label: 'Ê®ôÈ´ò',
                    data: altData,
                    borderColor: 'rgba(156, 163, 175, 0.3)',
                    backgroundColor: 'rgba(156, 163, 175, 0.15)',
                    borderWidth: 1,
                    fill: true,
                    tension: 0.2,
                    pointRadius: 0,
                    yAxisID: 'y1'
                });
            }
            
            // „É°„Ç§„É≥„ÅÆ„Éö„Éº„Çπ/ÈÄüÂ∫¶„Éá„Éº„Çø
            datasets.push({
                label: sportCategory === 'bike' ? 'ÈÄüÂ∫¶' : '„Éö„Éº„Çπ',
                data: data,
                borderColor: '#3b82f6',
                borderWidth: sportCategory === 'swim' ? 2 : 1.5,
                fill: false,
                tension: 0.2,
                pointRadius: sportCategory === 'swim' ? 3 : 0,
                pointBackgroundColor: '#3b82f6',
                spanGaps: true,
                yAxisID: 'y'
            });
            
            const scales = {
                x: { 
                    title: { display: true, text: xLabel },
                    ticks: {
                        maxTicksLimit: sportCategory === 'swim' ? 15 : 12,
                        callback: function(value, index) {
                            const label = this.getLabelForValue(value);
                            if (sportCategory === 'swim') {
                                const dist = parseFloat(label);
                                if (dist % 100 === 0) {
                                    return label + 'm';
                                }
                                return '';
                            }
                            return label;
                        }
                    }
                },
                y: { 
                    type: 'linear',
                    position: 'left',
                    title: { display: true, text: sportCategory === 'bike' ? 'km/h' : '„Éö„Éº„Çπ' },
                    reverse: sportCategory !== 'bike',
                    min: yAxisRange.min,
                    max: yAxisRange.max,
                    ticks: {
                        callback: function(value) {
                            if (sportCategory === 'bike') {
                                return value.toFixed(0);
                            } else if (sportCategory === 'swim') {
                                const min = Math.floor(value / 60);
                                const sec = Math.round(value % 60);
                                return `${min}:${String(sec).padStart(2, '0')}`;
                            } else {
                                const min = Math.floor(value);
                                const sec = Math.round((value - min) * 60);
                                return `${min}:${String(sec).padStart(2, '0')}`;
                            }
                        }
                    }
                }
            };
            
            // Ê®ôÈ´òÁî®YËª∏
            if (altData.length > 0 && sportCategory !== 'swim') {
                scales.y1 = {
                    type: 'linear',
                    position: 'right',
                    title: { display: true, text: 'Ê®ôÈ´ò (m)' },
                    grid: { drawOnChartArea: false },
                    min: Math.min(...altData) - 10,
                    max: Math.max(...altData) + 10
                };
            }
            
            charts.pace = new Chart(ctx, {
                type: 'line',
                data: { labels: labels, datasets: datasets },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: { legend: { display: altData.length > 0 && sportCategory !== 'swim' } },
                    scales: scales,
                    interaction: {
                        intersect: false,
                        mode: 'index'
                    },
                    plugins: {
                        tooltip: {
                            callbacks: {
                                title: function(context) {
                                    if (sportCategory === 'swim') {
                                        const dist = context[0].label;
                                        const lapNum = Math.ceil(parseFloat(dist) / poolLength);
                                        return `${dist}m („É©„ÉÉ„Éó ${lapNum})`;
                                    }
                                    return context[0].label;
                                },
                                label: function(context) {
                                    const value = context.raw;
                                    if (value === null) return `${context.dataset.label}: ÂÅúÊ≠¢‰∏≠`;
                                    
                                    if (context.dataset.label === 'Ê®ôÈ´ò') {
                                        return `Ê®ôÈ´ò: ${Math.round(value)}m`;
                                    }
                                    
                                    if (sportCategory === 'bike') {
                                        return `ÈÄüÂ∫¶: ${value.toFixed(1)} km/h`;
                                    } else if (sportCategory === 'swim') {
                                        const min = Math.floor(value / 60);
                                        const sec = Math.round(value % 60);
                                        return `„Éö„Éº„Çπ: ${min}:${String(sec).padStart(2, '0')}/100m`;
                                    } else {
                                        const min = Math.floor(value);
                                        const sec = Math.round((value - min) * 60);
                                        return `„Éö„Éº„Çπ: ${min}:${String(sec).padStart(2, '0')}/km`;
                                    }
                                }
                            }
                        }
                    }
                }
            });
        }
        
        // GAPÔºàGrade Adjusted PaceÔºâ„ÉÅ„É£„Éº„Éà - „É©„É≥„ÅÆ„Åø
        function renderGAPChart() {
            const sportCategory = getSportCategory(currentActivity.sport_type || currentActivity.type);
            
            // „É©„É≥„ÅÆ„Åø„ÄÅ„Åã„Å§ÂøÖË¶Å„Å™„Éá„Éº„Çø„Åå„ÅÇ„ÇãÂ†¥Âêà„ÅÆ„Åø
            if (sportCategory !== 'run') return;
            if (!streamData || !streamData.velocity_smooth?.data || !streamData.grade_smooth?.data) {
                return;
            }
            
            const ctx = document.getElementById('gapChart').getContext('2d');
            if (charts.gap) charts.gap.destroy();
            
            const velData = streamData.velocity_smooth.data;
            const gradeData = streamData.grade_smooth.data;
            const distanceData = streamData.distance?.data;
            const altitudeData = streamData.altitude?.data;
            const timeData = streamData.time?.data || velData.map((_, i) => i);
            
            // GAP„ÅÆË®àÁÆó
            // ÂÇæÊñú‰øÇÊï∞: ‰∏ä„Çä1%„ÅÇ„Åü„ÇäÁ¥Ñ0.03ËøΩÂä†„ÄÅ‰∏ã„Çä1%„ÅÇ„Åü„ÇäÁ¥Ñ0.015ÂâäÊ∏õ
            // GAP = Pace √ó (1 + grade * factor)
            // „Åü„Å†„ÅóÈÄüÂ∫¶„Éô„Éº„Çπ„ÅßË®àÁÆó: GAP_velocity = velocity / (1 + grade * factor)
            
            const maxPoints = 500;
            const step = Math.max(1, Math.floor(velData.length / maxPoints));
            
            const labels = [];
            const paceData = [];
            const gapData = [];
            const altData = [];
            const rawGapValues = [];
            
            const minVelocity = 0.5; // 0.5 m/s ‰ª•‰∏ã„ÅØÂÅúÊ≠¢„Å®„Åø„Å™„Åô
            
            for (let i = 0; i < velData.length; i += step) {
                if (distanceData) {
                    labels.push((distanceData[i] / 1000).toFixed(1));
                } else {
                    labels.push(formatDurationShort(timeData[i]));
                }
                
                const vel = velData[i];
                const grade = gradeData[i] || 0; // „Éë„Éº„Çª„É≥„Éà
                
                // „Éö„Éº„ÇπÔºàmin/kmÔºâ
                const pace = vel > minVelocity ? 1000 / vel / 60 : null;
                paceData.push(pace);
                
                // GAPË®àÁÆó
                // ‰∏ä„Çä: 1%„ÅÇ„Åü„Çä+3%„ÄÅ‰∏ã„Çä: 1%„ÅÇ„Åü„Çä-1.5%Ôºà‰∏ã„Çä„ÅØÂäπÊûú„ÅåÂ∞è„Åï„ÅÑÔºâ
                let gapFactor;
                if (grade >= 0) {
                    gapFactor = 1 + grade * 0.03; // ‰∏ä„Çä
                } else {
                    gapFactor = 1 + grade * 0.015; // ‰∏ã„ÇäÔºàÂäπÊûúÂ∞è„Åï„ÇÅÔºâ
                }
                
                // GAP = ÂÆüÈöõ„ÅÆ„Éö„Éº„Çπ √ó ÂÇæÊñú‰øÇÊï∞
                // ‰∏ä„Çä„Åß„ÅØÂÆüÈöõ„Çà„ÇäÈÅÖ„ÅÑ„Éö„Éº„Çπ„Åß„ÇÇ„ÄÅGAP„ÅØÈÄü„Åè„Å™„ÇãÔºàÂä™ÂäõÂ∫¶„ÅåÈ´ò„ÅÑÔºâ
                const gap = vel > minVelocity ? (1000 / vel / 60) / gapFactor : null;
                gapData.push(gap);
                
                if (gap && gap > 2 && gap < 15) { // 2:00„Äú15:00/km„ÅÆÁØÑÂõ≤ÂÜÖ
                    rawGapValues.push(gap);
                }
                
                if (altitudeData) {
                    altData.push(altitudeData[i]);
                }
            }
            
            // Âπ≥ÂùáGAPË®àÁÆó
            const validGaps = rawGapValues.filter(g => g);
            const avgGap = validGaps.length > 0 ? validGaps.reduce((a, b) => a + b, 0) / validGaps.length : 0;
            const avgGapFormatted = avgGap > 0 ? `${Math.floor(avgGap)}:${String(Math.round((avgGap % 1) * 60)).padStart(2, '0')}` : '-';
            
            // Âπ≥Âùá„Éö„Éº„Çπ
            const validPaces = paceData.filter(p => p && p > 2 && p < 15);
            const avgPace = validPaces.length > 0 ? validPaces.reduce((a, b) => a + b, 0) / validPaces.length : 0;
            const avgPaceFormatted = avgPace > 0 ? `${Math.floor(avgPace)}:${String(Math.round((avgPace % 1) * 60)).padStart(2, '0')}` : '-';
            
            // „É°„Éà„É™„ÇØ„ÇπË°®Á§∫
            document.getElementById('gapMetrics').innerHTML = `
                <div class="sport-metric-item">
                    <div class="sport-metric-value">${avgPaceFormatted}</div>
                    <div class="sport-metric-label">Âπ≥Âùá„Éö„Éº„Çπ (/km)</div>
                </div>
                <div class="sport-metric-item">
                    <div class="sport-metric-value">${avgGapFormatted}</div>
                    <div class="sport-metric-label">Âπ≥ÂùáGAP (/km)</div>
                </div>
            `;
            
            // YËª∏ÁØÑÂõ≤
            const yAxisRange = calculateYAxisRange(rawGapValues, 'run');
            
            // „Éá„Éº„Çø„Çª„ÉÉ„Éà
            const datasets = [];
            
            // Ê®ôÈ´òËÉåÊôØ
            if (altData.length > 0) {
                datasets.push({
                    label: 'Ê®ôÈ´ò',
                    data: altData,
                    borderColor: 'rgba(156, 163, 175, 0.3)',
                    backgroundColor: 'rgba(156, 163, 175, 0.15)',
                    borderWidth: 1,
                    fill: true,
                    tension: 0.2,
                    pointRadius: 0,
                    yAxisID: 'y1'
                });
            }
            
            // ÂÆüÈöõ„ÅÆ„Éö„Éº„ÇπÔºàËñÑ„ÅÑËâ≤Ôºâ
            datasets.push({
                label: '„Éö„Éº„Çπ',
                data: paceData,
                borderColor: 'rgba(59, 130, 246, 0.4)',
                borderWidth: 1,
                fill: false,
                tension: 0.2,
                pointRadius: 0,
                yAxisID: 'y'
            });
            
            // GAPÔºàÊøÉ„ÅÑËâ≤Ôºâ
            datasets.push({
                label: 'GAP',
                data: gapData,
                borderColor: '#10b981',
                borderWidth: 1.5,
                fill: false,
                tension: 0.2,
                pointRadius: 0,
                yAxisID: 'y'
            });
            
            const scales = {
                x: { 
                    title: { display: true, text: distanceData ? 'Ë∑ùÈõ¢ (km)' : 'ÊôÇÈñì' },
                    ticks: { maxTicksLimit: 12 }
                },
                y: { 
                    type: 'linear',
                    position: 'left',
                    title: { display: true, text: '„Éö„Éº„Çπ (min/km)' },
                    reverse: true,
                    min: yAxisRange.min,
                    max: yAxisRange.max,
                    ticks: {
                        callback: function(value) {
                            const min = Math.floor(value);
                            const sec = Math.round((value - min) * 60);
                            return `${min}:${String(sec).padStart(2, '0')}`;
                        }
                    }
                }
            };
            
            // Ê®ôÈ´òÁî®YËª∏
            if (altData.length > 0) {
                scales.y1 = {
                    type: 'linear',
                    position: 'right',
                    title: { display: true, text: 'Ê®ôÈ´ò (m)' },
                    grid: { drawOnChartArea: false },
                    min: Math.min(...altData) - 10,
                    max: Math.max(...altData) + 10
                };
            }
            
            charts.gap = new Chart(ctx, {
                type: 'line',
                data: { labels: labels, datasets: datasets },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: { 
                        legend: { display: true }
                    },
                    scales: scales,
                    interaction: {
                        intersect: false,
                        mode: 'index'
                    },
                    plugins: {
                        tooltip: {
                            callbacks: {
                                label: function(context) {
                                    const value = context.raw;
                                    if (value === null) return `${context.dataset.label}: ÂÅúÊ≠¢‰∏≠`;
                                    
                                    if (context.dataset.label === 'Ê®ôÈ´ò') {
                                        return `Ê®ôÈ´ò: ${Math.round(value)}m`;
                                    }
                                    
                                    const min = Math.floor(value);
                                    const sec = Math.round((value - min) * 60);
                                    return `${context.dataset.label}: ${min}:${String(sec).padStart(2, '0')}/km`;
                                }
                            }
                        }
                    }
                }
            });
        }
        
        // „Çπ„Ç§„É†„É©„ÉÉ„ÉóÊ£í„Ç∞„É©„ÉïÔºàHTML/CSS„ÅßÊèèÁîª„ÄÅXËª∏=Ë∑ùÈõ¢„ÄÅÊ£íÂπÖ„ÅØË∑ùÈõ¢„Å´ÊØî‰æãÔºâ
        function renderSwimLapBarChart() {
            if (!currentActivity.laps || currentActivity.laps.length === 0) {
                return;
            }
            
            // Chart.js„ÅÆ„Ç§„É≥„Çπ„Çø„É≥„Çπ„Åå„ÅÇ„Çå„Å∞Á†¥Ê£Ñ
            if (charts.pace) {
                charts.pace.destroy();
                charts.pace = null;
            }
            
            const container = document.getElementById('paceChart').parentElement;
            const laps = currentActivity.laps;
            
            // Ê≥≥„Åé„É©„ÉÉ„Éó„ÅÆ„ÅøÊäΩÂá∫ÔºàREST„ÇíÈô§Â§ñÔºâ
            const swimLaps = [];
            let cumulativeDistance = 0;
            
            laps.forEach((lap, index) => {
                const distance = lap.distance || 0;
                const movingTime = lap.moving_time || 0;
                
                // „Éö„Éº„ÇπË®àÁÆóÔºàÁßí/100mÔºâ
                let paceSeconds = null;
                if (lap.average_speed && lap.average_speed > 0) {
                    paceSeconds = 100 / lap.average_speed;
                } else if (movingTime > 0 && distance > 0) {
                    paceSeconds = (movingTime / distance) * 100;
                }
                
                // „É¨„Çπ„ÉàÂà§ÂÆö
                const isRest = distance === 0 ||
                               movingTime === 0 || 
                               movingTime < 10 ||
                               (paceSeconds && paceSeconds > 300) ||
                               (paceSeconds && paceSeconds < 60);
                
                if (!isRest && paceSeconds && distance > 0) {
                    // „Çπ„Éà„É≠„Éº„ÇØÊï∞„ÇíË®àÁÆóÔºàtotal_strokes„Åå„Å™„Åë„Çå„Å∞cadence„Å®ÊôÇÈñì„Åã„ÇâË®àÁÆóÔºâ
                    let strokes = lap.total_strokes;
                    if (!strokes && lap.average_cadence && movingTime) {
                        strokes = Math.round(lap.average_cadence * movingTime / 60);
                    }
                    
                    swimLaps.push({
                        lapNumber: index + 1,
                        distance: distance,
                        startDistance: cumulativeDistance,
                        endDistance: cumulativeDistance + distance,
                        paceSeconds: paceSeconds,
                        movingTime: movingTime,
                        heartrate: lap.average_heartrate,
                        strokes: strokes,
                        cadence: lap.average_cadence
                    });
                    cumulativeDistance += distance;
                }
            });
            
            const totalDistance = cumulativeDistance;
            console.log(`Ê≥≥„Åé„É©„ÉÉ„Éó: ${swimLaps.length}, Á∑èË∑ùÈõ¢: ${totalDistance}m`);
            
            if (swimLaps.length === 0) {
                container.innerHTML = '<div class="no-map-message">ÊúâÂäπ„Å™„Çπ„Ç§„É†„É©„ÉÉ„Éó„Éá„Éº„Çø„Åå„ÅÇ„Çä„Åæ„Åõ„Çì</div>';
                return;
            }
            
            // YËª∏ÁØÑÂõ≤„ÇíË®àÁÆó
            const paces = swimLaps.map(d => d.paceSeconds);
            const minPace = Math.min(...paces);
            const maxPace = Math.max(...paces);
            const avgPace = paces.reduce((a,b)=>a+b,0) / paces.length;
            const paceRange = maxPace - minPace || 20;
            const padding = Math.max(paceRange * 0.15, 5);
            const yMin = Math.floor((minPace - padding) / 5) * 5;
            const yMax = Math.ceil((maxPace + padding) / 5) * 5;
            
            // XËª∏„ÅÆÁõÆÁõõ„Çä
            const xStep = calculateXAxisStep(totalDistance);
            const xTicks = [];
            for (let d = 0; d <= totalDistance; d += xStep) {
                xTicks.push(d);
            }
            if (xTicks[xTicks.length - 1] !== totalDistance) {
                xTicks.push(totalDistance);
            }
            
            // YËª∏„ÅÆÁõÆÁõõ„ÇäÔºàÁØÑÂõ≤„Å´Âøú„Åò„Å¶ÈñìÈöî„ÇíË™øÊï¥„ÄÅ3„Äú6ÂÄãÁ®ãÂ∫¶„Å´„Å™„Çã„Çà„ÅÜ„Å´Ôºâ
            const yRange = yMax - yMin;
            let yStep;
            if (yRange <= 20) yStep = 5;        // 20Áßí‰ª•ÂÜÖ„Å™„Çâ5ÁßíÂàª„Åø
            else if (yRange <= 40) yStep = 10;  // 40Áßí‰ª•ÂÜÖ„Å™„Çâ10ÁßíÂàª„Åø
            else if (yRange <= 90) yStep = 15;  // 90Áßí‰ª•ÂÜÖ„Å™„Çâ15ÁßíÂàª„Åø
            else if (yRange <= 120) yStep = 20; // 2ÂàÜ‰ª•ÂÜÖ„Å™„Çâ20ÁßíÂàª„Åø
            else yStep = 30;                    // „Åù„Çå‰ª•‰∏ä„ÅØ30ÁßíÂàª„Åø
            
            const yTicks = [];
            const yStart = Math.ceil(yMin / yStep) * yStep;
            for (let p = yStart; p <= yMax; p += yStep) {
                yTicks.push(p);
            }
            
            // HTMLÁîüÊàê
            let html = `
                <div class="swim-chart-container">
                    <div class="swim-chart-title">„É©„ÉÉ„Éó„Éö„Éº„ÇπÔºà${swimLaps.length}Êú¨„ÄÅÂπ≥Âùá: ${formatPaceDebug(avgPace)}Ôºâ</div>
                    <div class="swim-chart-wrapper">
                        <div class="swim-chart-y-axis">
                            ${yTicks.map(p => `<div class="swim-y-tick" style="bottom: ${((yMax - p) / (yMax - yMin)) * 100}%">${Math.floor(p/60)}:${String(Math.round(p%60)).padStart(2,'0')}</div>`).join('')}
                            <div class="swim-y-label">„Éö„Éº„Çπ (/100m)</div>
                        </div>
                        <div class="swim-chart-area">
                            <div class="swim-chart-grid">
                                ${yTicks.map(p => `<div class="swim-grid-line-h" style="bottom: ${((yMax - p) / (yMax - yMin)) * 100}%"></div>`).join('')}
                                ${xTicks.map(d => `<div class="swim-grid-line-v" style="left: ${(d / totalDistance) * 100}%"></div>`).join('')}
                            </div>
                            <div class="swim-bars">
                                ${swimLaps.map(lap => {
                                    const left = (lap.startDistance / totalDistance) * 100;
                                    const width = (lap.distance / totalDistance) * 100;
                                    // ÈÄü„ÅÑ„Éö„Éº„ÇπÔºàÂ∞è„Åï„ÅÑÂÄ§Ôºâ„Åª„Å©È´ò„ÅÑÊ£í„Å´„Å™„Çã„Çà„ÅÜ„Å´Ë®àÁÆó
                                    const height = ((yMax - lap.paceSeconds) / (yMax - yMin)) * 100;
                                    return `<div class="swim-bar" 
                                        style="left: ${left}%; width: ${width}%; height: ${height}%;"
                                        data-lap='${JSON.stringify(lap)}'
                                        title="${lap.startDistance}m-${lap.endDistance}m: ${formatPaceDebug(lap.paceSeconds)}"></div>`;
                                }).join('')}
                            </div>
                        </div>
                    </div>
                    <div class="swim-chart-x-axis">
                        ${xTicks.map(d => `<div class="swim-x-tick" style="left: ${(d / totalDistance) * 100}%">${d}m</div>`).join('')}
                        <div class="swim-x-label">Ë∑ùÈõ¢ (m)</div>
                    </div>
                </div>
            `;
            
            container.innerHTML = html;
            
            // „ÉÑ„Éº„É´„ÉÅ„ÉÉ„Éó„Ç§„Éô„É≥„Éà
            container.querySelectorAll('.swim-bar').forEach(bar => {
                bar.addEventListener('mouseenter', (e) => {
                    const lap = JSON.parse(e.target.dataset.lap);
                    showSwimTooltip(e, lap);
                });
                bar.addEventListener('mousemove', (e) => {
                    moveSwimTooltip(e);
                });
                bar.addEventListener('mouseleave', hideSwimTooltip);
            });
        }
        
        // XËª∏„ÅÆÁõÆÁõõ„ÇäÈñìÈöî„ÇíË®àÁÆó
        function calculateXAxisStep(totalDistance) {
            if (totalDistance <= 500) return 100;
            if (totalDistance <= 1000) return 200;
            if (totalDistance <= 2000) return 500;
            if (totalDistance <= 5000) return 500;
            return 1000;
        }
        
        // „Çπ„Ç§„É†„ÉÅ„É£„Éº„Éà„ÅÆ„ÉÑ„Éº„É´„ÉÅ„ÉÉ„Éó
        let swimTooltip = null;
        
        function showSwimTooltip(e, lap) {
            if (!swimTooltip) {
                swimTooltip = document.createElement('div');
                swimTooltip.className = 'swim-tooltip';
                document.body.appendChild(swimTooltip);
            }
            
            let html = `<strong>${lap.startDistance}m - ${lap.endDistance}m (Lap ${lap.lapNumber})</strong><br>`;
            html += `„Éö„Éº„Çπ: ${formatPaceDebug(lap.paceSeconds)}<br>`;
            html += `ÊôÇÈñì: ${lap.movingTime}Áßí<br>`;
            html += `Ë∑ùÈõ¢: ${lap.distance}m`;
            if (lap.heartrate) html += `<br>ÂøÉÊãç: ${Math.round(lap.heartrate)} bpm`;
            if (lap.strokes) html += `<br>Strokes: ${lap.strokes}`;
            if (lap.cadence) html += `<br>Rate: ${lap.cadence} spm`;
            if (lap.strokes && lap.distance > 0) {
                const dps = (lap.distance / lap.strokes).toFixed(2);
                html += `<br>DPS: ${dps}m`;
            }
            
            swimTooltip.innerHTML = html;
            swimTooltip.style.display = 'block';
            swimTooltip.style.left = (e.clientX + 15) + 'px';
            swimTooltip.style.top = (e.clientY + 15) + 'px';
        }
        
        function moveSwimTooltip(e) {
            if (swimTooltip) {
                swimTooltip.style.left = (e.clientX + 15) + 'px';
                swimTooltip.style.top = (e.clientY + 15) + 'px';
            }
        }
        
        function hideSwimTooltip() {
            if (swimTooltip) {
                swimTooltip.style.display = 'none';
            }
        }
        
        // Á®ÆÁõÆÂà•„ÅÆÊúÄÂ∞èÈÄüÂ∫¶ÈñæÂÄ§Ôºà„Åì„Çå‰ª•‰∏ã„ÅØÂÅúÊ≠¢/Ê≠©Ë°å„Å®„Åø„Å™„ÅôÔºâ
        function getMinVelocityThreshold(sportCategory) {
            switch (sportCategory) {
                case 'bike':
                    return 3.0; // 10.8 km/h ‰ª•‰∏ã„ÅØÈô§Â§ñ
                case 'run':
                    return 1.5; // 5.4 km/h (Á¥Ñ11:00/km) ‰ª•‰∏ã„ÅØÈô§Â§ñ
                case 'swim':
                    return 0.3; // 3:20/100m „Çà„ÇäÈÅÖ„ÅÑ„ÇÇ„ÅÆ„ÅØÈô§Â§ñ
                default:
                    return 1.0;
            }
        }
        
        // YËª∏„ÅÆÁØÑÂõ≤„Çí„Éë„Éº„Çª„É≥„Çø„Ç§„É´„Éô„Éº„Çπ„ÅßË®àÁÆó
        function calculateYAxisRange(values, sportCategory) {
            if (values.length === 0) {
                return { min: undefined, max: undefined };
            }
            
            // „ÇΩ„Éº„Éà„Åó„Å¶ÁØÑÂõ≤„ÇíË®àÁÆó
            const sorted = [...values].sort((a, b) => a - b);
            const minVal = sorted[0];
            const maxVal = sorted[sorted.length - 1];
            const range = maxVal - minVal;
            const padding = range * 0.05; // 5%„ÅÆ‰ΩôÁôΩ
            
            if (sportCategory === 'bike') {
                // „Éê„Ç§„ÇØÈÄüÂ∫¶ÔºöÂÖ®„Éá„Éº„ÇøË°®Á§∫Ôºà0„Åã„ÇâÊúÄÂ§ßÂÄ§Ôºâ
                return {
                    min: 0,
                    max: Math.ceil(maxVal + padding)
                };
            } else if (sportCategory === 'run') {
                // „É©„É≥„Éö„Éº„ÇπÔºöÂÖ®„Éá„Éº„ÇøË°®Á§∫
                return {
                    min: Math.max(0, Math.floor(minVal - padding)),
                    max: Math.ceil(maxVal + padding)
                };
            } else if (sportCategory === 'swim') {
                // „Çπ„Ç§„É†: „Éë„Éº„Çª„É≥„Çø„Ç§„É´„Éô„Éº„Çπ„ÅßÁØÑÂõ≤„ÇíË®≠ÂÆö
                const p5 = sorted[Math.floor(sorted.length * 0.05)];
                const p95 = sorted[Math.floor(sorted.length * 0.95)];
                const pRange = p95 - p5;
                const pPadding = pRange * 0.15;
                console.log('„Çπ„Ç§„É†YËª∏Ë®àÁÆó: p5=', formatPaceDebug(p5), 'p95=', formatPaceDebug(p95));
                return {
                    min: Math.max(60, p5 - pPadding),   // ÊúÄÈÄü„Åß„ÇÇ1:00/100m
                    max: Math.min(300, p95 + pPadding)  // ÊúÄÈÅÖ„Åß„ÇÇ5:00/100m
                };
            }
            
            // „Éá„Éï„Ç©„É´„Éà
            return { 
                min: Math.max(0, Math.floor(minVal - padding)), 
                max: Math.ceil(maxVal + padding) 
            };
        }
        
        // „Çπ„Ç§„É†„ÅÆ„Çø„Éº„É≥Âçò‰ΩçÔºà25m/50mÔºâÂπ≥Âùá„Éö„Éº„Çπ„ÇíË®àÁÆó
        function calculateSwimLapPaces(velocityData, distanceData, poolLength = 25) {
            if (!velocityData || !distanceData || velocityData.length === 0) {
                return { labels: [], paces: [] };
            }
            
            // „Éá„Éê„ÉÉ„Ç∞: velocity_smooth„ÅÆÁµ±Ë®à„ÇíÂá∫Âäõ
            const validVelocities = velocityData.filter(v => v > 0);
            console.log('=== „Çπ„Ç§„É†„Éö„Éº„Çπ„Éá„Éê„ÉÉ„Ç∞ ===');
            console.log('velocity_smooth „Çµ„É≥„Éó„É´Êï∞:', velocityData.length);
            console.log('ÊúâÂäπ„Å™ÈÄüÂ∫¶„Éá„Éº„ÇøÊï∞:', validVelocities.length);
            console.log('ÈÄüÂ∫¶ ÊúÄÂ∞èÂÄ§ (m/s):', Math.min(...validVelocities).toFixed(3));
            console.log('ÈÄüÂ∫¶ ÊúÄÂ§ßÂÄ§ (m/s):', Math.max(...validVelocities).toFixed(3));
            console.log('ÈÄüÂ∫¶ Âπ≥ÂùáÂÄ§ (m/s):', (validVelocities.reduce((a,b)=>a+b,0)/validVelocities.length).toFixed(3));
            // „Éö„Éº„ÇπÊèõÁÆó
            const minVel = Math.min(...validVelocities);
            const maxVel = Math.max(...validVelocities);
            console.log('„Éö„Éº„ÇπÊèõÁÆó ÊúÄÈÄü (sec/100m):', (100/maxVel).toFixed(1), '=', formatPaceDebug(100/maxVel));
            console.log('„Éö„Éº„ÇπÊèõÁÆó ÊúÄÈÅÖ (sec/100m):', (100/minVel).toFixed(1), '=', formatPaceDebug(100/minVel));
            
            const labels = [];
            const paces = [];
            
            let currentLapStart = 0;
            let lapNumber = 1;
            
            // ÂêÑ„É©„ÉÉ„Éó„ÅÆÈñãÂßã„ÉªÁµÇ‰∫Ü„Ç§„É≥„Éá„ÉÉ„ÇØ„Çπ„ÇíÁâπÂÆö„Åó„Å¶Âπ≥Âùá„Éö„Éº„Çπ„ÇíË®àÁÆó
            for (let targetDist = poolLength; targetDist <= distanceData[distanceData.length - 1]; targetDist += poolLength) {
                // „Åì„ÅÆ„É©„ÉÉ„Éó„ÅÆÁµÇ‰∫Ü‰ΩçÁΩÆ„ÇíË¶ã„Å§„Åë„Çã
                let lapEnd = currentLapStart;
                while (lapEnd < distanceData.length && distanceData[lapEnd] < targetDist) {
                    lapEnd++;
                }
                
                if (lapEnd <= currentLapStart) {
                    currentLapStart = lapEnd;
                    continue;
                }
                
                // „Åì„ÅÆ„É©„ÉÉ„ÉóÂÜÖ„ÅÆÊúâÂäπ„Å™ÈÄüÂ∫¶„Éá„Éº„Çø„ÇíÂèéÈõÜ
                const lapVelocities = [];
                for (let i = currentLapStart; i < lapEnd; i++) {
                    const vel = velocityData[i];
                    // ÊúâÂäπ„Å™ÈÄüÂ∫¶„ÅÆ„Åø„Çí‰ΩøÁî®Ôºà0.2 m/s = 8:20/100m „Çà„ÇäÈÄü„ÅÑ„ÇÇ„ÅÆÔºâ
                    if (vel && vel > 0.2) {
                        lapVelocities.push(vel);
                    }
                }
                
                if (lapVelocities.length > 0) {
                    // Âπ≥ÂùáÈÄüÂ∫¶„ÇíË®àÁÆó
                    const avgVelocity = lapVelocities.reduce((a, b) => a + b, 0) / lapVelocities.length;
                    // „Éö„Éº„ÇπÔºàÁßí/100mÔºâ„Å´Â§âÊèõ
                    const paceSeconds = 100 / avgVelocity;
                    
                    labels.push(targetDist); // „É©„ÉÉ„ÉóÁµÇ‰∫ÜÂú∞ÁÇπ„ÅÆË∑ùÈõ¢
                    paces.push(paceSeconds);
                    
                    // Áï∞Â∏∏ÂÄ§„ÅÆ„Éá„Éê„ÉÉ„Ç∞
                    if (paceSeconds < 90 || paceSeconds > 200) {
                        console.log(`„É©„ÉÉ„Éó${lapNumber} (${targetDist}m): Áï∞Â∏∏„Éö„Éº„Çπ ${formatPaceDebug(paceSeconds)}, Âπ≥ÂùáÈÄüÂ∫¶=${avgVelocity.toFixed(3)}m/s, „Çµ„É≥„Éó„É´Êï∞=${lapVelocities.length}`);
                    }
                }
                
                currentLapStart = lapEnd;
                lapNumber++;
            }
            
            console.log('Ë®àÁÆó„Åï„Çå„Åü„É©„ÉÉ„ÉóÊï∞:', paces.length);
            console.log('„Éö„Éº„ÇπÁØÑÂõ≤:', formatPaceDebug(Math.min(...paces)), '„Äú', formatPaceDebug(Math.max(...paces)));
            console.log('=========================');
            
            return { labels, paces };
        }
        
        // „Éá„Éê„ÉÉ„Ç∞Áî®„Éö„Éº„Çπ„Éï„Ç©„Éº„Éû„ÉÉ„Éà
        function formatPaceDebug(seconds) {
            const min = Math.floor(seconds / 60);
            const sec = Math.round(seconds % 60);
            return `${min}:${String(sec).padStart(2, '0')}/100m`;
        }
        
        // „Éó„Éº„É´Èï∑„ÇíÊé®ÂÆöÔºà„Ç¢„ÇØ„ÉÜ„Ç£„Éì„ÉÜ„Ç£„Éá„Éº„Çø„Åæ„Åü„ÅØ„Éá„Éï„Ç©„É´„ÉàÂÄ§„Åã„ÇâÔºâ
        function detectPoolLength() {
            // Strava„Ç¢„ÇØ„ÉÜ„Ç£„Éì„ÉÜ„Ç£„Åã„Çâ„Éó„Éº„É´Èï∑„ÇíÂèñÂæóÔºàpool_length„Éï„Ç£„Éº„É´„Éâ„Åå„ÅÇ„ÇãÂ†¥ÂêàÔºâ
            if (currentActivity.pool_length) {
                return currentActivity.pool_length;
            }
            // Ë∑ùÈõ¢„Åã„ÇâÊé®Ê∏¨Ôºà25m„Éó„Éº„É´„Åã50m„Éó„Éº„É´„ÅãÔºâ
            // ÈÄöÂ∏∏„ÄÅ25m„Éó„Éº„É´„ÅåÂ§ö„ÅÑ„ÅÆ„Åß„Éá„Éï„Ç©„É´„Éà„ÅØ25m
            return 25;
        }
        
        function renderSportSpecificCharts() {
            const sportCategory = getSportCategory(currentActivity.sport_type || currentActivity.type);
            
            if (sportCategory === 'bike') {
                renderBikeCharts();
            } else if (sportCategory === 'run') {
                renderRunCharts();
            }
        }
        
        function renderBikeCharts() {
            // „Éë„ÉØ„Éº„ÉÅ„É£„Éº„Éà
            if (streamData && streamData.watts && streamData.watts.data) {
                // „Éë„ÉØ„Éº„É°„Éà„É™„ÇØ„Çπ
                const avgPower = currentActivity.average_watts || 0;
                const np = currentActivity.weighted_average_watts || 0;
                const vi = avgPower > 0 ? (np / avgPower).toFixed(2) : '-';
                document.getElementById('powerMetrics').innerHTML = `
                    <div class="sport-metric-item">
                        <div class="sport-metric-value">${Math.round(avgPower)}</div>
                        <div class="sport-metric-label">Âπ≥Âùá„Éë„ÉØ„Éº (W)</div>
                    </div>
                    <div class="sport-metric-item">
                        <div class="sport-metric-value">${Math.round(np)}</div>
                        <div class="sport-metric-label">NP (W)</div>
                    </div>
                    <div class="sport-metric-item">
                        <div class="sport-metric-value">${vi}</div>
                        <div class="sport-metric-label">VI</div>
                    </div>
                `;
                
                renderTimeSeriesChart('powerChart', streamData.watts.data, '„Éë„ÉØ„Éº', '#8b5cf6', 'W', 'power');
            }
            
            // „Ç±„Ç§„Éá„É≥„Çπ„ÉÅ„É£„Éº„Éà
            if (streamData && streamData.cadence && streamData.cadence.data) {
                const avgCadence = currentActivity.average_cadence || 0;
                document.getElementById('cadenceMetrics').innerHTML = `
                    <div class="sport-metric-item">
                        <div class="sport-metric-value">${Math.round(avgCadence)}</div>
                        <div class="sport-metric-label">Âπ≥Âùá„Ç±„Ç§„Éá„É≥„Çπ (rpm)</div>
                    </div>
                `;
                
                renderTimeSeriesChart('cadenceChart', streamData.cadence.data, '„Ç±„Ç§„Éá„É≥„Çπ', '#22c55e', 'rpm', 'cadence');
            }
        }
        
        function renderRunCharts() {
            // „Éî„ÉÉ„ÉÅ/„Ç±„Ç§„Éá„É≥„Çπ„ÉÅ„É£„Éº„Éà
            if (streamData && streamData.cadence && streamData.cadence.data) {
                const avgCadence = currentActivity.average_cadence || 0;
                document.getElementById('cadenceMetrics').innerHTML = `
                    <div class="sport-metric-item">
                        <div class="sport-metric-value">${Math.round(avgCadence * 2)}</div>
                        <div class="sport-metric-label">Âπ≥Âùá„Éî„ÉÉ„ÉÅ (spm)</div>
                    </div>
                `;
                
                // „É©„É≥„ÅÆÂ†¥Âêà„ÅØ„Ç±„Ç§„Éá„É≥„Çπ„Çí2ÂÄçÔºàÂ∑¶Âè≥ÂêàË®àÔºâ
                const pitchData = streamData.cadence.data.map(c => c * 2);
                renderTimeSeriesChart('cadenceChart', pitchData, '„Éî„ÉÉ„ÉÅ', '#22c55e', 'spm', 'cadence');
            }
        }
        
        function renderTimeSeriesChart(canvasId, data, label, color, unit, chartKey) {
            const ctx = document.getElementById(canvasId).getContext('2d');
            if (charts[chartKey]) charts[chartKey].destroy();
            
            const sportCategory = getSportCategory(currentActivity.sport_type || currentActivity.type);
            const distanceData = streamData?.distance?.data;
            const timeData = streamData?.time?.data || data.map((_, i) => i);
            const altitudeData = streamData?.altitude?.data;
            
            const maxPoints = 500;
            const step = Math.max(1, Math.floor(data.length / maxPoints));
            
            const labels = [];
            const chartData = [];
            const altData = [];
            const validValues = []; // YËª∏ÁØÑÂõ≤Ë®àÁÆóÁî®
            
            // „Éî„ÉÉ„ÉÅ/„Ç±„Ç§„Éá„É≥„Çπ„ÅÆÊúâÂäπÁØÑÂõ≤„ÇíÂÆöÁæ©
            const isRunPitch = chartKey === 'cadence' && sportCategory === 'run';
            const isBikeCadence = chartKey === 'cadence' && sportCategory === 'bike';
            const isPower = chartKey === 'power';
            
            // ÊúâÂäπÂÄ§„ÅÆÁØÑÂõ≤
            let minValid = 0, maxValid = Infinity;
            if (isRunPitch) {
                minValid = 120; // ÊúÄ‰Ωé120spm
                maxValid = 240; // ÊúÄÈ´ò240spm
            } else if (isBikeCadence) {
                minValid = 30;  // ÊúÄ‰Ωé30rpm
                maxValid = 150; // ÊúÄÈ´ò150rpm
            } else if (isPower) {
                minValid = 0;
                maxValid = 2000;
            }
            
            for (let i = 0; i < data.length; i += step) {
                if (distanceData) {
                    if (sportCategory === 'swim') {
                        labels.push(Math.round(distanceData[i]));
                    } else {
                        labels.push((distanceData[i] / 1000).toFixed(1));
                    }
                } else {
                    labels.push(formatDurationShort(timeData[i]));
                }
                
                const value = data[i];
                chartData.push(value);
                
                // Ê®ôÈ´ò„Éá„Éº„Çø
                if (altitudeData && i < altitudeData.length) {
                    altData.push(altitudeData[i]);
                }
                
                // YËª∏ÁØÑÂõ≤Ë®àÁÆóÁî®„Å´ÊúâÂäπÂÄ§„ÇíÂèéÈõÜ
                if (value >= minValid && value <= maxValid) {
                    validValues.push(value);
                }
            }
            
            // YËª∏ÁØÑÂõ≤„ÇíË®àÁÆóÔºà„É©„É≥„Å®„Éê„Ç§„ÇØ„ÅØÂÖ®„Éá„Éº„ÇøË°®Á§∫„ÄÅ„Çπ„Ç§„É†„ÅØ„Éë„Éº„Çª„É≥„Çø„Ç§„É´Ôºâ
            let yMin, yMax;
            if (validValues.length > 0) {
                const sorted = [...validValues].sort((a, b) => a - b);
                const minVal = sorted[0];
                const maxVal = sorted[sorted.length - 1];
                
                if (sportCategory === 'swim') {
                    // „Çπ„Ç§„É†„ÅØ„Éë„Éº„Çª„É≥„Çø„Ç§„É´„Éô„Éº„Çπ„ÅßË°®Á§∫ÁØÑÂõ≤„ÇíÂà∂Èôê
                    const p5 = sorted[Math.floor(sorted.length * 0.05)];
                    const p95 = sorted[Math.floor(sorted.length * 0.95)];
                    const range = p95 - p5;
                    const padding = range * 0.1;
                    yMin = Math.max(minValid, Math.floor(p5 - padding));
                    yMax = Math.min(maxValid, Math.ceil(p95 + padding));
                } else {
                    // „É©„É≥„Å®„Éê„Ç§„ÇØ„ÅØ0„Åã„ÇâÊúÄÂ§ßÂÄ§„Åæ„ÅßÂÖ®„Éá„Éº„ÇøË°®Á§∫
                    const padding = (maxVal - minVal) * 0.05;
                    yMin = Math.max(0, Math.floor(minVal - padding));
                    yMax = Math.ceil(maxVal + padding);
                }
            }
            
            // „Éá„Éº„Çø„Çª„ÉÉ„Éà
            const datasets = [];
            
            // Ê®ôÈ´òËÉåÊôØÔºà„Éê„Ç§„ÇØ„ÄÅ„É©„É≥„ÅÆ„ÅøÔºâ
            if (altData.length > 0 && sportCategory !== 'swim') {
                datasets.push({
                    label: 'Ê®ôÈ´ò',
                    data: altData,
                    borderColor: 'rgba(156, 163, 175, 0.3)',
                    backgroundColor: 'rgba(156, 163, 175, 0.15)',
                    borderWidth: 1,
                    fill: true,
                    tension: 0.2,
                    pointRadius: 0,
                    yAxisID: 'y1'
                });
            }
            
            // „É°„Ç§„É≥„Éá„Éº„Çø
            datasets.push({
                label: label,
                data: chartData,
                borderColor: color,
                borderWidth: 1.5,
                fill: false,
                tension: 0.2,
                pointRadius: 0,
                yAxisID: 'y'
            });
            
            const scales = {
                x: { 
                    title: { display: true, text: distanceData ? (sportCategory === 'swim' ? 'Ë∑ùÈõ¢ (m)' : 'Ë∑ùÈõ¢ (km)') : 'ÊôÇÈñì' },
                    ticks: {
                        maxTicksLimit: sportCategory === 'swim' ? 10 : 12,
                        callback: function(value, index) {
                            const label = this.getLabelForValue(value);
                            if (sportCategory === 'swim' && distanceData) {
                                const dist = parseFloat(label);
                                if (dist % 200 === 0 || index === 0) {
                                    return label;
                                }
                                return '';
                            }
                            return label;
                        }
                    }
                },
                y: { 
                    type: 'linear',
                    position: 'left',
                    title: { display: true, text: unit },
                    min: yMin,
                    max: yMax
                }
            };
            
            // Ê®ôÈ´òÁî®YËª∏
            if (altData.length > 0 && sportCategory !== 'swim') {
                scales.y1 = {
                    type: 'linear',
                    position: 'right',
                    title: { display: true, text: 'Ê®ôÈ´ò (m)' },
                    grid: { drawOnChartArea: false },
                    min: Math.min(...altData) - 10,
                    max: Math.max(...altData) + 10
                };
            }
            
            charts[chartKey] = new Chart(ctx, {
                type: 'line',
                data: { labels: labels, datasets: datasets },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: { legend: { display: altData.length > 0 && sportCategory !== 'swim' } },
                    scales: scales,
                    interaction: {
                        intersect: false,
                        mode: 'index'
                    }
                }
            });
        }
        
        function renderLapTable() {
            if (!currentActivity.laps || currentActivity.laps.length === 0) {
                return;
            }
            
            document.getElementById('lapSection').style.display = 'block';
            const sportCategory = getSportCategory(currentActivity.sport_type || currentActivity.type);
            
            // „Çπ„Ç§„É†„ÅÆÂ†¥Âêà„ÅØ„É©„ÉÉ„Éó„Éá„Éº„Çø„ÅÆË©≥Á¥∞„Çí„Éá„Éê„ÉÉ„Ç∞Âá∫Âäõ
            if (sportCategory === 'swim') {
                console.log('=== „Çπ„Ç§„É†„É©„ÉÉ„Éó„Éá„Éº„Çø (FORM/Strava„Åã„Çâ) ===');
                console.log('„É©„ÉÉ„ÉóÊï∞:', currentActivity.laps.length);
                currentActivity.laps.forEach((lap, i) => {
                    console.log(`Lap ${i+1}:`, {
                        distance: lap.distance,
                        elapsed_time: lap.elapsed_time,
                        moving_time: lap.moving_time,
                        average_speed: lap.average_speed,
                        average_cadence: lap.average_cadence,
                        total_strokes: lap.total_strokes,
                        average_heartrate: lap.average_heartrate,
                        lap_index: lap.lap_index,
                        start_index: lap.start_index,
                        end_index: lap.end_index,
                        // ÂÖ®„Éï„Ç£„Éº„É´„Éâ„ÇíÂá∫Âäõ
                        raw: lap
                    });
                });
                console.log('========================================');
            }
            
            let html = `
                <thead>
                    <tr>
                        <th>Lap</th>
                        <th>Ë∑ùÈõ¢</th>
                        ${sportCategory !== 'run' ? '<th>ÊôÇÈñì</th>' : ''}
                        <th>${sportCategory === 'bike' ? 'ÈÄüÂ∫¶' : '„Éö„Éº„Çπ'}</th>
                        <th>ÂøÉÊãç</th>
                        ${sportCategory === 'bike' ? '<th>„Éë„ÉØ„Éº</th>' : ''}
                        ${sportCategory === 'run' ? '<th>„Éî„ÉÉ„ÉÅ</th><th>„Çπ„Éà„É©„Ç§„Éâ</th>' : ''}
                        ${sportCategory === 'swim' ? '<th>Strokes</th><th>Rate</th><th>DPS</th>' : ''}
                    </tr>
                </thead>
                <tbody>
            `;
            
            currentActivity.laps.forEach((lap, index) => {
                let pace, distance;
                
                if (sportCategory === 'bike') {
                    pace = `${(lap.average_speed * 3.6).toFixed(1)} km/h`;
                    distance = `${(lap.distance / 1000).toFixed(2)} km`;
                } else if (sportCategory === 'swim') {
                    // „Çπ„Ç§„É†: „Éö„Éº„Çπ„ÇíÁßí/100m„ÅßË°®Á§∫
                    let paceSeconds = null;
                    const movingTime = lap.moving_time || 0;
                    
                    if (lap.average_speed && lap.average_speed > 0) {
                        paceSeconds = 100 / lap.average_speed;
                    } else if (movingTime > 0 && lap.distance > 0) {
                        paceSeconds = (movingTime / lap.distance) * 100;
                    }
                    
                    // „É¨„Çπ„ÉàÂà§ÂÆö: 10ÁßíÊú™Ê∫Ä or Áï∞Â∏∏„Å´ÈÄü„ÅÑ„Éö„Éº„Çπ(60Áßí/100mÊú™Ê∫Ä) or Áï∞Â∏∏„Å´ÈÅÖ„ÅÑ„Éö„Éº„Çπ(300Áßí/100mË∂Ö)
                    const isRest = movingTime < 10 || 
                                   (paceSeconds && paceSeconds < 60) || 
                                   (paceSeconds && paceSeconds > 300) ||
                                   !paceSeconds;
                    
                    if (isRest) {
                        pace = '<span style="color: #9ca3af;">REST</span>';
                    } else {
                        pace = formatPaceDebug(paceSeconds);
                    }
                    distance = `${Math.round(lap.distance)}m`;
                } else {
                    pace = formatRunPace(lap.average_speed);
                    distance = `${(lap.distance / 1000).toFixed(2)} km`;
                }
                
                // „Çπ„Ç§„É†Áî®„ÅÆ„Çπ„Éà„É≠„Éº„ÇØÊï∞Ë®àÁÆó
                // total_strokes„Åå„ÅÇ„Çå„Å∞„Åù„Çå„Çí‰Ωø„ÅÑ„ÄÅ„Å™„Åë„Çå„Å∞average_cadence„Å®ÊôÇÈñì„Åã„ÇâË®àÁÆó
                let strokes = lap.total_strokes;
                if (!strokes && lap.average_cadence && lap.moving_time) {
                    // Strokes = Rate(spm) √ó Time(Áßí) / 60
                    strokes = Math.round(lap.average_cadence * lap.moving_time / 60);
                }
                
                // „Çπ„Ç§„É†Áî®„ÅÆDPSË®àÁÆóÔºàDistance Per StrokeÔºâ
                let dps = '-';
                if (sportCategory === 'swim' && strokes && strokes > 0 && lap.distance > 0) {
                    dps = (lap.distance / strokes).toFixed(2) + 'm';
                }
                
                // „Çπ„Ç§„É†Áî®„ÅÆ„Çπ„Éà„É≠„Éº„ÇØ„É¨„Éº„ÉàË°®Á§∫
                let strokeRate = '-';
                if (sportCategory === 'swim' && lap.average_cadence) {
                    strokeRate = Math.round(lap.average_cadence) + ' spm';
                }
                
                // „É©„É≥Áî®„ÅÆ„Éî„ÉÉ„ÉÅ„Å®„Çπ„Éà„É©„Ç§„ÉâÈï∑Ë®àÁÆó
                let runPitch = '-';
                let runStride = '-';
                if (sportCategory === 'run') {
                    // „Éî„ÉÉ„ÉÅÔºà„Ç±„Ç§„Éá„É≥„ÇπÔºâ- Strava„ÅØÁâáË∂≥„ÅÆ„Çπ„ÉÜ„ÉÉ„ÉóÊï∞„ÇíËøî„Åô„ÅÆ„Åß2ÂÄç
                    if (lap.average_cadence) {
                        runPitch = Math.round(lap.average_cadence * 2) + ' spm';
                    }
                    // „Çπ„Éà„É©„Ç§„ÉâÈï∑ = Ë∑ùÈõ¢ / („Éî„ÉÉ„ÉÅ * ÊôÇÈñì(ÂàÜ))
                    // „Éî„ÉÉ„ÉÅ„ÅØsteps per minuteÔºà‰∏°Ë∂≥ÂêàË®àÔºâ„ÄÅÊôÇÈñì„ÅØÁßí„Å™„ÅÆ„ÅßÂàÜ„Å´Â§âÊèõ
                    if (lap.average_cadence && lap.moving_time && lap.distance) {
                        const timeMinutes = lap.moving_time / 60;
                        const totalSteps = lap.average_cadence * 2 * timeMinutes; // ‰∏°Ë∂≥ÂêàË®à„Çπ„ÉÜ„ÉÉ„ÉóÊï∞
                        const stride = lap.distance / totalSteps;
                        runStride = stride.toFixed(2) + 'm';
                    }
                }
                
                html += `
                    <tr>
                        <td>${index + 1}</td>
                        <td>${distance}</td>
                        ${sportCategory !== 'run' ? `<td>${formatDuration(lap.moving_time || lap.elapsed_time)}</td>` : ''}
                        <td>${pace}</td>
                        <td>${lap.average_heartrate ? Math.round(lap.average_heartrate) : '-'}</td>
                        ${sportCategory === 'bike' ? `<td>${lap.average_watts ? Math.round(lap.average_watts) : '-'} W</td>` : ''}
                        ${sportCategory === 'run' ? `<td>${runPitch}</td><td>${runStride}</td>` : ''}
                        ${sportCategory === 'swim' ? `<td>${strokes || '-'}</td><td>${strokeRate}</td><td>${dps}</td>` : ''}
                    </tr>
                `;
            });
            
            html += '</tbody>';
            document.getElementById('lapTable').innerHTML = html;
        }
        
        // ===== „Çπ„Éà„É™„Éº„É†„Éá„Éº„ÇøÂàÜÊûê =====
        function analyzeStreamData() {
            if (!streamData) return null;
            
            const analysis = {};
            const sportCategory = getSportCategory(currentActivity.sport_type || currentActivity.type);
            
            // „Éö„Éº„ÇπÂàÜÊûê
            if (streamData.velocity_smooth && streamData.velocity_smooth.data && streamData.distance?.data) {
                const velData = streamData.velocity_smooth.data;
                const distData = streamData.distance.data;
                const totalDist = distData[distData.length - 1];
                const halfDist = totalDist / 2;
                
                // ÂâçÂçä„ÉªÂæåÂçä„ÅÆ„Éö„Éº„Çπ„ÇíË®àÁÆó
                let firstHalfVels = [];
                let secondHalfVels = [];
                
                for (let i = 0; i < velData.length; i++) {
                    if (velData[i] > 0.5) { // ÂÅúÊ≠¢„ÇíÈô§Â§ñ
                        if (distData[i] <= halfDist) {
                            firstHalfVels.push(velData[i]);
                        } else {
                            secondHalfVels.push(velData[i]);
                        }
                    }
                }
                
                const avgFirstHalf = firstHalfVels.length > 0 ? firstHalfVels.reduce((a, b) => a + b, 0) / firstHalfVels.length : 0;
                const avgSecondHalf = secondHalfVels.length > 0 ? secondHalfVels.reduce((a, b) => a + b, 0) / secondHalfVels.length : 0;
                
                // „Éö„Éº„ÇπÂ§âÂãï‰øÇÊï∞
                const validVels = velData.filter(v => v > 0.5);
                const meanVel = validVels.reduce((a, b) => a + b, 0) / validVels.length;
                const variance = validVels.reduce((sum, v) => sum + Math.pow(v - meanVel, 2), 0) / validVels.length;
                const stdDev = Math.sqrt(variance);
                const cv = (stdDev / meanVel) * 100;
                
                // „Çπ„Éó„É™„ÉÉ„Éà„Çø„Ç§„Éó
                const splitDiff = ((avgSecondHalf / avgFirstHalf) - 1) * 100;
                let splitType = 'ÂùáÁ≠â';
                if (splitDiff > 3) splitType = '„Éç„Ç¨„ÉÜ„Ç£„ÉñÔºàÂæåÂçä„Éö„Éº„Çπ„Ç¢„ÉÉ„ÉóÔºâ';
                else if (splitDiff < -3) splitType = '„Éù„Ç∏„ÉÜ„Ç£„ÉñÔºàÂæåÂçä„Éö„Éº„Çπ„ÉÄ„Ç¶„É≥Ôºâ';
                
                analysis.paceAnalysis = {
                    firstHalfPace: formatPaceFromSpeed(avgFirstHalf, sportCategory),
                    secondHalfPace: formatPaceFromSpeed(avgSecondHalf, sportCategory),
                    splitType: splitType,
                    splitDiff: `${splitDiff > 0 ? '+' : ''}${splitDiff.toFixed(1)}%`,
                    variability: cv.toFixed(1)
                };
                
                // ÊúÄÈÄü„ÉªÊúÄÈÅÖÂå∫ÈñìÔºà1kmÂçò‰Ωç„ÅßÂàÜÊûêÔºâ
                if (sportCategory !== 'swim') {
                    const kmSections = [];
                    let currentKm = 1000;
                    let sectionVels = [];
                    
                    for (let i = 0; i < distData.length; i++) {
                        if (distData[i] <= currentKm) {
                            if (velData[i] > 0.5) sectionVels.push(velData[i]);
                        } else {
                            if (sectionVels.length > 0) {
                                const avgVel = sectionVels.reduce((a, b) => a + b, 0) / sectionVels.length;
                                kmSections.push({ km: Math.floor(currentKm / 1000), pace: avgVel });
                            }
                            currentKm += 1000;
                            sectionVels = [velData[i]];
                        }
                    }
                    
                    if (kmSections.length > 0) {
                        const fastest = kmSections.reduce((max, s) => s.pace > max.pace ? s : max);
                        const slowest = kmSections.reduce((min, s) => s.pace < min.pace ? s : min);
                        analysis.paceAnalysis.fastestSection = `${fastest.km}kmÁõÆ (${formatPaceFromSpeed(fastest.pace, sportCategory)})`;
                        analysis.paceAnalysis.slowestSection = `${slowest.km}kmÁõÆ (${formatPaceFromSpeed(slowest.pace, sportCategory)})`;
                    }
                }
            }
            
            // ÂøÉÊãçÂàÜÊûê
            if (streamData.heartrate && streamData.heartrate.data) {
                const hrData = streamData.heartrate.data;
                const validHr = hrData.filter(h => h > 0);
                
                if (validHr.length > 0) {
                    const thresholds = getUserThresholds();
                    const maxHr = thresholds.maxHr || 190;
                    
                    // ÂâçÂçä„ÉªÂæåÂçä„ÅÆÂøÉÊãçÊØîËºÉÔºà„Éâ„É™„Éï„ÉàÔºâ
                    const midPoint = Math.floor(validHr.length / 2);
                    const firstHalfHr = validHr.slice(0, midPoint);
                    const secondHalfHr = validHr.slice(midPoint);
                    
                    const avgFirstHr = firstHalfHr.reduce((a, b) => a + b, 0) / firstHalfHr.length;
                    const avgSecondHr = secondHalfHr.reduce((a, b) => a + b, 0) / secondHalfHr.length;
                    const drift = ((avgSecondHr / avgFirstHr) - 1) * 100;
                    
                    // ZoneÂàÜÂ∏É
                    const zones = { z1: 0, z2: 0, z3: 0, z4: 0, z5: 0 };
                    validHr.forEach(hr => {
                        const percent = (hr / maxHr) * 100;
                        if (percent < 60) zones.z1++;
                        else if (percent < 70) zones.z2++;
                        else if (percent < 80) zones.z3++;
                        else if (percent < 90) zones.z4++;
                        else zones.z5++;
                    });
                    
                    const total = validHr.length;
                    Object.keys(zones).forEach(z => {
                        zones[z] = Math.round((zones[z] / total) * 100);
                    });
                    
                    // ÂøÉÊãçÂäπÁéáÔºà„Éö„Éº„Çπ„Åå„ÅÇ„ÇãÂ†¥ÂêàÔºâ
                    let efficiency = null;
                    if (currentActivity.average_speed && currentActivity.average_heartrate) {
                        // ÂøÉÊãç1bpm„ÅÇ„Åü„Çä„ÅÆ„Éö„Éº„ÇπÔºàÊï∞ÂÄ§„ÅåÂ∞è„Åï„ÅÑ„Åª„Å©ÂäπÁéáÁöÑÔºâ
                        const pacePerKm = 1000 / currentActivity.average_speed / 60;
                        efficiency = (currentActivity.average_heartrate / pacePerKm).toFixed(1);
                    }
                    
                    analysis.heartRateAnalysis = {
                        drift: drift.toFixed(1),
                        zones: zones,
                        efficiency: efficiency
                    };
                }
            }
            
            // Ê®ôÈ´òÂàÜÊûê
            if (streamData.altitude && streamData.altitude.data && streamData.velocity_smooth?.data) {
                const altData = streamData.altitude.data;
                const velData = streamData.velocity_smooth.data;
                const gradeData = streamData.grade_smooth?.data;
                
                if (gradeData) {
                    // Áôª„Çä„ÉªÂπ≥Âú∞„Éª‰∏ã„Çä„Åß„ÅÆ„Éö„Éº„ÇπÊØîËºÉ
                    const climbVels = [];
                    const flatVels = [];
                    const descentVels = [];
                    
                    for (let i = 0; i < gradeData.length; i++) {
                        if (velData[i] > 0.5) {
                            if (gradeData[i] > 2) climbVels.push(velData[i]);
                            else if (gradeData[i] < -2) descentVels.push(velData[i]);
                            else flatVels.push(velData[i]);
                        }
                    }
                    
                    if (climbVels.length > 0 && flatVels.length > 0) {
                        const avgClimb = climbVels.reduce((a, b) => a + b, 0) / climbVels.length;
                        const avgFlat = flatVels.reduce((a, b) => a + b, 0) / flatVels.length;
                        const climbLoss = ((avgFlat / avgClimb) - 1) * 100;
                        
                        analysis.elevationAnalysis = {
                            climbingPaceLoss: climbLoss.toFixed(0)
                        };
                    }
                }
            }
            
            return Object.keys(analysis).length > 0 ? analysis : null;
        }
        
        function formatPaceFromSpeed(speed, sportCategory) {
            if (!speed || speed <= 0) return '-';
            if (sportCategory === 'bike') {
                return `${(speed * 3.6).toFixed(1)} km/h`;
            } else if (sportCategory === 'swim') {
                const pace = 100 / speed;
                const min = Math.floor(pace / 60);
                const sec = Math.round(pace % 60);
                return `${min}:${String(sec).padStart(2, '0')}/100m`;
            } else {
                const pace = 1000 / speed / 60;
                const min = Math.floor(pace);
                const sec = Math.round((pace - min) * 60);
                return `${min}:${String(sec).padStart(2, '0')}/km`;
            }
        }
        
        // ===== È°û‰ºº„Ç¢„ÇØ„ÉÜ„Ç£„Éì„ÉÜ„Ç£Ê§úÁ¥¢ =====
        function findSimilarActivities() {
            const cachedActivities = localStorage.getItem('strava_activities');
            if (!cachedActivities) return [];
            
            const activities = JSON.parse(cachedActivities);
            const currentSport = currentActivity.sport_type || currentActivity.type;
            const currentDist = currentActivity.distance || 0;
            const currentId = currentActivity.id;
            
            // Âêå„ÅòÁ®ÆÁõÆ„ÄÅË∑ùÈõ¢„Åå¬±30%‰ª•ÂÜÖ„ÅÆ„Ç¢„ÇØ„ÉÜ„Ç£„Éì„ÉÜ„Ç£„ÇíÊ§úÁ¥¢
            const similar = activities.filter(a => {
                if (a.id === currentId) return false;
                const sport = a.sport_type || a.type;
                if (sport !== currentSport) return false;
                
                const dist = a.distance || 0;
                const ratio = dist / currentDist;
                return ratio >= 0.7 && ratio <= 1.3;
            });
            
            // Êó•‰ªò„ÅßÈôçÈ†Ü„ÇΩ„Éº„Éà„ÄÅÊúÄÊñ∞3‰ª∂„ÇíËøî„Åô
            similar.sort((a, b) => new Date(b.start_date) - new Date(a.start_date));
            return similar.slice(0, 5);
        }
        
        // ===== AI„Ç≥„Éº„ÉÅÔºà„Çª„ÉÉ„Ç∑„Éß„É≥„Çø„Ç§„ÉóÈÅ∏ÊäûÁâàÔºâ =====
        
        // „Çª„ÉÉ„Ç∑„Éß„É≥„Çø„Ç§„ÉóÈÅ∏ÊäûUI„ÇíÂàùÊúüÂåñ
        function initSessionTypeSelector() {
            const sportType = currentActivity.sport_type || currentActivity.type;
            const sportCategory = getSportCategory(sportType);
            
            // Á®ÆÁõÆ„Å´Âøú„Åò„ÅüÈÅ∏ÊäûËÇ¢„ÇíÂèñÂæó
            let options = [];
            if (sportCategory === 'swim') {
                options = SESSION_TYPES.swim;
            } else if (sportCategory === 'bike') {
                options = SESSION_TYPES.bike;
            } else if (sportCategory === 'run') {
                options = SESSION_TYPES.run;
            }
            // ÂÖ±ÈÄö„Ç™„Éó„Ç∑„Éß„É≥„ÇíËøΩÂä†
            options = options.concat(SESSION_TYPES.common);
            
            // „Ç∞„É™„ÉÉ„Éâ„Å´„Éú„Çø„É≥„ÇíÁîüÊàê
            const grid = document.getElementById('sessionTypeGrid');
            if (!grid) return;
            
            grid.innerHTML = '';
            
            options.forEach(function(opt) {
                const btn = document.createElement('button');
                btn.className = 'session-type-btn';
                btn.dataset.type = opt.id;
                btn.innerHTML = `
                    <span class="session-type-btn-label">${opt.label}</span>
                    <span class="session-type-btn-desc">${opt.description}</span>
                `;
                btn.addEventListener('click', function() {
                    selectSessionType(opt.id, opt.label);
                });
                grid.appendChild(btn);
            });
            
            // „Éú„Çø„É≥„Ç§„Éô„É≥„ÉàË®≠ÂÆö
            const generateBtn = document.getElementById('generateCommentBtn');
            if (generateBtn) {
                generateBtn.addEventListener('click', generateAIComment);
            }
        }

        // „Çª„ÉÉ„Ç∑„Éß„É≥„Çø„Ç§„Éó„ÇíÈÅ∏Êäû
        function selectSessionType(typeId, typeLabel) {
            // Ââç„ÅÆÈÅ∏Êäû„ÇíËß£Èô§
            document.querySelectorAll('.session-type-btn').forEach(function(btn) {
                btn.classList.remove('selected');
            });
            
            // Êñ∞„Åó„ÅÑÈÅ∏Êäû„Çí„Éû„Éº„ÇØ
            const selectedBtn = document.querySelector(`.session-type-btn[data-type="${typeId}"]`);
            if (selectedBtn) {
                selectedBtn.classList.add('selected');
            }
            
            selectedSessionType = typeId;
            
            // „Äå„Åù„ÅÆ‰ªñ„Äç„ÅÆÂ†¥Âêà„ÅØÂÖ•ÂäõÊ¨Ñ„ÇíË°®Á§∫
            const otherContainer = document.getElementById('otherInputContainer');
            if (typeId === 'other') {
                otherContainer.classList.add('visible');
            } else {
                otherContainer.classList.remove('visible');
            }
            
            // „Éú„Çø„É≥„ÇíÊúâÂäπÂåñ
            document.getElementById('generateCommentBtn').disabled = false;
        }

        // „Ç≥„É°„É≥„ÉàÁîüÊàê
        async function generateAIComment() {
            if (!selectedSessionType) {
                alert('„Çª„ÉÉ„Ç∑„Éß„É≥„Çø„Ç§„Éó„ÇíÈÅ∏Êäû„Åó„Å¶„Åè„Å†„Åï„ÅÑ');
                return;
            }
            
            const supplement = document.getElementById('sessionSupplement').value.trim();
            const otherInput = document.getElementById('otherInput').value.trim();
            
            // „Äå„Åù„ÅÆ‰ªñ„Äç„ÅÆÂ†¥Âêà„ÅØÂÖ•ÂäõÂÜÖÂÆπ„ÇíË£úË∂≥„Å´ËøΩÂä†
            let finalSupplement = supplement;
            if (selectedSessionType === 'other' && otherInput) {
                finalSupplement = otherInput + (supplement ? '„ÄÇ' + supplement : '');
            }
            
            // A„É¨„Éº„ÇπÁõÆÊ®ô„ÇíÂèñÂæó
            let raceGoal = null;
            try {
                // selected_races„Åã„ÇâA„É¨„Éº„Çπ„ÇíÂèñÂæó
                const savedRaces = localStorage.getItem('selected_races');
                if (savedRaces) {
                    const raceData = JSON.parse(savedRaces);
                    const aRaceIds = raceData.a || [];
                    const details = raceData.details || {};
                    const targetTimes = raceData.targetTimes || {};
                    
                    // A„É¨„Éº„Çπ„Åå„ÅÇ„Çå„Å∞ÊúÄÂàù„ÅÆ„ÇÇ„ÅÆ„Çí‰ΩøÁî®
                    if (aRaceIds.length > 0) {
                        const aRaceId = aRaceIds[0];
                        const aRaceDetail = details[aRaceId];
                        
                        if (aRaceDetail) {
                            raceGoal = {
                                raceName: aRaceDetail.name,
                                raceDate: aRaceDetail.date,
                                raceDistance: aRaceDetail.distance || aRaceDetail.raceType,
                                goalTime: targetTimes[aRaceId] || null
                            };
                            
                            // race_goals„Åã„ÇâË©≥Á¥∞„Å™ÁõÆÊ®ô„Çø„Ç§„É†„ÇíÂèñÂæó
                            const savedGoals = localStorage.getItem('race_goals');
                            if (savedGoals && !raceGoal.goalTime) {
                                const goals = JSON.parse(savedGoals);
                                if (goals[aRaceId] && goals[aRaceId].goalTime) {
                                    raceGoal.goalTime = goals[aRaceId].goalTime;
                                }
                            }
                        }
                    }
                }
                
                // selected_race„Åã„Çâ„ÇÇË©¶„Åø„ÇãÔºàÊóßÂΩ¢Âºè‰∫íÊèõÔºâ
                if (!raceGoal) {
                    const savedRace = localStorage.getItem('selected_race');
                    if (savedRace) {
                        const race = JSON.parse(savedRace);
                        raceGoal = {
                            raceName: race.name || race.raceName,
                            raceDate: race.date || race.raceDate,
                            raceDistance: race.distance || race.raceDistance || race.raceType
                        };
                        
                        const savedGoals = localStorage.getItem('race_goals');
                        if (savedGoals) {
                            const goals = JSON.parse(savedGoals);
                            if (goals.goalTime) {
                                raceGoal.goalTime = goals.goalTime;
                            }
                        }
                    }
                }
            } catch (e) {
                console.log('Race goal not found:', e);
            }
            
            // „Ç∞„É≠„Éº„Éê„É´Â§âÊï∞„Å´‰øùÂ≠òÔºàËøΩÂä†Ë≥™ÂïèÊôÇ„Å´‰ΩøÁî®Ôºâ
            currentRaceGoal = raceGoal;
            
            // UIÊõ¥Êñ∞
            document.getElementById('sessionTypeSelector').style.display = 'none';
            document.getElementById('aiCommentLoading').style.display = 'flex';
            document.getElementById('aiCommentResult').style.display = 'none';
            
            try {
                const streamAnalysis = analyzeStreamData();
                const similarActivities = findSimilarActivities();
                
                const response = await fetch('/.netlify/functions/ai-coach-comment', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        activity: currentActivity,
                        trainingStatus: trainingStatus,
                        streamAnalysis: streamAnalysis,
                        similarActivities: similarActivities,
                        sessionType: selectedSessionType,
                        sessionSupplement: finalSupplement,
                        raceGoal: raceGoal,
                        conversationHistory: []
                    })
                });
                
                if (!response.ok) {
                    throw new Error('„Ç≥„É°„É≥„ÉàÁîüÊàê„Å´Â§±Êïó„Åó„Åæ„Åó„Åü');
                }
                
                const data = await response.json();
                
                // ÁµêÊûú„ÇíË°®Á§∫
                document.getElementById('aiCommentLoading').style.display = 'none';
                document.getElementById('aiCommentResult').style.display = 'block';
                document.getElementById('aiCommentText').innerHTML = formatAIComment(data.comment);
                document.getElementById('commentSessionType').textContent = getSessionTypeLabel(selectedSessionType);
                
                // ‰ºöË©±Â±•Ê≠¥„Çí„É™„Çª„ÉÉ„Éà„Åó„Å¶ÊúÄÂàù„ÅÆ„Ç≥„É°„É≥„Éà„ÇíËøΩÂä†
                conversationHistory = [
                    { role: 'assistant', content: data.comment }
                ];
                
                // Êó¢Â≠ò„ÅÆ‰ºöË©±Â±•Ê≠¥„Åå„ÅÇ„Çå„Å∞Ë™≠„ÅøËæº„Åø
                loadChatHistory();
                
                // Â±•Ê≠¥„Çí‰øùÂ≠ò
                saveChatHistory();
                
            } catch (error) {
                console.error('AI comment error:', error);
                document.getElementById('aiCommentLoading').style.display = 'none';
                document.getElementById('sessionTypeSelector').style.display = 'block';
                alert('„Ç≥„É°„É≥„ÉàÁîüÊàê„Å´Â§±Êïó„Åó„Åæ„Åó„Åü: ' + error.message);
            }
        }

        // „Çª„ÉÉ„Ç∑„Éß„É≥„Çø„Ç§„Éó„ÇíÂ§âÊõ¥
        function changeSessionType() {
            document.getElementById('aiCommentResult').style.display = 'none';
            document.getElementById('sessionTypeSelector').style.display = 'block';
            document.getElementById('chatHistory').innerHTML = '';
            document.getElementById('chatHint').style.display = 'block';
            
            // Â±•Ê≠¥„Çí„ÇØ„É™„Ç¢
            conversationHistory = [];
            
            // localStorage„Åã„Çâ„ÇÇÂâäÈô§
            if (currentActivity) {
                localStorage.removeItem(`chat_history_${currentActivity.id}`);
            }
        }

        // „Çª„ÉÉ„Ç∑„Éß„É≥„Çø„Ç§„Éó„ÅÆ„É©„Éô„É´„ÇíÂèñÂæó
        function getSessionTypeLabel(typeId) {
            const allTypes = [
                ...SESSION_TYPES.swim,
                ...SESSION_TYPES.bike,
                ...SESSION_TYPES.run,
                ...SESSION_TYPES.common
            ];
            const found = allTypes.find(t => t.id === typeId);
            return found ? found.label : typeId;
        }

        // AI„Ç≥„É°„É≥„Éà„ÅÆMarkdown„ÇíÊï¥ÂΩ¢
        function formatAIComment(text) {
            return text
                .replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>')
                .replace(/\n/g, '<br>');
        }
        
        // ========== „ÉÅ„É£„ÉÉ„ÉàÂ±•Ê≠¥ÁÆ°ÁêÜ ==========
        
        // Â±•Ê≠¥„ÇílocalStorage„Å´‰øùÂ≠ò
        function saveChatHistory() {
            if (!currentActivity) return;
            const activityId = currentActivity.id;
            const historyKey = `chat_history_${activityId}`;
            
            const historyData = {
                conversationHistory: conversationHistory,
                sessionType: selectedSessionType,
                timestamp: Date.now()
            };
            
            localStorage.setItem(historyKey, JSON.stringify(historyData));
        }
        
        // Â±•Ê≠¥„ÇílocalStorage„Åã„ÇâË™≠„ÅøËæº„Åø
        function loadChatHistory() {
            if (!currentActivity) return;
            const activityId = currentActivity.id;
            const historyKey = `chat_history_${activityId}`;
            
            const saved = localStorage.getItem(historyKey);
            if (!saved) return;
            
            try {
                const historyData = JSON.parse(saved);
                
                // 7Êó•‰ª•‰∏äÂâç„ÅÆÂ±•Ê≠¥„ÅØÂâäÈô§
                if (Date.now() - historyData.timestamp > 7 * 24 * 60 * 60 * 1000) {
                    localStorage.removeItem(historyKey);
                    return;
                }
                
                // ÊúÄÂàù„ÅÆ„Ç≥„É°„É≥„Éà‰ª•Â§ñ„ÅÆ‰ºöË©±„ÇíÂæ©ÂÖÉ
                const savedHistory = historyData.conversationHistory || [];
                if (savedHistory.length > 1) {
                    // ÊúÄÂàù„ÅÆ„Ç≥„É°„É≥„ÉàÔºàAI„Ç≥„Éº„ÉÅ„ÅÆÂàùÊúü„Ç≥„É°„É≥„ÉàÔºâ„ÅØ„Çπ„Ç≠„ÉÉ„Éó„Åó„ÄÅ„Åù„Çå‰ª•Èôç„ÇíÂæ©ÂÖÉ
                    conversationHistory = savedHistory;
                    
                    const historyEl = document.getElementById('chatHistory');
                    historyEl.innerHTML = '';
                    
                    // 2Áï™ÁõÆ‰ª•Èôç„ÅÆ„É°„ÉÉ„Çª„Éº„Ç∏Ôºà„É¶„Éº„Ç∂„Éº„ÅÆË≥™Âïè„Å®ÂõûÁ≠îÔºâ„ÇíË°®Á§∫
                    for (let i = 1; i < savedHistory.length; i++) {
                        const msg = savedHistory[i];
                        const type = msg.role === 'user' ? 'user' : 'coach';
                        addChatMessageToUI(type, msg.content, false);
                    }
                    
                    // „Éí„É≥„Éà„ÇíÈùûË°®Á§∫
                    document.getElementById('chatHint').style.display = 'none';
                }
            } catch (e) {
                console.error('Â±•Ê≠¥„ÅÆË™≠„ÅøËæº„Åø„Å´Â§±Êïó:', e);
            }
        }
        
        // „Çø„Ç§„Éî„É≥„Ç∞„Ç®„Éï„Çß„ÇØ„Éà‰ªò„Åç„Åß„ÉÜ„Ç≠„Çπ„Éà„ÇíË°®Á§∫
        async function typeText(element, text, speed = 15) {
            element.innerHTML = '';
            element.classList.add('streaming-text');
            
            let displayText = '';
            const chars = text.split('');
            
            for (let i = 0; i < chars.length; i++) {
                displayText += chars[i];
                element.innerHTML = formatAIComment(displayText);
                
                // Ë¶™Ë¶ÅÁ¥†„Çí„Çπ„ÇØ„É≠„Éº„É´
                const historyEl = document.getElementById('chatHistory');
                historyEl.scrollTop = historyEl.scrollHeight;
                
                // Âè•Ë™≠ÁÇπ„ÅßÂ∞ë„ÅóÈï∑„ÇÅ„Å´ÂæÖÊ©ü
                const char = chars[i];
                let delay = speed;
                if (char === '„ÄÇ' || char === 'ÔºÅ' || char === 'Ôºü') {
                    delay = speed * 8;
                } else if (char === '„ÄÅ' || char === '\n') {
                    delay = speed * 4;
                }
                
                await new Promise(resolve => setTimeout(resolve, delay));
            }
            
            element.classList.remove('streaming-text');
        }
        
        // „Çπ„Éà„É™„Éº„Éü„É≥„Ç∞È¢®„ÅÆË≥™ÂïèÈñ¢Êï∞
        async function askQuestion() {
            const input = document.getElementById('questionInput');
            const btn = document.getElementById('askBtn');
            const btnText = document.getElementById('askBtnText');
            const question = input.value.trim();
            
            if (!question) return;
            
            // „Éí„É≥„Éà„ÇíÈùûË°®Á§∫
            document.getElementById('chatHint').style.display = 'none';
            
            // „É¶„Éº„Ç∂„Éº„ÅÆË≥™Âïè„ÇíUI„Å´ËøΩÂä†
            addChatMessageToUI('user', question, true);
            input.value = '';
            btn.disabled = true;
            btnText.textContent = '...';
            
            // ‰ºöË©±Â±•Ê≠¥„Å´ËøΩÂä†
            conversationHistory.push({ role: 'user', content: question });
            
            // AI„ÅÆÂõûÁ≠îÁî®„É°„ÉÉ„Çª„Éº„Ç∏„Éú„ÉÉ„ÇØ„Çπ„Çí‰ΩúÊàê
            const historyEl = document.getElementById('chatHistory');
            const messageId = 'coach-msg-' + Date.now();
            const messageHtml = `
                <div class="chat-message coach" id="${messageId}">
                    <div class="chat-message-label">ü§ñ AI„Ç≥„Éº„ÉÅ</div>
                    <div class="chat-message-content" id="${messageId}-content">
                        <div class="typing-indicator">
                            <span></span><span></span><span></span>
                        </div>
                    </div>
                </div>
            `;
            historyEl.insertAdjacentHTML('beforeend', messageHtml);
            historyEl.scrollTop = historyEl.scrollHeight;
            
            try {
                const streamAnalysis = analyzeStreamData();
                
                // ÂæìÊù•„ÅÆAPI„ÇíÂëº„Å≥Âá∫„Åó
                const response = await fetch('/.netlify/functions/ai-coach-comment', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        activity: currentActivity,
                        trainingStatus: trainingStatus,
                        streamAnalysis: streamAnalysis,
                        sessionType: selectedSessionType,
                        userQuestion: question,
                        raceGoal: currentRaceGoal,  // A„É¨„Éº„ÇπÁõÆÊ®ô„ÇíËøΩÂä†
                        conversationHistory: conversationHistory.slice(-10) // ÊúÄÊñ∞10‰ª∂„ÅÆ„Åø
                    })
                });
                
                if (!response.ok) {
                    throw new Error('ÂõûÁ≠î„ÅÆÁîüÊàê„Å´Â§±Êïó„Åó„Åæ„Åó„Åü');
                }
                
                const data = await response.json();
                const contentEl = document.getElementById(`${messageId}-content`);
                
                // „Çø„Ç§„Éî„É≥„Ç∞„Ç®„Éï„Çß„ÇØ„Éà„ÅßË°®Á§∫
                await typeText(contentEl, data.comment);
                
                // ‰ºöË©±Â±•Ê≠¥„Å´ËøΩÂä†
                conversationHistory.push({ role: 'assistant', content: data.comment });
                
                // localStorage„Å´‰øùÂ≠ò
                saveChatHistory();
                
            } catch (error) {
                console.error('Question error:', error);
                const contentEl = document.getElementById(`${messageId}-content`);
                contentEl.innerHTML = 'Áî≥„ÅóË®≥„ÅÇ„Çä„Åæ„Åõ„Çì„ÄÅÂõûÁ≠î„ÅÆÁîüÊàê„Å´Â§±Êïó„Åó„Åæ„Åó„Åü„ÄÇ„Åó„Å∞„Çâ„Åè„Åó„Å¶„Åã„Çâ„ÅäË©¶„Åó„Åè„Å†„Åï„ÅÑ„ÄÇ';
            }
            
            btn.disabled = false;
            btnText.textContent = 'ÈÄÅ‰ø°';
            input.focus();
        }
        
        // „ÉÅ„É£„ÉÉ„Éà„É°„ÉÉ„Çª„Éº„Ç∏„ÇíUI„Å´ËøΩÂä†
        function addChatMessageToUI(type, content, animate = true) {
            const historyEl = document.getElementById('chatHistory');
            const label = type === 'user' ? 'üë§ „ÅÇ„Å™„Åü' : 'ü§ñ AI„Ç≥„Éº„ÉÅ';
            const formattedContent = type === 'coach' ? formatAIComment(content) : escapeHtml(content);
            
            const messageHtml = `
                <div class="chat-message ${type}" ${animate ? '' : 'style="animation: none;"'}>
                    <div class="chat-message-label">${label}</div>
                    <div class="chat-message-content">${formattedContent}</div>
                </div>
            `;
            
            historyEl.insertAdjacentHTML('beforeend', messageHtml);
            if (animate) {
                historyEl.scrollTop = historyEl.scrollHeight;
            }
        }
        
        // HTML„Ç®„Çπ„Ç±„Éº„Éó
        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }
        
        // ÊóßÈñ¢Êï∞Ôºà‰∫íÊèõÊÄß„ÅÆ„Åü„ÇÅÊÆã„ÅôÔºâ
        function addChatMessage(type, content) {
            addChatMessageToUI(type, content, true);
        }
        
        // Enter„Ç≠„Éº„ÅßÈÄÅ‰ø°
        document.getElementById('questionInput')?.addEventListener('keypress', (e) => {
            if (e.key === 'Enter' && !e.shiftKey) {
                e.preventDefault();
                askQuestion();
            }
        });
        
        // ===== „É¶„Éº„ÉÜ„Ç£„É™„ÉÜ„Ç£ =====
        function getUserThresholds() {
            const saved = localStorage.getItem('user_thresholds');
            if (saved) {
                try {
                    return JSON.parse(saved);
                } catch (e) {}
            }
            return { ftp: 200, rFtpPacePerKm: 300, sFtpPacePer100m: 100, maxHr: 190, thresholdHr: 170 };
        }
        
        function getSportCategory(sportType) {
            const swim = ['Swim'];
            const bike = ['Ride', 'VirtualRide', 'EBikeRide'];
            const run = ['Run', 'TrailRun', 'VirtualRun'];
            
            if (swim.includes(sportType)) return 'swim';
            if (bike.includes(sportType)) return 'bike';
            if (run.includes(sportType)) return 'run';
            return 'other';
        }
        
        function getSportLabel(sportType) {
            const labels = {
                'Run': '„É©„É≥', 'TrailRun': '„Éà„É¨„Ç§„É´', 'VirtualRun': '„Éê„Éº„ÉÅ„É£„É´„É©„É≥',
                'Ride': '„Éê„Ç§„ÇØ', 'VirtualRide': '„Éê„Éº„ÉÅ„É£„É´„É©„Ç§„Éâ', 'EBikeRide': 'E-Bike',
                'Swim': '„Çπ„Ç§„É†', 'WeightTraining': '„Ç¶„Çß„Ç§„Éà', 'Yoga': '„É®„Ç¨'
            };
            return labels[sportType] || sportType;
        }
        
        function getActivityIcon(sportType) {
            const icons = {
                'Run': 'üèÉ‚Äç‚ôÇÔ∏è', 'TrailRun': 'üèîÔ∏è', 'VirtualRun': 'üèÉ‚Äç‚ôÇÔ∏è',
                'Ride': 'üö¥‚Äç‚ôÇÔ∏è', 'VirtualRide': 'üö¥‚Äç‚ôÇÔ∏è', 'EBikeRide': 'üö¥‚Äç‚ôÇÔ∏è',
                'Swim': 'üèä‚Äç‚ôÇÔ∏è', 'WeightTraining': 'üèãÔ∏è‚Äç‚ôÇÔ∏è', 'Yoga': 'üßò‚Äç‚ôÇÔ∏è'
            };
            return icons[sportType] || 'üèÉ‚Äç‚ôÇÔ∏è';
        }
        
        function formatDuration(seconds) {
            if (!seconds) return '0:00';
            const h = Math.floor(seconds / 3600);
            const m = Math.floor((seconds % 3600) / 60);
            const s = Math.floor(seconds % 60);
            
            if (h > 0) {
                return `${h}:${String(m).padStart(2, '0')}:${String(s).padStart(2, '0')}`;
            }
            return `${m}:${String(s).padStart(2, '0')}`;
        }
        
        function formatDurationShort(seconds) {
            if (!seconds) return '0:00';
            const m = Math.floor(seconds / 60);
            const s = Math.floor(seconds % 60);
            return `${m}:${String(s).padStart(2, '0')}`;
        }
        
        function formatRunPace(avgSpeed) {
            if (!avgSpeed || avgSpeed <= 0) return '-';
            const pace = 1000 / avgSpeed;
            const min = Math.floor(pace / 60);
            const sec = Math.round(pace % 60);
            return `${min}:${String(sec).padStart(2, '0')}`;
        }
        
        function formatSwimPace(avgSpeed) {
            if (!avgSpeed || avgSpeed <= 0) return '-';
            const pace = 100 / avgSpeed;
            const min = Math.floor(pace / 60);
            const sec = Math.round(pace % 60);
            return `${min}:${String(sec).padStart(2, '0')}`;
        }
        
        function showError(message) {
            document.getElementById('loadingSection').style.display = 'none';
            document.getElementById('errorSection').style.display = 'block';
            document.getElementById('errorMessage').textContent = message;
        }
        
        function goBackToData() {
            window.location.href = 'data.html';
        }
    </script>
</body>
</html>
