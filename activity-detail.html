<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>„Ç¢„ÇØ„ÉÜ„Ç£„Éì„ÉÜ„Ç£Ë©≥Á¥∞ | AI Triathlon Coach</title>
    <!-- Leaflet CSS -->
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            line-height: 1.6;
            color: #333;
            background: linear-gradient(135deg, #dbeafe 0%, #ffffff 50%, #cffafe 100%);
            min-height: 100vh;
            margin: 0;
            padding: 0;
            display: flex;
        }
        
        /* „Éä„Éì„Ç≤„Éº„Ç∑„Éß„É≥ */
        .flow-navbar {
            position: fixed;
            top: 0;
            left: 0;
            bottom: 0;
            width: 240px;
            background: linear-gradient(180deg, #667eea 0%, #764ba2 100%);
            box-shadow: 4px 0 20px rgba(0, 0, 0, 0.1);
            z-index: 1000;
            display: flex;
            flex-direction: column;
            padding: 24px 0;
            overflow-y: auto;
        }

        .flow-nav-container {
            display: flex;
            flex-direction: column;
            height: 100%;
        }

        .flow-nav-logo {
            font-size: 1.3rem;
            font-weight: 700;
            color: white;
            text-align: center;
            padding: 0 20px 30px;
            margin-bottom: 20px;
            border-bottom: 2px solid rgba(255, 255, 255, 0.2);
        }

        .flow-nav-steps {
            display: flex;
            flex-direction: column;
            gap: 8px;
            padding: 0 16px;
            flex: 1;
        }

        .flow-nav-step {
            display: flex;
            align-items: center;
            gap: 12px;
            padding: 12px 16px;
            border-radius: 10px;
            font-size: 0.9rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            text-decoration: none;
            color: rgba(255, 255, 255, 0.8);
            white-space: nowrap;
        }

        .flow-nav-step .nav-icon {
            font-size: 1.4rem;
            flex-shrink: 0;
        }

        .flow-nav-step.current {
            background: rgba(255, 255, 255, 0.25);
            color: white;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
        }

        .flow-nav-step.available:hover {
            background: rgba(255, 255, 255, 0.15);
            color: white;
            transform: translateX(5px);
        }

        /* „É°„Ç§„É≥„Ç≥„É≥„ÉÜ„É≥„ÉÑ */
        .content-wrapper {
            margin-left: 240px;
            flex: 1;
            padding: 24px;
            width: calc(100% - 240px);
        }
        
        .container {
            max-width: 1400px;
            margin: 0 auto;
        }
        
        .back-button {
            background: #6c757d;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 0.9em;
            margin-bottom: 16px;
            transition: background 0.2s;
            text-decoration: none;
            display: inline-block;
        }
        
        .back-button:hover {
            background: #5a6268;
        }
        
        /* Ê¶ÇË¶Å„Éò„ÉÉ„ÉÄ„Éº */
        .activity-header {
            background: white;
            border-radius: 16px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.08);
            padding: 24px;
            margin-bottom: 20px;
        }
        
        .activity-title-row {
            display: flex;
            align-items: center;
            gap: 16px;
            margin-bottom: 16px;
        }
        
        .activity-icon {
            font-size: 2.5rem;
        }
        
        .activity-info h1 {
            font-size: 1.8rem;
            color: #1f2937;
            margin-bottom: 4px;
        }
        
        .activity-date {
            color: #6b7280;
            font-size: 0.95rem;
        }
        
        .activity-sport-badge {
            padding: 6px 14px;
            border-radius: 20px;
            font-size: 0.85rem;
            font-weight: 600;
            margin-left: auto;
        }
        
        .activity-sport-badge.swim { background: #dbeafe; color: #1d4ed8; }
        .activity-sport-badge.bike { background: #f3e8ff; color: #7c3aed; }
        .activity-sport-badge.run { background: #dcfce7; color: #16a34a; }
        .activity-sport-badge.other { background: #fef3c7; color: #b45309; }
        
        /* Ê¶ÇË¶Å„É°„Éà„É™„ÇØ„Çπ */
        .summary-metrics {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(140px, 1fr));
            gap: 16px;
        }
        
        .summary-metric {
            text-align: center;
            padding: 16px 12px;
            background: #f9fafb;
            border-radius: 12px;
        }
        
        .summary-metric-value {
            font-size: 1.8rem;
            font-weight: 700;
            color: #1f2937;
            line-height: 1.2;
        }
        
        .summary-metric-label {
            font-size: 0.75rem;
            color: #6b7280;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin-top: 4px;
        }
        
        /* „Ç∞„É™„ÉÉ„Éâ„É¨„Ç§„Ç¢„Ç¶„Éà */
        .detail-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin-bottom: 20px;
        }
        
        .detail-grid.full-width {
            grid-template-columns: 1fr;
        }
        
        .panel {
            background: white;
            border-radius: 16px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.08);
            overflow: hidden;
        }
        
        .panel-header {
            padding: 16px 20px;
            border-bottom: 1px solid #f3f4f6;
            display: flex;
            align-items: center;
            justify-content: space-between;
        }
        
        .panel-title {
            font-size: 1rem;
            font-weight: 700;
            color: #1f2937;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .panel-content {
            padding: 20px;
        }
        
        /* Âú∞Âõ≥ */
        #routeMap {
            height: 350px;
            border-radius: 8px;
        }
        
        .no-map-message {
            height: 350px;
            display: flex;
            align-items: center;
            justify-content: center;
            color: #9ca3af;
            font-size: 0.95rem;
            background: #f9fafb;
            border-radius: 8px;
        }
        
        /* „Ç∞„É©„Éï */
        .chart-container {
            position: relative;
            height: 250px;
        }
        
        .chart-container.small {
            height: 180px;
        }
        
        .chart-container.wide {
            height: 300px;
            width: 100%;
        }
        
        /* „Çø„Éñ„Éú„Çø„É≥ */
        .tab-buttons {
            display: flex;
            gap: 8px;
            flex-wrap: wrap;
        }
        
        .tab-btn {
            padding: 8px 16px;
            border: 2px solid #e5e7eb;
            background: white;
            border-radius: 8px;
            font-size: 0.85rem;
            font-weight: 600;
            color: #6b7280;
            cursor: pointer;
            transition: all 0.2s;
        }
        
        .tab-btn:hover {
            border-color: #667eea;
            color: #667eea;
        }
        
        .tab-btn.active {
            background: #667eea;
            border-color: #667eea;
            color: white;
        }
        
        .chart-tab-content {
            width: 100%;
        }
        
        .sport-metrics-row {
            display: flex;
            gap: 16px;
            margin-bottom: 16px;
            flex-wrap: wrap;
        }
        
        .sport-metric-item {
            background: #f3f4f6;
            padding: 12px 20px;
            border-radius: 10px;
            text-align: center;
            min-width: 120px;
        }
        
        .sport-metric-value {
            font-size: 1.4rem;
            font-weight: 700;
            color: #667eea;
        }
        
        .sport-metric-label {
            font-size: 0.75rem;
            color: #6b7280;
            margin-top: 2px;
        }
        
        /* ZoneÂàÜÂ∏É */
        .zone-summary {
            display: grid;
            grid-template-columns: repeat(5, 1fr);
            gap: 8px;
            margin-bottom: 16px;
        }
        
        .zone-item {
            text-align: center;
            padding: 12px 8px;
            border-radius: 8px;
            color: white;
            font-size: 0.8rem;
        }
        
        .zone-item.z1 { background: #9ca3af; }
        .zone-item.z2 { background: #3b82f6; }
        .zone-item.z3 { background: #22c55e; }
        .zone-item.z4 { background: #f97316; }
        .zone-item.z5 { background: #ef4444; }
        
        .zone-time {
            font-size: 1.1rem;
            font-weight: 700;
            display: block;
        }
        
        .zone-percent {
            font-size: 0.7rem;
            opacity: 0.9;
        }
        
        /* Lap„ÉÜ„Éº„Éñ„É´ */
        .lap-table {
            width: 100%;
            border-collapse: collapse;
            font-size: 0.85rem;
        }
        
        .lap-table th {
            background: #f3f4f6;
            padding: 10px 8px;
            text-align: left;
            font-weight: 600;
            color: #4b5563;
        }
        
        .lap-table td {
            padding: 10px 8px;
            border-bottom: 1px solid #f3f4f6;
        }
        
        .lap-table tbody tr:hover {
            background: #f9fafb;
        }
        
        /* AI„Ç≥„Éº„ÉÅ„Çª„ÇØ„Ç∑„Éß„É≥ */
        .ai-coach-panel {
            background: white;
            border-radius: 16px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.08);
            overflow: hidden;
        }
        
        .ai-coach-header {
            background: linear-gradient(135deg, #ff6b35 0%, #f7931e 100%);
            color: white;
            padding: 16px 20px;
            display: flex;
            align-items: center;
            gap: 12px;
        }
        
        .ai-coach-header h2 {
            font-size: 1.1rem;
            font-weight: 700;
        }
        
        .ai-coach-content {
            padding: 24px;
        }
        
        .ai-comment {
            font-size: 1rem;
            line-height: 1.8;
            color: #374151;
            white-space: pre-wrap;
        }
        
        .ai-loading {
            display: flex;
            align-items: center;
            gap: 12px;
            color: #6b7280;
            padding: 20px 0;
        }
        
        .ai-loading .spinner {
            width: 24px;
            height: 24px;
            border: 3px solid #e5e7eb;
            border-top-color: #f97316;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }
        
        @keyframes spin {
            to { transform: rotate(360deg); }
        }
        
        /* Ë≥™ÂïèÂÖ•Âäõ */
        .question-section {
            margin-top: 24px;
            padding-top: 20px;
            border-top: 1px solid #e5e7eb;
        }
        
        .question-section h3 {
            font-size: 0.95rem;
            font-weight: 600;
            color: #374151;
            margin-bottom: 12px;
        }
        
        .question-input-row {
            display: flex;
            gap: 12px;
        }
        
        .question-input {
            flex: 1;
            padding: 12px 16px;
            border: 2px solid #e5e7eb;
            border-radius: 10px;
            font-size: 0.95rem;
            transition: border-color 0.2s;
        }
        
        .question-input:focus {
            outline: none;
            border-color: #f97316;
        }
        
        .question-btn {
            padding: 12px 24px;
            background: linear-gradient(135deg, #ff6b35 0%, #f7931e 100%);
            color: white;
            border: none;
            border-radius: 10px;
            font-weight: 600;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
        }
        
        .question-btn:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(249, 115, 22, 0.4);
        }
        
        .question-btn:disabled {
            opacity: 0.6;
            cursor: not-allowed;
        }
        
        /* ‰ºöË©±Â±•Ê≠¥ */
        .chat-history {
            margin-top: 20px;
            max-height: 400px;
            overflow-y: auto;
        }
        
        .chat-message {
            padding: 12px 16px;
            border-radius: 12px;
            margin-bottom: 12px;
        }
        
        .chat-message.user {
            background: #f3f4f6;
            margin-left: 40px;
        }
        
        .chat-message.coach {
            background: #fff7ed;
            margin-right: 40px;
        }
        
        .chat-message-label {
            font-size: 0.75rem;
            font-weight: 600;
            color: #6b7280;
            margin-bottom: 4px;
        }
        
        .chat-message.coach .chat-message-label {
            color: #ea580c;
        }
        
        .chat-message-content {
            font-size: 0.95rem;
            line-height: 1.6;
            white-space: pre-wrap;
        }
        
        /* „É≠„Éº„Éá„Ç£„É≥„Ç∞ */
        .loading-container {
            text-align: center;
            padding: 60px 20px;
        }
        
        .loading-spinner {
            border: 4px solid #f3f3f3;
            border-radius: 50%;
            border-top: 4px solid #667eea;
            width: 50px;
            height: 50px;
            animation: spin 1s linear infinite;
            margin: 0 auto 20px;
        }
        
        /* „Ç®„É©„Éº */
        .error-message {
            background: #fef2f2;
            color: #991b1b;
            padding: 20px;
            border-radius: 12px;
            text-align: center;
        }
        
        /* Á®ÆÁõÆÂà•„É°„Éà„É™„ÇØ„Çπ */
        .sport-specific-row {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 16px;
            margin-top: 16px;
        }
        
        .sport-metric-card {
            background: #f9fafb;
            padding: 16px;
            border-radius: 12px;
            text-align: center;
        }
        
        .sport-metric-value {
            font-size: 1.5rem;
            font-weight: 700;
            color: #667eea;
        }
        
        .sport-metric-label {
            font-size: 0.8rem;
            color: #6b7280;
            margin-top: 4px;
        }
        
        /* „É¨„Çπ„Éù„É≥„Ç∑„Éñ */
        @media (max-width: 1024px) {
            .detail-grid {
                grid-template-columns: 1fr;
            }
        }
        
        @media (max-width: 768px) {
            body {
                flex-direction: column;
            }

            .flow-navbar {
                position: fixed;
                top: 0;
                left: 0;
                right: 0;
                bottom: auto;
                width: 100%;
                height: auto;
                padding: 12px 0;
            }

            .flow-nav-logo {
                padding: 0 20px 15px;
                margin-bottom: 10px;
                font-size: 1.1rem;
            }

            .flow-nav-steps {
                flex-direction: row;
                overflow-x: auto;
                gap: 5px;
                padding: 0 10px;
            }

            .flow-nav-step {
                padding: 8px 12px;
                font-size: 0.8rem;
            }

            .flow-nav-step span:not(.nav-icon) {
                display: none;
            }

            .content-wrapper {
                margin-left: 0;
                padding: 16px;
                padding-top: 140px;
                width: 100%;
            }
            
            .activity-title-row {
                flex-wrap: wrap;
            }
            
            .activity-sport-badge {
                margin-left: 0;
                margin-top: 8px;
            }
            
            .summary-metrics {
                grid-template-columns: repeat(3, 1fr);
            }
            
            .zone-summary {
                grid-template-columns: repeat(3, 1fr);
            }
            
            .question-input-row {
                flex-direction: column;
            }
        }
        
        /* „Çπ„Ç§„É†„ÉÅ„É£„Éº„ÉàÔºàHTML/CSSÁâàÔºâ */
        .swim-chart-container {
            width: 100%;
            height: 250px;
            display: flex;
            flex-direction: column;
        }
        
        .swim-chart-title {
            text-align: center;
            font-weight: 600;
            font-size: 14px;
            color: #374151;
            margin-bottom: 8px;
        }
        
        .swim-chart-wrapper {
            flex: 1;
            display: flex;
            min-height: 0;
        }
        
        .swim-chart-y-axis {
            width: 60px;
            position: relative;
            padding-right: 8px;
        }
        
        .swim-y-tick {
            position: absolute;
            right: 8px;
            font-size: 11px;
            color: #6b7280;
            transform: translateY(50%);
            white-space: nowrap;
        }
        
        .swim-y-label {
            position: absolute;
            left: 0;
            top: 50%;
            transform: rotate(-90deg) translateX(-50%);
            transform-origin: left center;
            font-size: 11px;
            color: #374151;
            white-space: nowrap;
        }
        
        .swim-chart-area {
            flex: 1;
            position: relative;
            border-left: 1px solid #9ca3af;
            border-bottom: 1px solid #9ca3af;
        }
        
        .swim-chart-grid {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
        }
        
        .swim-grid-line-h {
            position: absolute;
            left: 0;
            right: 0;
            height: 1px;
            background: #e5e7eb;
        }
        
        .swim-grid-line-v {
            position: absolute;
            top: 0;
            bottom: 0;
            width: 1px;
            background: #e5e7eb;
        }
        
        .swim-bars {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
        }
        
        .swim-bar {
            position: absolute;
            bottom: 0;
            background: rgba(59, 130, 246, 0.8);
            border: 1px solid rgba(59, 130, 246, 1);
            border-bottom: none;
            box-sizing: border-box;
            cursor: pointer;
            transition: background 0.15s;
        }
        
        .swim-bar:hover {
            background: rgba(59, 130, 246, 1);
        }
        
        .swim-chart-x-axis {
            height: 35px;
            position: relative;
            margin-left: 60px;
        }
        
        .swim-x-tick {
            position: absolute;
            top: 8px;
            font-size: 11px;
            color: #6b7280;
            transform: translateX(-50%);
        }
        
        .swim-x-label {
            position: absolute;
            bottom: 0;
            left: 50%;
            transform: translateX(-50%);
            font-size: 11px;
            color: #374151;
        }
        
        .swim-tooltip {
            position: fixed;
            background: rgba(0, 0, 0, 0.85);
            color: white;
            padding: 10px 14px;
            border-radius: 6px;
            font-size: 12px;
            line-height: 1.5;
            pointer-events: none;
            z-index: 10000;
            white-space: nowrap;
            display: none;
        }
    </style>
</head>
<body>
    <!-- „Éä„Éì„Ç≤„Éº„Ç∑„Éß„É≥ -->
    <nav class="flow-navbar">
        <div class="flow-nav-container">
            <div class="flow-nav-logo">AI Triathlon Coach</div>
            <div class="flow-nav-steps">
                <a href="home.html" class="flow-nav-step available">
                    <span class="nav-icon">üè†</span>
                    <span>„Éõ„Éº„É†</span>
                </a>
                <a href="index.html" class="flow-nav-step available">
                    <span class="nav-icon">ü§ñ</span>
                    <span>AI„Ç≥„Éº„ÉÅ</span>
                </a>
                <a href="news.html" class="flow-nav-step available">
                    <span class="nav-icon">üì∞</span>
                    <span>„Éã„É•„Éº„Çπ</span>
                </a>
                <a href="race-selection.html" class="flow-nav-step available">
                    <span class="nav-icon">üéØ</span>
                    <span>„É¨„Éº„ÇπÈÅ∏Êäû</span>
                </a>
                <a href="goal-setting.html" class="flow-nav-step available">
                    <span class="nav-icon">üèÜ</span>
                    <span>ÁõÆÊ®ôË®≠ÂÆö</span>
                </a>
                <a href="training-plan.html" class="flow-nav-step available">
                    <span class="nav-icon">üìã</span>
                    <span>Ë®àÁîª</span>
                </a>
                <a href="simulator.html" class="flow-nav-step available">
                    <span class="nav-icon">üî¨</span>
                    <span>„Ç∑„Éü„É•„É¨„Éº„Çø„Éº</span>
                </a>
                <a href="data.html" class="flow-nav-step current">
                    <span class="nav-icon">üìä</span>
                    <span>ÈÄ≤Êçó</span>
                </a>
                <a href="settings.html" class="flow-nav-step available">
                    <span class="nav-icon">‚öôÔ∏è</span>
                    <span>Ë®≠ÂÆö</span>
                </a>
            </div>
        </div>
    </nav>

    <div class="content-wrapper">
        <div class="container">
            <button class="back-button" onclick="goBackToData()">‚Üê ÈÄ≤Êçó„Éö„Éº„Ç∏„Å´Êàª„Çã</button>
            
            <!-- „É≠„Éº„Éá„Ç£„É≥„Ç∞ -->
            <div id="loadingSection" class="loading-container">
                <div class="loading-spinner"></div>
                <p>„Ç¢„ÇØ„ÉÜ„Ç£„Éì„ÉÜ„Ç£„Éá„Éº„Çø„ÇíË™≠„ÅøËæº„Åø‰∏≠...</p>
            </div>
            
            <!-- „É°„Ç§„É≥„Ç≥„É≥„ÉÜ„É≥„ÉÑ -->
            <div id="mainContent" style="display: none;">
                <!-- Ê¶ÇË¶Å„Éò„ÉÉ„ÉÄ„Éº -->
                <div class="activity-header">
                    <div class="activity-title-row">
                        <span class="activity-icon" id="activityIcon">üèÉ‚Äç‚ôÇÔ∏è</span>
                        <div class="activity-info">
                            <h1 id="activityName">„Ç¢„ÇØ„ÉÜ„Ç£„Éì„ÉÜ„Ç£Âêç</h1>
                            <div class="activity-date" id="activityDate">Êó•ÊôÇ</div>
                        </div>
                        <span class="activity-sport-badge run" id="sportBadge">„É©„É≥</span>
                    </div>
                    <div class="summary-metrics" id="summaryMetrics">
                        <!-- ÂãïÁöÑ„Å´ÁîüÊàê -->
                    </div>
                </div>
                
                <!-- Âú∞Âõ≥„Å®„Çæ„Éº„É≥ÂàÜÊûê -->
                <div class="detail-grid">
                    <div class="panel">
                        <div class="panel-header">
                            <h2 class="panel-title">üó∫Ô∏è „É´„Éº„Éà„Éû„ÉÉ„Éó</h2>
                        </div>
                        <div class="panel-content">
                            <div id="mapContainer">
                                <div id="routeMap"></div>
                            </div>
                        </div>
                    </div>
                    
                    <div class="panel">
                        <div class="panel-header">
                            <h2 class="panel-title">üíì ÂøÉÊãç„Çæ„Éº„É≥ÂàÜÂ∏É</h2>
                        </div>
                        <div class="panel-content">
                            <div class="zone-summary" id="zoneSummary">
                                <!-- ÂãïÁöÑ„Å´ÁîüÊàê -->
                            </div>
                            <div class="chart-container small">
                                <canvas id="zoneChart"></canvas>
                            </div>
                        </div>
                    </div>
                </div>
                
                <!-- ÊôÇÁ≥ªÂàó„Ç∞„É©„ÉïÔºà„Çø„ÉñÂàá„ÇäÊõø„ÅàÔºâ -->
                <div class="detail-grid full-width">
                    <div class="panel">
                        <div class="panel-header">
                            <h2 class="panel-title">üìà ÊôÇÁ≥ªÂàó„Éá„Éº„Çø</h2>
                            <div class="tab-buttons" id="chartTabs">
                                <button class="tab-btn active" data-tab="hr">üíì ÂøÉÊãçÊï∞</button>
                                <button class="tab-btn" data-tab="pace">‚è±Ô∏è „Éö„Éº„Çπ</button>
                                <button class="tab-btn" data-tab="rawVelocity" id="rawVelocityTab" style="display: none;">üîç Áîü„Éá„Éº„Çø</button>
                                <button class="tab-btn" data-tab="cadence" id="cadenceTab" style="display: none;">üîÑ „Ç±„Ç§„Éá„É≥„Çπ</button>
                                <button class="tab-btn" data-tab="power" id="powerTab" style="display: none;">‚ö° „Éë„ÉØ„Éº</button>
                            </div>
                        </div>
                        <div class="panel-content">
                            <div class="chart-tab-content" id="hrTabContent">
                                <div class="chart-container wide">
                                    <canvas id="hrChart"></canvas>
                                </div>
                            </div>
                            <div class="chart-tab-content" id="paceTabContent" style="display: none;">
                                <div class="chart-container wide">
                                    <canvas id="paceChart"></canvas>
                                </div>
                            </div>
                            <div class="chart-tab-content" id="rawVelocityTabContent" style="display: none;">
                                <div class="sport-metrics-row" id="rawVelocityMetrics"></div>
                                <div class="chart-container wide">
                                    <canvas id="rawVelocityChart"></canvas>
                                </div>
                            </div>
                            <div class="chart-tab-content" id="cadenceTabContent" style="display: none;">
                                <div class="sport-metrics-row" id="cadenceMetrics"></div>
                                <div class="chart-container wide">
                                    <canvas id="cadenceChart"></canvas>
                                </div>
                            </div>
                            <div class="chart-tab-content" id="powerTabContent" style="display: none;">
                                <div class="sport-metrics-row" id="powerMetrics"></div>
                                <div class="chart-container wide">
                                    <canvas id="powerChart"></canvas>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
                
                <!-- Lap„Éá„Éº„Çø -->
                <div class="detail-grid full-width" id="lapSection" style="display: none;">
                    <div class="panel">
                        <div class="panel-header">
                            <h2 class="panel-title">üìã LapË©≥Á¥∞</h2>
                        </div>
                        <div class="panel-content">
                            <div style="max-height: 300px; overflow-y: auto;">
                                <table class="lap-table" id="lapTable">
                                    <!-- ÂãïÁöÑ„Å´ÁîüÊàê -->
                                </table>
                            </div>
                        </div>
                    </div>
                </div>
                
                <!-- AI„Ç≥„Éº„ÉÅ„Ç≥„É°„É≥„Éà -->
                <div class="ai-coach-panel">
                    <div class="ai-coach-header">
                        <span style="font-size: 1.5rem;">ü§ñ</span>
                        <h2>AI„Ç≥„Éº„ÉÅ„Åã„Çâ„ÅÆ„Ç≥„É°„É≥„Éà</h2>
                    </div>
                    <div class="ai-coach-content">
                        <div id="aiCommentLoading" class="ai-loading">
                            <div class="spinner"></div>
                            <span>AI„Ç≥„Éº„ÉÅ„Åå„Ç¢„ÇØ„ÉÜ„Ç£„Éì„ÉÜ„Ç£„ÇíÂàÜÊûê‰∏≠...</span>
                        </div>
                        <div id="aiComment" class="ai-comment" style="display: none;"></div>
                        
                        <!-- Ë≥™Âïè„Çª„ÇØ„Ç∑„Éß„É≥ -->
                        <div class="question-section">
                            <h3>üí¨ „Ç≥„Éº„ÉÅ„Å´Ë≥™Âïè„Åô„Çã</h3>
                            <div class="question-input-row">
                                <input type="text" class="question-input" id="questionInput" 
                                    placeholder="‰æã: Ê¨°Âõû„ÅÆ„Éà„É¨„Éº„Éã„É≥„Ç∞„Åß„ÅØ„Å©„Åì„ÇíÊÑèË≠ò„Åô„Åπ„ÅçÔºü">
                                <button class="question-btn" id="askBtn" onclick="askQuestion()">Ë≥™Âïè„Åô„Çã</button>
                            </div>
                            <div class="chat-history" id="chatHistory" style="display: none;">
                                <!-- ‰ºöË©±Â±•Ê≠¥ -->
                            </div>
                        </div>
                    </div>
                </div>
            </div>
            
            <!-- „Ç®„É©„Éº -->
            <div id="errorSection" style="display: none;">
                <div class="error-message">
                    <h3>‚ùå „Éá„Éº„Çø„ÅÆÂèñÂæó„Å´Â§±Êïó„Åó„Åæ„Åó„Åü</h3>
                    <p id="errorMessage">„Ç®„É©„Éº„É°„ÉÉ„Çª„Éº„Ç∏</p>
                </div>
            </div>
        </div>
    </div>

    <!-- Scripts -->
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.0/dist/chart.umd.min.js"></script>
    
    <script>
        // ===== „Ç∞„É≠„Éº„Éê„É´Â§âÊï∞ =====
        let currentActivity = null;
        let streamData = null;
        let trainingStatus = null;
        let map = null;
        let charts = {};
        
        // ===== ÂàùÊúüÂåñ =====
        document.addEventListener('DOMContentLoaded', async () => {
            const activityId = getActivityId();
            
            if (!activityId) {
                showError('„Ç¢„ÇØ„ÉÜ„Ç£„Éì„ÉÜ„Ç£ID„ÅåÊåáÂÆö„Åï„Çå„Å¶„ÅÑ„Åæ„Åõ„Çì');
                return;
            }
            
            try {
                await loadActivityData(activityId);
            } catch (error) {
                console.error('Error loading activity:', error);
                showError(error.message);
            }
        });
        
        function getActivityId() {
            const urlParams = new URLSearchParams(window.location.search);
            return urlParams.get('id');
        }
        
        // ===== „Éá„Éº„ÇøË™≠„ÅøËæº„Åø =====
        async function loadActivityData(activityId) {
            // „Ç≠„É£„ÉÉ„Ç∑„É•„Åã„Çâ„Ç¢„ÇØ„ÉÜ„Ç£„Éì„ÉÜ„Ç£„ÇíÂèñÂæó
            const cachedActivities = localStorage.getItem('strava_activities');
            if (!cachedActivities) {
                throw new Error('„Ç¢„ÇØ„ÉÜ„Ç£„Éì„ÉÜ„Ç£„Éá„Éº„Çø„Åå„ÅÇ„Çä„Åæ„Åõ„Çì„ÄÇÈÄ≤Êçó„Éö„Éº„Ç∏„Åß„Éá„Éº„Çø„ÇíÂêåÊúü„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ');
            }
            
            const activities = JSON.parse(cachedActivities);
            currentActivity = activities.find(a => a.id.toString() === activityId.toString());
            
            if (!currentActivity) {
                throw new Error('ÊåáÂÆö„Åï„Çå„Åü„Ç¢„ÇØ„ÉÜ„Ç£„Éì„ÉÜ„Ç£„ÅåË¶ã„Å§„Åã„Çä„Åæ„Åõ„Çì');
            }
            
            // „Éà„É¨„Éº„Éã„É≥„Ç∞„Çπ„ÉÜ„Éº„Çø„Çπ„ÇíË®àÁÆó
            trainingStatus = calculateTrainingStatus(activities);
            
            // Âü∫Êú¨ÊÉÖÂ†±„ÇíË°®Á§∫
            renderActivityHeader();
            renderSummaryMetrics();
            
            // Streams API„Åß„Éá„Éº„Çø„ÇíÂèñÂæó
            await loadStreamData(activityId);
            
            // Laps API„Åß„É©„ÉÉ„Éó„Éá„Éº„Çø„ÇíÂèñÂæóÔºà„Çπ„Ç§„É†„Å™„Å©Ôºâ
            await loadLapData(activityId);
            
            // UI„ÇíË°®Á§∫
            document.getElementById('loadingSection').style.display = 'none';
            document.getElementById('mainContent').style.display = 'block';
            
            // „Ç∞„É©„Éï„ÇíÊèèÁîª
            renderCharts();
            
            // AI„Ç≥„É°„É≥„Éà„ÇíÂèñÂæó
            fetchAIComment();
        }
        
        async function loadStreamData(activityId) {
            const authData = localStorage.getItem('strava_auth');
            if (!authData) {
                console.log('No auth data, skipping streams');
                return;
            }
            
            try {
                const auth = JSON.parse(authData);
                const response = await fetch('/.netlify/functions/strava-streams', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        token: auth.access_token,
                        activityId: activityId
                    })
                });
                
                if (response.ok) {
                    const data = await response.json();
                    if (data.hasStreams) {
                        streamData = data.streams;
                        console.log('Stream data loaded:', Object.keys(streamData));
                    }
                }
            } catch (error) {
                console.error('Failed to load streams:', error);
            }
        }
        
        // „É©„ÉÉ„Éó„Éá„Éº„Çø„ÇíÂèñÂæóÔºàFORM/Garmin„Å™„Å©„Åã„Çâ„ÅÆ„Çπ„Ç§„É†„Éá„Éº„ÇøÁî®Ôºâ
        async function loadLapData(activityId) {
            const authData = localStorage.getItem('strava_auth');
            if (!authData) {
                console.log('No auth data, skipping laps');
                return;
            }
            
            try {
                const auth = JSON.parse(authData);
                const response = await fetch('/.netlify/functions/strava-laps', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        token: auth.access_token,
                        activityId: activityId
                    })
                });
                
                if (response.ok) {
                    const data = await response.json();
                    console.log('Lap API response:', data);
                    
                    // Êó¢Â≠òAPI„ÅØ lapCount „ÇíËøî„Åô
                    if (data.laps && data.laps.length > 0) {
                        currentActivity.laps = data.laps;
                        console.log('Lap data loaded:', data.laps.length, 'laps');
                        console.log('First lap sample:', data.laps[0]);
                        if (data.analysis) {
                            console.log('Lap analysis:', data.analysis);
                        }
                    } else {
                        console.log('No laps in response');
                    }
                } else {
                    console.error('Lap API error:', response.status);
                }
            } catch (error) {
                console.error('Failed to load laps:', error);
            }
        }
        
        // ===== „Éà„É¨„Éº„Éã„É≥„Ç∞„Çπ„ÉÜ„Éº„Çø„ÇπË®àÁÆó =====
        function calculateTrainingStatus(activities) {
            if (activities.length === 0) return null;
            
            const dailyTss = {};
            activities.forEach(activity => {
                const date = activity.start_date.split('T')[0];
                if (!dailyTss[date]) dailyTss[date] = 0;
                dailyTss[date] += activity.tss || 0;
            });
            
            const today = new Date();
            const days = [];
            for (let i = 89; i >= 0; i--) {
                const d = new Date(today);
                d.setDate(d.getDate() - i);
                const dateStr = d.toISOString().split('T')[0];
                days.push({ date: dateStr, tss: dailyTss[dateStr] || 0 });
            }
            
            const ctlFactor = 1 - Math.exp(-1 / 42);
            const atlFactor = 1 - Math.exp(-1 / 7);
            
            let ctl = 0, atl = 0, prevCtl = 0;
            
            days.forEach((day, i) => {
                ctl = ctl + (day.tss - ctl) * ctlFactor;
                atl = atl + (day.tss - atl) * atlFactor;
                if (i === days.length - 8) prevCtl = ctl;
            });
            
            return {
                ctl: Math.round(ctl * 10) / 10,
                atl: Math.round(atl * 10) / 10,
                tsb: Math.round((ctl - atl) * 10) / 10,
                ctlTrend: Math.round((ctl - prevCtl) * 10) / 10
            };
        }
        
        // ===== „Éò„ÉÉ„ÉÄ„ÉºÊèèÁîª =====
        function renderActivityHeader() {
            const sportType = currentActivity.sport_type || currentActivity.type;
            const sportCategory = getSportCategory(sportType);
            
            document.getElementById('activityIcon').textContent = getActivityIcon(sportType);
            document.getElementById('activityName').textContent = currentActivity.name || 'ÁÑ°È°å„ÅÆ„Ç¢„ÇØ„ÉÜ„Ç£„Éì„ÉÜ„Ç£';
            document.getElementById('activityDate').textContent = new Date(currentActivity.start_date).toLocaleString('ja-JP', {
                year: 'numeric', month: 'long', day: 'numeric',
                weekday: 'short', hour: '2-digit', minute: '2-digit'
            });
            
            const badge = document.getElementById('sportBadge');
            badge.textContent = getSportLabel(sportType);
            badge.className = `activity-sport-badge ${sportCategory}`;
        }
        
        function renderSummaryMetrics() {
            const sportType = currentActivity.sport_type || currentActivity.type;
            const sportCategory = getSportCategory(sportType);
            
            let html = '';
            
            // Ë∑ùÈõ¢
            if (currentActivity.distance) {
                html += createMetricCard((currentActivity.distance / 1000).toFixed(2), 'km', 'Ë∑ùÈõ¢');
            }
            
            // ÊôÇÈñì
            html += createMetricCard(formatDuration(currentActivity.moving_time), '', 'ÊôÇÈñì');
            
            // „Éö„Éº„Çπ/ÈÄüÂ∫¶
            if (currentActivity.average_speed) {
                if (sportCategory === 'swim') {
                    html += createMetricCard(formatSwimPace(currentActivity.average_speed), '/100m', '„Éö„Éº„Çπ');
                } else if (sportCategory === 'bike') {
                    html += createMetricCard((currentActivity.average_speed * 3.6).toFixed(1), 'km/h', 'Âπ≥ÂùáÈÄüÂ∫¶');
                } else {
                    html += createMetricCard(formatRunPace(currentActivity.average_speed), '/km', '„Éö„Éº„Çπ');
                }
            }
            
            // ÂøÉÊãç
            if (currentActivity.average_heartrate) {
                html += createMetricCard(Math.round(currentActivity.average_heartrate), 'bpm', 'Âπ≥ÂùáÂøÉÊãç');
            }
            
            // TSS
            if (currentActivity.tss) {
                html += createMetricCard(currentActivity.tss, '', 'TSS');
            }
            
            // Ê®ôÈ´ò
            if (currentActivity.total_elevation_gain && currentActivity.total_elevation_gain > 10) {
                html += createMetricCard(Math.round(currentActivity.total_elevation_gain), 'm', 'Áç≤ÂæóÊ®ôÈ´ò');
            }
            
            document.getElementById('summaryMetrics').innerHTML = html;
        }
        
        function createMetricCard(value, unit, label) {
            return `
                <div class="summary-metric">
                    <div class="summary-metric-value">${value}<small style="font-size: 0.6em; font-weight: 400;">${unit}</small></div>
                    <div class="summary-metric-label">${label}</div>
                </div>
            `;
        }
        
        // ===== „Ç∞„É©„ÉïÊèèÁîª =====
        function renderCharts() {
            renderMap();
            renderZoneChart();
            setupChartTabs();
            renderHeartRateChart();
            renderPaceChart();
            renderRawVelocityChartIfSwim();
            renderSportSpecificCharts();
            renderLapTable();
        }
        
        function renderRawVelocityChartIfSwim() {
            const sportCategory = getSportCategory(currentActivity.sport_type || currentActivity.type);
            if (sportCategory === 'swim' && streamData && streamData.velocity_smooth) {
                renderRawVelocityChart();
            }
        }
        
        function setupChartTabs() {
            const sportCategory = getSportCategory(currentActivity.sport_type || currentActivity.type);
            
            // „Éê„Ç§„ÇØ„ÅÆÂ†¥Âêà„ÅØ„Éö„Éº„Çπ„Çø„Éñ„Çí„ÄåÈÄüÂ∫¶„Äç„Å´Â§âÊõ¥
            const paceTabBtn = document.querySelector('.tab-btn[data-tab="pace"]');
            if (sportCategory === 'bike' && paceTabBtn) {
                paceTabBtn.textContent = 'üö¥ ÈÄüÂ∫¶';
            }
            
            // Á®ÆÁõÆÂà•„Çø„Éñ„ÅÆË°®Á§∫Âà∂Âæ°
            if (sportCategory === 'bike') {
                document.getElementById('cadenceTab').style.display = 'inline-block';
                document.getElementById('cadenceTab').textContent = 'üîÑ „Ç±„Ç§„Éá„É≥„Çπ';
                if (currentActivity.average_watts || (streamData && streamData.watts)) {
                    document.getElementById('powerTab').style.display = 'inline-block';
                }
            } else if (sportCategory === 'run') {
                if (currentActivity.average_cadence || (streamData && streamData.cadence)) {
                    document.getElementById('cadenceTab').style.display = 'inline-block';
                    document.getElementById('cadenceTab').textContent = 'üëü „Éî„ÉÉ„ÉÅ';
                }
            } else if (sportCategory === 'swim') {
                // „Çπ„Ç§„É†„ÅÆÂ†¥Âêà„ÅØÁîü„Éá„Éº„Çø„Çø„Éñ„ÇíË°®Á§∫Ôºà„Éá„Éê„ÉÉ„Ç∞Áî®Ôºâ
                if (streamData && streamData.velocity_smooth) {
                    document.getElementById('rawVelocityTab').style.display = 'inline-block';
                }
            }
            
            // „Çø„Éñ„ÇØ„É™„ÉÉ„ÇØ„Ç§„Éô„É≥„Éà
            document.querySelectorAll('.tab-btn').forEach(btn => {
                btn.addEventListener('click', (e) => {
                    const tabId = e.target.dataset.tab;
                    switchChartTab(tabId);
                });
            });
        }
        
        function switchChartTab(tabId) {
            // „Çø„Éñ„Éú„Çø„É≥„ÅÆ„Ç¢„ÇØ„ÉÜ„Ç£„ÉñÁä∂ÊÖã„ÇíÊõ¥Êñ∞
            document.querySelectorAll('.tab-btn').forEach(btn => {
                btn.classList.remove('active');
                if (btn.dataset.tab === tabId) {
                    btn.classList.add('active');
                }
            });
            
            // „Çø„Éñ„Ç≥„É≥„ÉÜ„É≥„ÉÑ„ÅÆË°®Á§∫„ÇíÂàá„ÇäÊõø„Åà
            document.querySelectorAll('.chart-tab-content').forEach(content => {
                content.style.display = 'none';
            });
            document.getElementById(`${tabId}TabContent`).style.display = 'block';
            
            // „Ç∞„É©„Éï„ÅÆ„É™„Çµ„Ç§„Ç∫„Çí„Éà„É™„Ç¨„ÉºÔºàË°®Á§∫Âæå„Å´ÊèèÁîª„ÇíÊõ¥Êñ∞Ôºâ
            if (charts[tabId]) {
                charts[tabId].resize();
            }
        }
        
        function renderMap() {
            const mapContainer = document.getElementById('mapContainer');
            
            if (!streamData || !streamData.latlng || !streamData.latlng.data || streamData.latlng.data.length === 0) {
                mapContainer.innerHTML = '<div class="no-map-message">üó∫Ô∏è GPS„Éá„Éº„Çø„Åå„ÅÇ„Çä„Åæ„Åõ„ÇìÔºà„Ç§„É≥„Éâ„Ç¢„Ç¢„ÇØ„ÉÜ„Ç£„Éì„ÉÜ„Ç£„ÅÆÂèØËÉΩÊÄßÔºâ</div>';
                return;
            }
            
            const coords = streamData.latlng.data;
            
            map = L.map('routeMap');
            
            // CartoDB Positron - ËñÑ„ÅÑ„Ç∞„É¨„ÉºÁ≥ª„Åß„É´„Éº„Éà„ÅåË¶ã„ÇÑ„Åô„ÅÑ
            L.tileLayer('https://{s}.basemaps.cartocdn.com/light_all/{z}/{x}/{y}{r}.png', {
                attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> &copy; <a href="https://carto.com/attributions">CARTO</a>',
                maxZoom: 19,
                subdomains: 'abcd'
            }).addTo(map);
            
            // „É´„Éº„Éà„É©„Ç§„É≥„ÅÆ„Çπ„Çø„Ç§„É´
            const polyline = L.polyline(coords, { 
                color: '#667eea', 
                weight: 5, 
                opacity: 0.9,
                lineJoin: 'round'
            }).addTo(map);
            
            map.fitBounds(polyline.getBounds(), { padding: [30, 30] });
            
            // „Çπ„Çø„Éº„Éà„Éª„Ç¥„Éº„É´„Éû„Éº„Ç´„Éº
            const startIcon = L.divIcon({ 
                className: 'custom-marker', 
                html: '<div style="background: #22c55e; width: 14px; height: 14px; border-radius: 50%; border: 3px solid white; box-shadow: 0 2px 6px rgba(0,0,0,0.3);"></div>',
                iconSize: [20, 20],
                iconAnchor: [10, 10]
            });
            const endIcon = L.divIcon({ 
                className: 'custom-marker', 
                html: '<div style="background: #ef4444; width: 14px; height: 14px; border-radius: 50%; border: 3px solid white; box-shadow: 0 2px 6px rgba(0,0,0,0.3);"></div>',
                iconSize: [20, 20],
                iconAnchor: [10, 10]
            });
            
            L.marker(coords[0], { icon: startIcon }).addTo(map).bindPopup('„Çπ„Çø„Éº„Éà');
            L.marker(coords[coords.length - 1], { icon: endIcon }).addTo(map).bindPopup('„Ç¥„Éº„É´');
        }
        
        function renderZoneChart() {
            const zones = calculateHeartRateZones();
            
            // Zone „Çµ„Éû„É™„Éº
            const zoneSummaryHtml = zones.map((z, i) => `
                <div class="zone-item z${i + 1}">
                    <span class="zone-time">${formatDurationShort(z.time)}</span>
                    <span class="zone-percent">${z.percent.toFixed(0)}%</span>
                </div>
            `).join('');
            document.getElementById('zoneSummary').innerHTML = zoneSummaryHtml;
            
            // Zone „ÉÅ„É£„Éº„Éà
            const ctx = document.getElementById('zoneChart').getContext('2d');
            if (charts.zone) charts.zone.destroy();
            
            charts.zone = new Chart(ctx, {
                type: 'bar',
                data: {
                    labels: ['Z1', 'Z2', 'Z3', 'Z4', 'Z5'],
                    datasets: [{
                        data: zones.map(z => z.percent),
                        backgroundColor: ['#9ca3af', '#3b82f6', '#22c55e', '#f97316', '#ef4444']
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: { legend: { display: false } },
                    scales: {
                        y: { beginAtZero: true, max: 100, title: { display: true, text: '%' } }
                    }
                }
            });
        }
        
        function calculateHeartRateZones() {
            const thresholds = getUserThresholds();
            const maxHr = thresholds.maxHr || 190;
            const totalTime = currentActivity.moving_time || 0;
            
            // Stream„Éá„Éº„Çø„Åå„ÅÇ„ÇãÂ†¥Âêà„ÅØË©≥Á¥∞Ë®àÁÆó
            if (streamData && streamData.heartrate && streamData.heartrate.data && streamData.time) {
                const hrData = streamData.heartrate.data;
                const timeData = streamData.time.data;
                
                const zoneTimes = [0, 0, 0, 0, 0];
                
                for (let i = 1; i < hrData.length; i++) {
                    const hr = hrData[i];
                    const duration = timeData[i] - timeData[i - 1];
                    const hrPercent = (hr / maxHr) * 100;
                    
                    if (hrPercent < 60) zoneTimes[0] += duration;
                    else if (hrPercent < 70) zoneTimes[1] += duration;
                    else if (hrPercent < 80) zoneTimes[2] += duration;
                    else if (hrPercent < 90) zoneTimes[3] += duration;
                    else zoneTimes[4] += duration;
                }
                
                const total = zoneTimes.reduce((a, b) => a + b, 0) || 1;
                return zoneTimes.map(t => ({ time: t, percent: (t / total) * 100 }));
            }
            
            // Âπ≥ÂùáÂøÉÊãç„Åã„ÇâÊé®ÂÆö
            const avgHr = currentActivity.average_heartrate;
            if (!avgHr) return [0, 1, 2, 3, 4].map(() => ({ time: 0, percent: 0 }));
            
            const hrPercent = (avgHr / maxHr) * 100;
            const zones = [0, 0, 0, 0, 0];
            
            if (hrPercent < 60) zones[0] = 100;
            else if (hrPercent < 70) zones[1] = 100;
            else if (hrPercent < 80) zones[2] = 100;
            else if (hrPercent < 90) zones[3] = 100;
            else zones[4] = 100;
            
            return zones.map((p, i) => ({ time: p > 0 ? totalTime : 0, percent: p }));
        }
        
        function renderHeartRateChart() {
            const ctx = document.getElementById('hrChart').getContext('2d');
            if (charts.hr) charts.hr.destroy();
            
            if (!streamData || !streamData.heartrate || !streamData.heartrate.data) {
                ctx.canvas.parentElement.innerHTML = '<div class="no-map-message">ÂøÉÊãç„Éá„Éº„Çø„Åå„ÅÇ„Çä„Åæ„Åõ„Çì</div>';
                return;
            }
            
            const sportCategory = getSportCategory(currentActivity.sport_type || currentActivity.type);
            const hrData = streamData.heartrate.data;
            const timeData = streamData.time?.data || hrData.map((_, i) => i);
            const distanceData = streamData.distance?.data;
            
            // „Éá„Éº„Çø„Çí„Çµ„É≥„Éó„É™„É≥„Ç∞ÔºàÂ§ö„Åô„Åé„ÇãÂ†¥ÂêàÔºâ
            const maxPoints = 500;
            const step = Math.max(1, Math.floor(hrData.length / maxPoints));
            
            const labels = [];
            const data = [];
            
            for (let i = 0; i < hrData.length; i += step) {
                if (distanceData) {
                    // „Çπ„Ç§„É†„ÅØmÂçò‰Ωç„ÄÅ„Åù„Çå‰ª•Â§ñ„ÅØkmÂçò‰Ωç
                    if (sportCategory === 'swim') {
                        labels.push(Math.round(distanceData[i]));
                    } else {
                        labels.push((distanceData[i] / 1000).toFixed(1));
                    }
                } else {
                    labels.push(formatDurationShort(timeData[i]));
                }
                data.push(hrData[i]);
            }
            
            charts.hr = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: labels,
                    datasets: [{
                        label: 'ÂøÉÊãçÊï∞',
                        data: data,
                        borderColor: '#ef4444',
                        borderWidth: 1.5,
                        fill: false,
                        tension: 0.2,
                        pointRadius: 0
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: { legend: { display: false } },
                    scales: {
                        x: { 
                            title: { display: true, text: distanceData ? (sportCategory === 'swim' ? 'Ë∑ùÈõ¢ (m)' : 'Ë∑ùÈõ¢ (km)') : 'ÊôÇÈñì' },
                            ticks: {
                                maxTicksLimit: sportCategory === 'swim' ? 10 : 12,
                                callback: function(value, index) {
                                    const label = this.getLabelForValue(value);
                                    // „Çπ„Ç§„É†„ÅØ200m„Åä„Åç„Å´Ë°®Á§∫
                                    if (sportCategory === 'swim' && distanceData) {
                                        const dist = parseFloat(label);
                                        if (dist % 200 === 0 || index === 0) {
                                            return label;
                                        }
                                        return '';
                                    }
                                    return label;
                                }
                            }
                        },
                        y: { title: { display: true, text: 'bpm' } }
                    },
                    interaction: {
                        intersect: false,
                        mode: 'index'
                    }
                }
            });
        }
        
        function renderPaceChart() {
            const ctx = document.getElementById('paceChart').getContext('2d');
            if (charts.pace) charts.pace.destroy();
            
            const sportCategory = getSportCategory(currentActivity.sport_type || currentActivity.type);
            
            // „Çπ„Ç§„É†„ÅÆÂ†¥ÂêàÔºö„É©„ÉÉ„Éó„Éá„Éº„Çø„Åå„ÅÇ„Çå„Å∞Ê£í„Ç∞„É©„Éï„Çí‰ΩøÁî®ÔºàFORM„Å™„Å©„Åã„Çâ„ÅÆ„Éá„Éº„ÇøÔºâ
            if (sportCategory === 'swim' && currentActivity.laps && currentActivity.laps.length > 0) {
                console.log('„Çπ„Ç§„É†: „É©„ÉÉ„Éó„Éá„Éº„Çø„Çí‰ΩøÁî®„Åó„Å¶Ê£í„Ç∞„É©„Éï„ÇíÊèèÁîª');
                renderSwimLapBarChart();
                return;
            }
            
            if (!streamData || !streamData.velocity_smooth || !streamData.velocity_smooth.data) {
                ctx.canvas.parentElement.innerHTML = '<div class="no-map-message">„Éö„Éº„Çπ/ÈÄüÂ∫¶„Éá„Éº„Çø„Åå„ÅÇ„Çä„Åæ„Åõ„Çì</div>';
                return;
            }
            
            const velData = streamData.velocity_smooth.data;
            const distanceData = streamData.distance?.data;
            const timeData = streamData.time?.data || velData.map((_, i) => i);
            
            // ÈÄüÂ∫¶„ÅÆÈñæÂÄ§„ÇíË®≠ÂÆöÔºàÂÅúÊ≠¢„ÇÑÊ≠©Ë°å„ÇíÈô§Â§ñÔºâ
            const minVelocity = getMinVelocityThreshold(sportCategory);
            
            let labels = [];
            let data = [];
            let rawPaceValues = [];
            
            // „Çπ„Ç§„É†„ÅÆÂ†¥Âêà„ÅØ„Çø„Éº„É≥Âçò‰ΩçÔºà25m/50mÔºâ„ÅÆÂπ≥Âùá„Éö„Éº„Çπ„Çí‰ΩøÁî®Ôºà„É©„ÉÉ„Éó„Éá„Éº„Çø„Åå„Å™„ÅÑÂ†¥Âêà„ÅÆ„Éï„Ç©„Éº„É´„Éê„ÉÉ„ÇØÔºâ
            if (sportCategory === 'swim' && distanceData) {
                const poolLength = detectPoolLength();
                const lapData = calculateSwimLapPaces(velData, distanceData, poolLength);
                labels = lapData.labels;
                data = lapData.paces;
                rawPaceValues = lapData.paces.filter(p => p && p > 0);
            } else {
                // ÈÄöÂ∏∏„ÅÆÂá¶ÁêÜÔºà„É©„É≥„ÄÅ„Éê„Ç§„ÇØÁ≠âÔºâ
                const maxPoints = 500;
                const step = Math.max(1, Math.floor(velData.length / maxPoints));
                
                for (let i = 0; i < velData.length; i += step) {
                    if (distanceData) {
                        labels.push((distanceData[i] / 1000).toFixed(1));
                    } else {
                        labels.push(formatDurationShort(timeData[i]));
                    }
                    
                    const vel = velData[i];
                    
                    if (sportCategory === 'bike') {
                        const speed = vel * 3.6; // km/h
                        data.push(speed);
                        if (vel >= minVelocity) rawPaceValues.push(speed);
                    } else {
                        // „É©„É≥: min/km
                        const pace = vel > 0 ? 1000 / vel / 60 : null;
                        data.push(pace);
                        if (vel >= minVelocity && pace) rawPaceValues.push(pace);
                    }
                }
            }
            
            // YËª∏„ÅÆÁØÑÂõ≤„ÇíË®àÁÆóÔºàÂ§ñ„ÇåÂÄ§„ÇíÈô§Â§ñÔºâ
            const yAxisRange = calculateYAxisRange(rawPaceValues, sportCategory);
            
            const xLabel = sportCategory === 'swim' ? 'Ë∑ùÈõ¢ (m)' : (distanceData ? 'Ë∑ùÈõ¢ (km)' : 'ÊôÇÈñì');
            const poolLength = sportCategory === 'swim' ? detectPoolLength() : null;
            
            charts.pace = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: labels,
                    datasets: [{
                        label: sportCategory === 'bike' ? 'ÈÄüÂ∫¶' : '„Éö„Éº„Çπ',
                        data: data,
                        borderColor: '#3b82f6',
                        borderWidth: sportCategory === 'swim' ? 2 : 1.5,
                        fill: false,
                        tension: 0.2,
                        pointRadius: sportCategory === 'swim' ? 3 : 0, // „Çπ„Ç§„É†„ÅØ„Éù„Ç§„É≥„Éà„ÇíË°®Á§∫
                        pointBackgroundColor: '#3b82f6',
                        spanGaps: true
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: { legend: { display: false } },
                    scales: {
                        x: { 
                            title: { display: true, text: xLabel },
                            ticks: {
                                maxTicksLimit: sportCategory === 'swim' ? 15 : 12,
                                callback: function(value, index) {
                                    const label = this.getLabelForValue(value);
                                    // „Çπ„Ç§„É†„ÅØ100m„Åä„Åç„Å´„É©„Éô„É´„ÇíË°®Á§∫
                                    if (sportCategory === 'swim') {
                                        const dist = parseFloat(label);
                                        if (dist % 100 === 0) {
                                            return label + 'm';
                                        }
                                        return '';
                                    }
                                    return label;
                                }
                            }
                        },
                        y: { 
                            title: { display: true, text: sportCategory === 'bike' ? 'km/h' : '„Éö„Éº„Çπ' },
                            reverse: sportCategory !== 'bike',
                            min: yAxisRange.min,
                            max: yAxisRange.max,
                            ticks: {
                                callback: function(value) {
                                    if (sportCategory === 'bike') {
                                        return value.toFixed(0);
                                    } else if (sportCategory === 'swim') {
                                        // „Çπ„Ç§„É†: Áßí„ÇíÂàÜ:Áßí„Å´Â§âÊèõ
                                        const min = Math.floor(value / 60);
                                        const sec = Math.round(value % 60);
                                        return `${min}:${String(sec).padStart(2, '0')}`;
                                    } else {
                                        // „É©„É≥: min/kmÔºàvalue„ÅØÂàÜÂçò‰Ωç„ÅÆÂ∞èÊï∞Ôºâ
                                        const min = Math.floor(value);
                                        const sec = Math.round((value - min) * 60);
                                        return `${min}:${String(sec).padStart(2, '0')}`;
                                    }
                                }
                            }
                        }
                    },
                    interaction: {
                        intersect: false,
                        mode: 'index'
                    },
                    plugins: {
                        tooltip: {
                            callbacks: {
                                title: function(context) {
                                    if (sportCategory === 'swim') {
                                        const dist = context[0].label;
                                        const lapNum = Math.ceil(parseFloat(dist) / poolLength);
                                        return `${dist}m („É©„ÉÉ„Éó ${lapNum})`;
                                    }
                                    return context[0].label;
                                },
                                label: function(context) {
                                    const value = context.raw;
                                    if (value === null) return 'ÂÅúÊ≠¢‰∏≠';
                                    if (sportCategory === 'bike') {
                                        return `ÈÄüÂ∫¶: ${value.toFixed(1)} km/h`;
                                    } else if (sportCategory === 'swim') {
                                        // „Çπ„Ç§„É†: Áßí„ÇíÂàÜ:Áßí„Å´Â§âÊèõ
                                        const min = Math.floor(value / 60);
                                        const sec = Math.round(value % 60);
                                        return `„Éö„Éº„Çπ: ${min}:${String(sec).padStart(2, '0')}/100m`;
                                    } else {
                                        const min = Math.floor(value);
                                        const sec = Math.round((value - min) * 60);
                                        return `„Éö„Éº„Çπ: ${min}:${String(sec).padStart(2, '0')}/km`;
                                    }
                                }
                            }
                        }
                    }
                }
            });
        }
        
        // „Çπ„Ç§„É†Áîü„Éá„Éº„ÇøÔºàvelocity_smoothÔºâ„ÇíÂèØË¶ñÂåñ
        function renderRawVelocityChart() {
            const ctx = document.getElementById('rawVelocityChart').getContext('2d');
            if (charts.rawVelocity) charts.rawVelocity.destroy();
            
            if (!streamData || !streamData.velocity_smooth || !streamData.velocity_smooth.data) {
                ctx.canvas.parentElement.innerHTML = '<div class="no-map-message">ÈÄüÂ∫¶„Éá„Éº„Çø„Åå„ÅÇ„Çä„Åæ„Åõ„Çì</div>';
                return;
            }
            
            const velData = streamData.velocity_smooth.data;
            const distanceData = streamData.distance?.data;
            const timeData = streamData.time?.data || velData.map((_, i) => i);
            const movingData = streamData.moving?.data;
            
            // Áµ±Ë®àÊÉÖÂ†±„ÇíË®àÁÆó
            const validVelocities = velData.filter(v => v > 0);
            const zeroCount = velData.filter(v => v === 0).length;
            const minVel = validVelocities.length > 0 ? Math.min(...validVelocities) : 0;
            const maxVel = validVelocities.length > 0 ? Math.max(...validVelocities) : 0;
            const avgVel = validVelocities.length > 0 ? validVelocities.reduce((a,b)=>a+b,0)/validVelocities.length : 0;
            
            // „É°„Éà„É™„ÇØ„ÇπË°®Á§∫
            document.getElementById('rawVelocityMetrics').innerHTML = `
                <div class="sport-metric-item">
                    <div class="sport-metric-value">${velData.length}</div>
                    <div class="sport-metric-label">Á∑è„Çµ„É≥„Éó„É´Êï∞</div>
                </div>
                <div class="sport-metric-item">
                    <div class="sport-metric-value">${zeroCount}</div>
                    <div class="sport-metric-label">ÈÄüÂ∫¶0„ÅÆ„Çµ„É≥„Éó„É´</div>
                </div>
                <div class="sport-metric-item">
                    <div class="sport-metric-value">${minVel.toFixed(3)}</div>
                    <div class="sport-metric-label">ÊúÄÂ∞èÈÄüÂ∫¶ (m/s)</div>
                </div>
                <div class="sport-metric-item">
                    <div class="sport-metric-value">${maxVel.toFixed(3)}</div>
                    <div class="sport-metric-label">ÊúÄÂ§ßÈÄüÂ∫¶ (m/s)</div>
                </div>
                <div class="sport-metric-item">
                    <div class="sport-metric-value">${avgVel.toFixed(3)}</div>
                    <div class="sport-metric-label">Âπ≥ÂùáÈÄüÂ∫¶ (m/s)</div>
                </div>
                <div class="sport-metric-item">
                    <div class="sport-metric-value">${formatPaceDebug(100/maxVel)}</div>
                    <div class="sport-metric-label">ÊúÄÈÄü„Éö„Éº„Çπ</div>
                </div>
                <div class="sport-metric-item">
                    <div class="sport-metric-value">${minVel > 0 ? formatPaceDebug(100/minVel) : '-'}</div>
                    <div class="sport-metric-label">ÊúÄÈÅÖ„Éö„Éº„Çπ</div>
                </div>
            `;
            
            // „Çµ„É≥„Éó„É™„É≥„Ç∞ÔºàÂÖ®„Éá„Éº„Çø„ÅåÂ§ö„Åô„Åé„ÇãÂ†¥ÂêàÔºâ
            const maxPoints = 2000;
            const step = Math.max(1, Math.floor(velData.length / maxPoints));
            
            const labels = [];
            const velocities = [];
            const movingStatus = [];
            
            for (let i = 0; i < velData.length; i += step) {
                // XËª∏: Ë∑ùÈõ¢„Åå„ÅÇ„Çå„Å∞Ë∑ùÈõ¢„ÄÅ„Å™„Åë„Çå„Å∞„Ç§„É≥„Éá„ÉÉ„ÇØ„Çπ
                if (distanceData) {
                    labels.push(Math.round(distanceData[i]));
                } else {
                    labels.push(i);
                }
                velocities.push(velData[i]);
                if (movingData) {
                    movingStatus.push(movingData[i] ? null : velData[i]); // ÂÅúÊ≠¢‰∏≠„ÅÆ„Éù„Ç§„É≥„Éà„ÇíÂà•Ëâ≤„Åß
                }
            }
            
            const datasets = [{
                label: 'velocity_smooth (m/s)',
                data: velocities,
                borderColor: '#3b82f6',
                borderWidth: 1,
                fill: false,
                tension: 0,
                pointRadius: 0
            }];
            
            // moving=false„ÅÆ„Éù„Ç§„É≥„Éà„ÇíËµ§„ÅßË°®Á§∫
            if (movingData) {
                datasets.push({
                    label: 'ÂÅúÊ≠¢‰∏≠ (moving=false)',
                    data: movingStatus.map((v, i) => movingData[i * step] === false ? velocities[i] : null),
                    borderColor: '#ef4444',
                    backgroundColor: '#ef4444',
                    borderWidth: 0,
                    pointRadius: 3,
                    showLine: false
                });
            }
            
            charts.rawVelocity = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: labels,
                    datasets: datasets
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: { 
                        legend: { display: movingData ? true : false },
                        title: {
                            display: true,
                            text: 'velocity_smooth Áîü„Éá„Éº„ÇøÔºàStrava API„Åã„ÇâÂèñÂæó„Åó„Åü„Åæ„ÅæÔºâ'
                        }
                    },
                    scales: {
                        x: { 
                            title: { display: true, text: distanceData ? 'Ë∑ùÈõ¢ (m)' : '„Çµ„É≥„Éó„É´Index' },
                            ticks: {
                                maxTicksLimit: 15,
                                callback: function(value, index) {
                                    const label = this.getLabelForValue(value);
                                    if (distanceData) {
                                        const dist = parseFloat(label);
                                        if (dist % 200 === 0) return label + 'm';
                                        return '';
                                    }
                                    return label;
                                }
                            }
                        },
                        y: { 
                            title: { display: true, text: 'ÈÄüÂ∫¶ (m/s)' },
                            min: 0
                        }
                    },
                    interaction: {
                        intersect: false,
                        mode: 'index'
                    },
                    plugins: {
                        tooltip: {
                            callbacks: {
                                afterLabel: function(context) {
                                    const vel = context.raw;
                                    if (vel > 0) {
                                        const pace = 100 / vel;
                                        return `= ${formatPaceDebug(pace)}`;
                                    }
                                    return 'ÂÅúÊ≠¢‰∏≠';
                                }
                            }
                        }
                    }
                }
            });
        }
        
        // „Çπ„Ç§„É†„É©„ÉÉ„ÉóÊ£í„Ç∞„É©„ÉïÔºàHTML/CSS„ÅßÊèèÁîª„ÄÅXËª∏=Ë∑ùÈõ¢„ÄÅÊ£íÂπÖ„ÅØË∑ùÈõ¢„Å´ÊØî‰æãÔºâ
        function renderSwimLapBarChart() {
            if (!currentActivity.laps || currentActivity.laps.length === 0) {
                return;
            }
            
            // Chart.js„ÅÆ„Ç§„É≥„Çπ„Çø„É≥„Çπ„Åå„ÅÇ„Çå„Å∞Á†¥Ê£Ñ
            if (charts.pace) {
                charts.pace.destroy();
                charts.pace = null;
            }
            
            const container = document.getElementById('paceChart').parentElement;
            const laps = currentActivity.laps;
            
            // Ê≥≥„Åé„É©„ÉÉ„Éó„ÅÆ„ÅøÊäΩÂá∫ÔºàREST„ÇíÈô§Â§ñÔºâ
            const swimLaps = [];
            let cumulativeDistance = 0;
            
            laps.forEach((lap, index) => {
                const distance = lap.distance || 0;
                const movingTime = lap.moving_time || 0;
                
                // „Éö„Éº„ÇπË®àÁÆóÔºàÁßí/100mÔºâ
                let paceSeconds = null;
                if (lap.average_speed && lap.average_speed > 0) {
                    paceSeconds = 100 / lap.average_speed;
                } else if (movingTime > 0 && distance > 0) {
                    paceSeconds = (movingTime / distance) * 100;
                }
                
                // „É¨„Çπ„ÉàÂà§ÂÆö
                const isRest = distance === 0 ||
                               movingTime === 0 || 
                               movingTime < 10 ||
                               (paceSeconds && paceSeconds > 300) ||
                               (paceSeconds && paceSeconds < 60);
                
                if (!isRest && paceSeconds && distance > 0) {
                    swimLaps.push({
                        lapNumber: index + 1,
                        distance: distance,
                        startDistance: cumulativeDistance,
                        endDistance: cumulativeDistance + distance,
                        paceSeconds: paceSeconds,
                        movingTime: movingTime,
                        heartrate: lap.average_heartrate,
                        strokes: lap.total_strokes,
                        cadence: lap.average_cadence
                    });
                    cumulativeDistance += distance;
                }
            });
            
            const totalDistance = cumulativeDistance;
            console.log(`Ê≥≥„Åé„É©„ÉÉ„Éó: ${swimLaps.length}, Á∑èË∑ùÈõ¢: ${totalDistance}m`);
            
            if (swimLaps.length === 0) {
                container.innerHTML = '<div class="no-map-message">ÊúâÂäπ„Å™„Çπ„Ç§„É†„É©„ÉÉ„Éó„Éá„Éº„Çø„Åå„ÅÇ„Çä„Åæ„Åõ„Çì</div>';
                return;
            }
            
            // YËª∏ÁØÑÂõ≤„ÇíË®àÁÆó
            const paces = swimLaps.map(d => d.paceSeconds);
            const minPace = Math.min(...paces);
            const maxPace = Math.max(...paces);
            const avgPace = paces.reduce((a,b)=>a+b,0) / paces.length;
            const paceRange = maxPace - minPace || 20;
            const padding = Math.max(paceRange * 0.15, 5);
            const yMin = Math.floor((minPace - padding) / 5) * 5;
            const yMax = Math.ceil((maxPace + padding) / 5) * 5;
            
            // XËª∏„ÅÆÁõÆÁõõ„Çä
            const xStep = calculateXAxisStep(totalDistance);
            const xTicks = [];
            for (let d = 0; d <= totalDistance; d += xStep) {
                xTicks.push(d);
            }
            if (xTicks[xTicks.length - 1] !== totalDistance) {
                xTicks.push(totalDistance);
            }
            
            // YËª∏„ÅÆÁõÆÁõõ„ÇäÔºà10ÁßíÂàª„ÅøÔºâ
            const yTicks = [];
            for (let p = yMin; p <= yMax; p += 10) {
                yTicks.push(p);
            }
            
            // HTMLÁîüÊàê
            let html = `
                <div class="swim-chart-container">
                    <div class="swim-chart-title">„É©„ÉÉ„Éó„Éö„Éº„ÇπÔºà${swimLaps.length}Êú¨„ÄÅÂπ≥Âùá: ${formatPaceDebug(avgPace)}Ôºâ</div>
                    <div class="swim-chart-wrapper">
                        <div class="swim-chart-y-axis">
                            ${yTicks.map(p => `<div class="swim-y-tick" style="bottom: ${((yMax - p) / (yMax - yMin)) * 100}%">${Math.floor(p/60)}:${String(Math.round(p%60)).padStart(2,'0')}</div>`).join('')}
                            <div class="swim-y-label">„Éö„Éº„Çπ (/100m)</div>
                        </div>
                        <div class="swim-chart-area">
                            <div class="swim-chart-grid">
                                ${yTicks.map(p => `<div class="swim-grid-line-h" style="bottom: ${((yMax - p) / (yMax - yMin)) * 100}%"></div>`).join('')}
                                ${xTicks.map(d => `<div class="swim-grid-line-v" style="left: ${(d / totalDistance) * 100}%"></div>`).join('')}
                            </div>
                            <div class="swim-bars">
                                ${swimLaps.map(lap => {
                                    const left = (lap.startDistance / totalDistance) * 100;
                                    const width = (lap.distance / totalDistance) * 100;
                                    // ÈÄü„ÅÑ„Éö„Éº„ÇπÔºàÂ∞è„Åï„ÅÑÂÄ§Ôºâ„Åª„Å©È´ò„ÅÑÊ£í„Å´„Å™„Çã„Çà„ÅÜ„Å´Ë®àÁÆó
                                    const height = ((yMax - lap.paceSeconds) / (yMax - yMin)) * 100;
                                    return `<div class="swim-bar" 
                                        style="left: ${left}%; width: ${width}%; height: ${height}%;"
                                        data-lap='${JSON.stringify(lap)}'
                                        title="${lap.startDistance}m-${lap.endDistance}m: ${formatPaceDebug(lap.paceSeconds)}"></div>`;
                                }).join('')}
                            </div>
                        </div>
                    </div>
                    <div class="swim-chart-x-axis">
                        ${xTicks.map(d => `<div class="swim-x-tick" style="left: ${(d / totalDistance) * 100}%">${d}m</div>`).join('')}
                        <div class="swim-x-label">Ë∑ùÈõ¢ (m)</div>
                    </div>
                </div>
            `;
            
            container.innerHTML = html;
            
            // „ÉÑ„Éº„É´„ÉÅ„ÉÉ„Éó„Ç§„Éô„É≥„Éà
            container.querySelectorAll('.swim-bar').forEach(bar => {
                bar.addEventListener('mouseenter', (e) => {
                    const lap = JSON.parse(e.target.dataset.lap);
                    showSwimTooltip(e, lap);
                });
                bar.addEventListener('mousemove', (e) => {
                    moveSwimTooltip(e);
                });
                bar.addEventListener('mouseleave', hideSwimTooltip);
            });
        }
        
        // XËª∏„ÅÆÁõÆÁõõ„ÇäÈñìÈöî„ÇíË®àÁÆó
        function calculateXAxisStep(totalDistance) {
            if (totalDistance <= 500) return 100;
            if (totalDistance <= 1000) return 200;
            if (totalDistance <= 2000) return 500;
            if (totalDistance <= 5000) return 500;
            return 1000;
        }
        
        // „Çπ„Ç§„É†„ÉÅ„É£„Éº„Éà„ÅÆ„ÉÑ„Éº„É´„ÉÅ„ÉÉ„Éó
        let swimTooltip = null;
        
        function showSwimTooltip(e, lap) {
            if (!swimTooltip) {
                swimTooltip = document.createElement('div');
                swimTooltip.className = 'swim-tooltip';
                document.body.appendChild(swimTooltip);
            }
            
            let html = `<strong>${lap.startDistance}m - ${lap.endDistance}m (Lap ${lap.lapNumber})</strong><br>`;
            html += `„Éö„Éº„Çπ: ${formatPaceDebug(lap.paceSeconds)}<br>`;
            html += `ÊôÇÈñì: ${lap.movingTime}Áßí<br>`;
            html += `Ë∑ùÈõ¢: ${lap.distance}m`;
            if (lap.heartrate) html += `<br>ÂøÉÊãç: ${Math.round(lap.heartrate)} bpm`;
            if (lap.strokes) html += `<br>„Çπ„Éà„É≠„Éº„ÇØ: ${lap.strokes}`;
            if (lap.cadence) html += `<br>„Ç±„Ç§„Éá„É≥„Çπ: ${lap.cadence} spm`;
            
            swimTooltip.innerHTML = html;
            swimTooltip.style.display = 'block';
            swimTooltip.style.left = (e.clientX + 15) + 'px';
            swimTooltip.style.top = (e.clientY + 15) + 'px';
        }
        
        function moveSwimTooltip(e) {
            if (swimTooltip) {
                swimTooltip.style.left = (e.clientX + 15) + 'px';
                swimTooltip.style.top = (e.clientY + 15) + 'px';
            }
        }
        
        function hideSwimTooltip() {
            if (swimTooltip) {
                swimTooltip.style.display = 'none';
            }
        }
        
        // Á®ÆÁõÆÂà•„ÅÆÊúÄÂ∞èÈÄüÂ∫¶ÈñæÂÄ§Ôºà„Åì„Çå‰ª•‰∏ã„ÅØÂÅúÊ≠¢/Ê≠©Ë°å„Å®„Åø„Å™„ÅôÔºâ
        function getMinVelocityThreshold(sportCategory) {
            switch (sportCategory) {
                case 'bike':
                    return 3.0; // 10.8 km/h ‰ª•‰∏ã„ÅØÈô§Â§ñ
                case 'run':
                    return 1.5; // 5.4 km/h (Á¥Ñ11:00/km) ‰ª•‰∏ã„ÅØÈô§Â§ñ
                case 'swim':
                    return 0.3; // 3:20/100m „Çà„ÇäÈÅÖ„ÅÑ„ÇÇ„ÅÆ„ÅØÈô§Â§ñ
                default:
                    return 1.0;
            }
        }
        
        // YËª∏„ÅÆÁØÑÂõ≤„Çí„Éë„Éº„Çª„É≥„Çø„Ç§„É´„Éô„Éº„Çπ„ÅßË®àÁÆó
        function calculateYAxisRange(values, sportCategory) {
            if (values.length === 0) {
                return { min: undefined, max: undefined };
            }
            
            // „ÇΩ„Éº„Éà„Åó„Å¶„Éë„Éº„Çª„É≥„Çø„Ç§„É´„ÇíË®àÁÆó
            const sorted = [...values].sort((a, b) => a - b);
            const p5 = sorted[Math.floor(sorted.length * 0.05)];
            const p95 = sorted[Math.floor(sorted.length * 0.95)];
            const median = sorted[Math.floor(sorted.length * 0.5)];
            
            // ÁØÑÂõ≤„ÇíË®àÁÆóÔºà„Éë„Éº„Çª„É≥„Çø„Ç§„É´„ÇíÂü∫Ê∫ñ„Å´Â∞ë„Åó‰ΩôË£ï„ÇíÊåÅ„Åü„Åõ„ÇãÔºâ
            const range = p95 - p5;
            const padding = range * 0.15; // 15%„ÅÆ‰ΩôÁôΩ
            
            if (sportCategory === 'bike') {
                // ÈÄüÂ∫¶„ÅÆÂ†¥ÂêàÔºöÈÄü„ÅÑ„Åª„Å©‰∏ä„Å™„ÅÆ„ÅßÈÄöÂ∏∏„ÅÆmin/max
                return {
                    min: Math.max(0, Math.floor(p5 - padding)),
                    max: Math.ceil(p95 + padding)
                };
            } else {
                // „Éö„Éº„Çπ„ÅÆÂ†¥ÂêàÔºöÈÅÖ„ÅÑ„Åª„Å©Êï∞ÂÄ§„ÅåÂ§ß„Åç„ÅÑÔºà„Ç∞„É©„Éï„ÅØÂèçËª¢„Åô„Çã„ÅÆ„Åßmin„ÅåÈÄü„ÅÑ„ÄÅmax„ÅåÈÅÖ„ÅÑÔºâ
                // „Çà„ÇäÁ¥∞„Åã„ÅÑ„Éö„Éº„ÇπÂ§âÂãï„ÅåË¶ã„Åà„Çã„Çà„ÅÜ„Å´ÁØÑÂõ≤„ÇíÁã≠„ÇÅ„Çã
                const minPace = Math.max(0, p5 - padding * 0.5); // ÈÄü„ÅÑÂÅ¥ÔºàÊï∞ÂÄ§Â∞è„Åï„ÅÑÔºâ
                const maxPace = p95 + padding * 0.5; // ÈÅÖ„ÅÑÂÅ¥ÔºàÊï∞ÂÄ§Â§ß„Åç„ÅÑÔºâ
                
                // „É©„É≥„ÅÆÂ†¥Âêà„ÄÅË°®Á§∫ÁØÑÂõ≤„ÇíÈÅ©Âàá„Å´Âà∂ÈôêÔºà‰æãÔºö3:00„Äú8:00/kmÁ®ãÂ∫¶„Å´Âèé„ÇÅ„ÇãÔºâ
                if (sportCategory === 'run') {
                    return {
                        min: Math.max(2.5, minPace), // ÊúÄÈÄü„Åß„ÇÇ2:30/km
                        max: Math.min(10, maxPace)   // ÊúÄÈÅÖ„Åß„ÇÇ10:00/km
                    };
                } else if (sportCategory === 'swim') {
                    // „Çπ„Ç§„É†: „Éá„Éº„Çø„Å´Âü∫„Å•„ÅÑ„Å¶ÁØÑÂõ≤„ÇíË®≠ÂÆöÔºàÂõ∫ÂÆöÂÄ§„Åß„ÅØ„Å™„ÅèÔºâ
                    console.log('„Çπ„Ç§„É†YËª∏Ë®àÁÆó: p5=', formatPaceDebug(p5), 'p95=', formatPaceDebug(p95));
                    return {
                        min: Math.max(60, p5 - padding),   // ÊúÄÈÄü„Åß„ÇÇ1:00/100m„ÄÅ„Åü„Å†„Åó„Éá„Éº„Çø„Å´Âêà„Çè„Åõ„Çã
                        max: Math.min(300, p95 + padding)  // ÊúÄÈÅÖ„Åß„ÇÇ5:00/100m„ÄÅ„Åü„Å†„Åó„Éá„Éº„Çø„Å´Âêà„Çè„Åõ„Çã
                    };
                }
                
                return { min: minPace, max: maxPace };
            }
        }
        
        // „Çπ„Ç§„É†„ÅÆ„Çø„Éº„É≥Âçò‰ΩçÔºà25m/50mÔºâÂπ≥Âùá„Éö„Éº„Çπ„ÇíË®àÁÆó
        function calculateSwimLapPaces(velocityData, distanceData, poolLength = 25) {
            if (!velocityData || !distanceData || velocityData.length === 0) {
                return { labels: [], paces: [] };
            }
            
            // „Éá„Éê„ÉÉ„Ç∞: velocity_smooth„ÅÆÁµ±Ë®à„ÇíÂá∫Âäõ
            const validVelocities = velocityData.filter(v => v > 0);
            console.log('=== „Çπ„Ç§„É†„Éö„Éº„Çπ„Éá„Éê„ÉÉ„Ç∞ ===');
            console.log('velocity_smooth „Çµ„É≥„Éó„É´Êï∞:', velocityData.length);
            console.log('ÊúâÂäπ„Å™ÈÄüÂ∫¶„Éá„Éº„ÇøÊï∞:', validVelocities.length);
            console.log('ÈÄüÂ∫¶ ÊúÄÂ∞èÂÄ§ (m/s):', Math.min(...validVelocities).toFixed(3));
            console.log('ÈÄüÂ∫¶ ÊúÄÂ§ßÂÄ§ (m/s):', Math.max(...validVelocities).toFixed(3));
            console.log('ÈÄüÂ∫¶ Âπ≥ÂùáÂÄ§ (m/s):', (validVelocities.reduce((a,b)=>a+b,0)/validVelocities.length).toFixed(3));
            // „Éö„Éº„ÇπÊèõÁÆó
            const minVel = Math.min(...validVelocities);
            const maxVel = Math.max(...validVelocities);
            console.log('„Éö„Éº„ÇπÊèõÁÆó ÊúÄÈÄü (sec/100m):', (100/maxVel).toFixed(1), '=', formatPaceDebug(100/maxVel));
            console.log('„Éö„Éº„ÇπÊèõÁÆó ÊúÄÈÅÖ (sec/100m):', (100/minVel).toFixed(1), '=', formatPaceDebug(100/minVel));
            
            const labels = [];
            const paces = [];
            
            let currentLapStart = 0;
            let lapNumber = 1;
            
            // ÂêÑ„É©„ÉÉ„Éó„ÅÆÈñãÂßã„ÉªÁµÇ‰∫Ü„Ç§„É≥„Éá„ÉÉ„ÇØ„Çπ„ÇíÁâπÂÆö„Åó„Å¶Âπ≥Âùá„Éö„Éº„Çπ„ÇíË®àÁÆó
            for (let targetDist = poolLength; targetDist <= distanceData[distanceData.length - 1]; targetDist += poolLength) {
                // „Åì„ÅÆ„É©„ÉÉ„Éó„ÅÆÁµÇ‰∫Ü‰ΩçÁΩÆ„ÇíË¶ã„Å§„Åë„Çã
                let lapEnd = currentLapStart;
                while (lapEnd < distanceData.length && distanceData[lapEnd] < targetDist) {
                    lapEnd++;
                }
                
                if (lapEnd <= currentLapStart) {
                    currentLapStart = lapEnd;
                    continue;
                }
                
                // „Åì„ÅÆ„É©„ÉÉ„ÉóÂÜÖ„ÅÆÊúâÂäπ„Å™ÈÄüÂ∫¶„Éá„Éº„Çø„ÇíÂèéÈõÜ
                const lapVelocities = [];
                for (let i = currentLapStart; i < lapEnd; i++) {
                    const vel = velocityData[i];
                    // ÊúâÂäπ„Å™ÈÄüÂ∫¶„ÅÆ„Åø„Çí‰ΩøÁî®Ôºà0.2 m/s = 8:20/100m „Çà„ÇäÈÄü„ÅÑ„ÇÇ„ÅÆÔºâ
                    if (vel && vel > 0.2) {
                        lapVelocities.push(vel);
                    }
                }
                
                if (lapVelocities.length > 0) {
                    // Âπ≥ÂùáÈÄüÂ∫¶„ÇíË®àÁÆó
                    const avgVelocity = lapVelocities.reduce((a, b) => a + b, 0) / lapVelocities.length;
                    // „Éö„Éº„ÇπÔºàÁßí/100mÔºâ„Å´Â§âÊèõ
                    const paceSeconds = 100 / avgVelocity;
                    
                    labels.push(targetDist); // „É©„ÉÉ„ÉóÁµÇ‰∫ÜÂú∞ÁÇπ„ÅÆË∑ùÈõ¢
                    paces.push(paceSeconds);
                    
                    // Áï∞Â∏∏ÂÄ§„ÅÆ„Éá„Éê„ÉÉ„Ç∞
                    if (paceSeconds < 90 || paceSeconds > 200) {
                        console.log(`„É©„ÉÉ„Éó${lapNumber} (${targetDist}m): Áï∞Â∏∏„Éö„Éº„Çπ ${formatPaceDebug(paceSeconds)}, Âπ≥ÂùáÈÄüÂ∫¶=${avgVelocity.toFixed(3)}m/s, „Çµ„É≥„Éó„É´Êï∞=${lapVelocities.length}`);
                    }
                }
                
                currentLapStart = lapEnd;
                lapNumber++;
            }
            
            console.log('Ë®àÁÆó„Åï„Çå„Åü„É©„ÉÉ„ÉóÊï∞:', paces.length);
            console.log('„Éö„Éº„ÇπÁØÑÂõ≤:', formatPaceDebug(Math.min(...paces)), '„Äú', formatPaceDebug(Math.max(...paces)));
            console.log('=========================');
            
            return { labels, paces };
        }
        
        // „Éá„Éê„ÉÉ„Ç∞Áî®„Éö„Éº„Çπ„Éï„Ç©„Éº„Éû„ÉÉ„Éà
        function formatPaceDebug(seconds) {
            const min = Math.floor(seconds / 60);
            const sec = Math.round(seconds % 60);
            return `${min}:${String(sec).padStart(2, '0')}/100m`;
        }
        
        // „Éó„Éº„É´Èï∑„ÇíÊé®ÂÆöÔºà„Ç¢„ÇØ„ÉÜ„Ç£„Éì„ÉÜ„Ç£„Éá„Éº„Çø„Åæ„Åü„ÅØ„Éá„Éï„Ç©„É´„ÉàÂÄ§„Åã„ÇâÔºâ
        function detectPoolLength() {
            // Strava„Ç¢„ÇØ„ÉÜ„Ç£„Éì„ÉÜ„Ç£„Åã„Çâ„Éó„Éº„É´Èï∑„ÇíÂèñÂæóÔºàpool_length„Éï„Ç£„Éº„É´„Éâ„Åå„ÅÇ„ÇãÂ†¥ÂêàÔºâ
            if (currentActivity.pool_length) {
                return currentActivity.pool_length;
            }
            // Ë∑ùÈõ¢„Åã„ÇâÊé®Ê∏¨Ôºà25m„Éó„Éº„É´„Åã50m„Éó„Éº„É´„ÅãÔºâ
            // ÈÄöÂ∏∏„ÄÅ25m„Éó„Éº„É´„ÅåÂ§ö„ÅÑ„ÅÆ„Åß„Éá„Éï„Ç©„É´„Éà„ÅØ25m
            return 25;
        }
        
        function renderSportSpecificCharts() {
            const sportCategory = getSportCategory(currentActivity.sport_type || currentActivity.type);
            
            if (sportCategory === 'bike') {
                renderBikeCharts();
            } else if (sportCategory === 'run') {
                renderRunCharts();
            }
        }
        
        function renderBikeCharts() {
            // „Éë„ÉØ„Éº„ÉÅ„É£„Éº„Éà
            if (streamData && streamData.watts && streamData.watts.data) {
                // „Éë„ÉØ„Éº„É°„Éà„É™„ÇØ„Çπ
                const avgPower = currentActivity.average_watts || 0;
                const np = currentActivity.weighted_average_watts || 0;
                document.getElementById('powerMetrics').innerHTML = `
                    <div class="sport-metric-item">
                        <div class="sport-metric-value">${Math.round(avgPower)}</div>
                        <div class="sport-metric-label">Âπ≥Âùá„Éë„ÉØ„Éº (W)</div>
                    </div>
                    <div class="sport-metric-item">
                        <div class="sport-metric-value">${Math.round(np)}</div>
                        <div class="sport-metric-label">NP (W)</div>
                    </div>
                `;
                
                renderTimeSeriesChart('powerChart', streamData.watts.data, '„Éë„ÉØ„Éº', '#8b5cf6', 'W', 'power');
            }
            
            // „Ç±„Ç§„Éá„É≥„Çπ„ÉÅ„É£„Éº„Éà
            if (streamData && streamData.cadence && streamData.cadence.data) {
                const avgCadence = currentActivity.average_cadence || 0;
                document.getElementById('cadenceMetrics').innerHTML = `
                    <div class="sport-metric-item">
                        <div class="sport-metric-value">${Math.round(avgCadence)}</div>
                        <div class="sport-metric-label">Âπ≥Âùá„Ç±„Ç§„Éá„É≥„Çπ (rpm)</div>
                    </div>
                `;
                
                renderTimeSeriesChart('cadenceChart', streamData.cadence.data, '„Ç±„Ç§„Éá„É≥„Çπ', '#22c55e', 'rpm', 'cadence');
            }
        }
        
        function renderRunCharts() {
            // „Éî„ÉÉ„ÉÅ/„Ç±„Ç§„Éá„É≥„Çπ„ÉÅ„É£„Éº„Éà
            if (streamData && streamData.cadence && streamData.cadence.data) {
                const avgCadence = currentActivity.average_cadence || 0;
                document.getElementById('cadenceMetrics').innerHTML = `
                    <div class="sport-metric-item">
                        <div class="sport-metric-value">${Math.round(avgCadence * 2)}</div>
                        <div class="sport-metric-label">Âπ≥Âùá„Éî„ÉÉ„ÉÅ (spm)</div>
                    </div>
                `;
                
                // „É©„É≥„ÅÆÂ†¥Âêà„ÅØ„Ç±„Ç§„Éá„É≥„Çπ„Çí2ÂÄçÔºàÂ∑¶Âè≥ÂêàË®àÔºâ
                const pitchData = streamData.cadence.data.map(c => c * 2);
                renderTimeSeriesChart('cadenceChart', pitchData, '„Éî„ÉÉ„ÉÅ', '#22c55e', 'spm', 'cadence');
            }
        }
        
        function renderTimeSeriesChart(canvasId, data, label, color, unit, chartKey) {
            const ctx = document.getElementById(canvasId).getContext('2d');
            if (charts[chartKey]) charts[chartKey].destroy();
            
            const sportCategory = getSportCategory(currentActivity.sport_type || currentActivity.type);
            const distanceData = streamData?.distance?.data;
            const timeData = streamData?.time?.data || data.map((_, i) => i);
            
            const maxPoints = 500;
            const step = Math.max(1, Math.floor(data.length / maxPoints));
            
            const labels = [];
            const chartData = [];
            const validValues = []; // YËª∏ÁØÑÂõ≤Ë®àÁÆóÁî®
            
            // „Éî„ÉÉ„ÉÅ/„Ç±„Ç§„Éá„É≥„Çπ„ÅÆÊúâÂäπÁØÑÂõ≤„ÇíÂÆöÁæ©
            const isRunPitch = chartKey === 'cadence' && sportCategory === 'run';
            const isBikeCadence = chartKey === 'cadence' && sportCategory === 'bike';
            const isPower = chartKey === 'power';
            
            // ÊúâÂäπÂÄ§„ÅÆÁØÑÂõ≤
            let minValid = 0, maxValid = Infinity;
            if (isRunPitch) {
                minValid = 120; // ÊúÄ‰Ωé120spm
                maxValid = 240; // ÊúÄÈ´ò240spm
            } else if (isBikeCadence) {
                minValid = 30;  // ÊúÄ‰Ωé30rpm
                maxValid = 150; // ÊúÄÈ´ò150rpm
            } else if (isPower) {
                minValid = 0;
                maxValid = 2000;
            }
            
            for (let i = 0; i < data.length; i += step) {
                if (distanceData) {
                    if (sportCategory === 'swim') {
                        labels.push(Math.round(distanceData[i]));
                    } else {
                        labels.push((distanceData[i] / 1000).toFixed(1));
                    }
                } else {
                    labels.push(formatDurationShort(timeData[i]));
                }
                
                const value = data[i];
                chartData.push(value);
                
                // YËª∏ÁØÑÂõ≤Ë®àÁÆóÁî®„Å´ÊúâÂäπÂÄ§„ÇíÂèéÈõÜ
                if (value >= minValid && value <= maxValid) {
                    validValues.push(value);
                }
            }
            
            // YËª∏ÁØÑÂõ≤„Çí„Éë„Éº„Çª„É≥„Çø„Ç§„É´„Éô„Éº„Çπ„ÅßË®àÁÆó
            let yMin, yMax;
            if (validValues.length > 0) {
                const sorted = [...validValues].sort((a, b) => a - b);
                const p5 = sorted[Math.floor(sorted.length * 0.05)];
                const p95 = sorted[Math.floor(sorted.length * 0.95)];
                const range = p95 - p5;
                const padding = range * 0.1;
                
                yMin = Math.max(minValid, Math.floor(p5 - padding));
                yMax = Math.min(maxValid, Math.ceil(p95 + padding));
            }
            
            charts[chartKey] = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: labels,
                    datasets: [{
                        label: label,
                        data: chartData,
                        borderColor: color,
                        borderWidth: 1.5,
                        fill: false,
                        tension: 0.2,
                        pointRadius: 0
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: { legend: { display: false } },
                    scales: {
                        x: { 
                            title: { display: true, text: distanceData ? (sportCategory === 'swim' ? 'Ë∑ùÈõ¢ (m)' : 'Ë∑ùÈõ¢ (km)') : 'ÊôÇÈñì' },
                            ticks: {
                                maxTicksLimit: sportCategory === 'swim' ? 10 : 12,
                                callback: function(value, index) {
                                    const label = this.getLabelForValue(value);
                                    if (sportCategory === 'swim' && distanceData) {
                                        const dist = parseFloat(label);
                                        if (dist % 200 === 0 || index === 0) {
                                            return label;
                                        }
                                        return '';
                                    }
                                    return label;
                                }
                            }
                        },
                        y: { 
                            title: { display: true, text: unit },
                            min: yMin,
                            max: yMax
                        }
                    },
                    interaction: {
                        intersect: false,
                        mode: 'index'
                    }
                }
            });
        }
        
        function renderLapTable() {
            if (!currentActivity.laps || currentActivity.laps.length === 0) {
                return;
            }
            
            document.getElementById('lapSection').style.display = 'block';
            const sportCategory = getSportCategory(currentActivity.sport_type || currentActivity.type);
            
            // „Çπ„Ç§„É†„ÅÆÂ†¥Âêà„ÅØ„É©„ÉÉ„Éó„Éá„Éº„Çø„ÅÆË©≥Á¥∞„Çí„Éá„Éê„ÉÉ„Ç∞Âá∫Âäõ
            if (sportCategory === 'swim') {
                console.log('=== „Çπ„Ç§„É†„É©„ÉÉ„Éó„Éá„Éº„Çø (FORM/Strava„Åã„Çâ) ===');
                console.log('„É©„ÉÉ„ÉóÊï∞:', currentActivity.laps.length);
                currentActivity.laps.forEach((lap, i) => {
                    console.log(`Lap ${i+1}:`, {
                        distance: lap.distance,
                        elapsed_time: lap.elapsed_time,
                        moving_time: lap.moving_time,
                        average_speed: lap.average_speed,
                        average_cadence: lap.average_cadence,
                        total_strokes: lap.total_strokes,
                        average_heartrate: lap.average_heartrate,
                        lap_index: lap.lap_index,
                        start_index: lap.start_index,
                        end_index: lap.end_index,
                        // ÂÖ®„Éï„Ç£„Éº„É´„Éâ„ÇíÂá∫Âäõ
                        raw: lap
                    });
                });
                console.log('========================================');
            }
            
            let html = `
                <thead>
                    <tr>
                        <th>Lap</th>
                        <th>Ë∑ùÈõ¢</th>
                        <th>ÊôÇÈñì</th>
                        <th>${sportCategory === 'bike' ? 'ÈÄüÂ∫¶' : '„Éö„Éº„Çπ'}</th>
                        <th>ÂøÉÊãç</th>
                        ${sportCategory === 'bike' ? '<th>„Éë„ÉØ„Éº</th>' : ''}
                        ${sportCategory === 'swim' ? '<th>„Çπ„Éà„É≠„Éº„ÇØ</th><th>„Ç±„Ç§„Éá„É≥„Çπ</th>' : ''}
                    </tr>
                </thead>
                <tbody>
            `;
            
            currentActivity.laps.forEach((lap, index) => {
                let pace, distance;
                
                if (sportCategory === 'bike') {
                    pace = `${(lap.average_speed * 3.6).toFixed(1)} km/h`;
                    distance = `${(lap.distance / 1000).toFixed(2)} km`;
                } else if (sportCategory === 'swim') {
                    // „Çπ„Ç§„É†: „Éö„Éº„Çπ„ÇíÁßí/100m„ÅßË°®Á§∫
                    let paceSeconds = null;
                    const movingTime = lap.moving_time || 0;
                    
                    if (lap.average_speed && lap.average_speed > 0) {
                        paceSeconds = 100 / lap.average_speed;
                    } else if (movingTime > 0 && lap.distance > 0) {
                        paceSeconds = (movingTime / lap.distance) * 100;
                    }
                    
                    // „É¨„Çπ„ÉàÂà§ÂÆö: 10ÁßíÊú™Ê∫Ä or Áï∞Â∏∏„Å´ÈÄü„ÅÑ„Éö„Éº„Çπ(60Áßí/100mÊú™Ê∫Ä) or Áï∞Â∏∏„Å´ÈÅÖ„ÅÑ„Éö„Éº„Çπ(300Áßí/100mË∂Ö)
                    const isRest = movingTime < 10 || 
                                   (paceSeconds && paceSeconds < 60) || 
                                   (paceSeconds && paceSeconds > 300) ||
                                   !paceSeconds;
                    
                    if (isRest) {
                        pace = '<span style="color: #9ca3af;">REST</span>';
                    } else {
                        pace = formatPaceDebug(paceSeconds);
                    }
                    distance = `${Math.round(lap.distance)}m`;
                } else {
                    pace = formatRunPace(lap.average_speed);
                    distance = `${(lap.distance / 1000).toFixed(2)} km`;
                }
                
                html += `
                    <tr>
                        <td>${index + 1}</td>
                        <td>${distance}</td>
                        <td>${formatDuration(lap.moving_time || lap.elapsed_time)}</td>
                        <td>${pace}</td>
                        <td>${lap.average_heartrate ? Math.round(lap.average_heartrate) : '-'}</td>
                        ${sportCategory === 'bike' ? `<td>${lap.average_watts ? Math.round(lap.average_watts) : '-'} W</td>` : ''}
                        ${sportCategory === 'swim' ? `<td>${lap.total_strokes || '-'}</td><td>${lap.average_cadence ? Math.round(lap.average_cadence) : '-'}</td>` : ''}
                    </tr>
                `;
            });
            
            html += '</tbody>';
            document.getElementById('lapTable').innerHTML = html;
        }
        
        // ===== „Çπ„Éà„É™„Éº„É†„Éá„Éº„ÇøÂàÜÊûê =====
        function analyzeStreamData() {
            if (!streamData) return null;
            
            const analysis = {};
            const sportCategory = getSportCategory(currentActivity.sport_type || currentActivity.type);
            
            // „Éö„Éº„ÇπÂàÜÊûê
            if (streamData.velocity_smooth && streamData.velocity_smooth.data && streamData.distance?.data) {
                const velData = streamData.velocity_smooth.data;
                const distData = streamData.distance.data;
                const totalDist = distData[distData.length - 1];
                const halfDist = totalDist / 2;
                
                // ÂâçÂçä„ÉªÂæåÂçä„ÅÆ„Éö„Éº„Çπ„ÇíË®àÁÆó
                let firstHalfVels = [];
                let secondHalfVels = [];
                
                for (let i = 0; i < velData.length; i++) {
                    if (velData[i] > 0.5) { // ÂÅúÊ≠¢„ÇíÈô§Â§ñ
                        if (distData[i] <= halfDist) {
                            firstHalfVels.push(velData[i]);
                        } else {
                            secondHalfVels.push(velData[i]);
                        }
                    }
                }
                
                const avgFirstHalf = firstHalfVels.length > 0 ? firstHalfVels.reduce((a, b) => a + b, 0) / firstHalfVels.length : 0;
                const avgSecondHalf = secondHalfVels.length > 0 ? secondHalfVels.reduce((a, b) => a + b, 0) / secondHalfVels.length : 0;
                
                // „Éö„Éº„ÇπÂ§âÂãï‰øÇÊï∞
                const validVels = velData.filter(v => v > 0.5);
                const meanVel = validVels.reduce((a, b) => a + b, 0) / validVels.length;
                const variance = validVels.reduce((sum, v) => sum + Math.pow(v - meanVel, 2), 0) / validVels.length;
                const stdDev = Math.sqrt(variance);
                const cv = (stdDev / meanVel) * 100;
                
                // „Çπ„Éó„É™„ÉÉ„Éà„Çø„Ç§„Éó
                const splitDiff = ((avgSecondHalf / avgFirstHalf) - 1) * 100;
                let splitType = 'ÂùáÁ≠â';
                if (splitDiff > 3) splitType = '„Éç„Ç¨„ÉÜ„Ç£„ÉñÔºàÂæåÂçä„Éö„Éº„Çπ„Ç¢„ÉÉ„ÉóÔºâ';
                else if (splitDiff < -3) splitType = '„Éù„Ç∏„ÉÜ„Ç£„ÉñÔºàÂæåÂçä„Éö„Éº„Çπ„ÉÄ„Ç¶„É≥Ôºâ';
                
                analysis.paceAnalysis = {
                    firstHalfPace: formatPaceFromSpeed(avgFirstHalf, sportCategory),
                    secondHalfPace: formatPaceFromSpeed(avgSecondHalf, sportCategory),
                    splitType: splitType,
                    splitDiff: `${splitDiff > 0 ? '+' : ''}${splitDiff.toFixed(1)}%`,
                    variability: cv.toFixed(1)
                };
                
                // ÊúÄÈÄü„ÉªÊúÄÈÅÖÂå∫ÈñìÔºà1kmÂçò‰Ωç„ÅßÂàÜÊûêÔºâ
                if (sportCategory !== 'swim') {
                    const kmSections = [];
                    let currentKm = 1000;
                    let sectionVels = [];
                    
                    for (let i = 0; i < distData.length; i++) {
                        if (distData[i] <= currentKm) {
                            if (velData[i] > 0.5) sectionVels.push(velData[i]);
                        } else {
                            if (sectionVels.length > 0) {
                                const avgVel = sectionVels.reduce((a, b) => a + b, 0) / sectionVels.length;
                                kmSections.push({ km: Math.floor(currentKm / 1000), pace: avgVel });
                            }
                            currentKm += 1000;
                            sectionVels = [velData[i]];
                        }
                    }
                    
                    if (kmSections.length > 0) {
                        const fastest = kmSections.reduce((max, s) => s.pace > max.pace ? s : max);
                        const slowest = kmSections.reduce((min, s) => s.pace < min.pace ? s : min);
                        analysis.paceAnalysis.fastestSection = `${fastest.km}kmÁõÆ (${formatPaceFromSpeed(fastest.pace, sportCategory)})`;
                        analysis.paceAnalysis.slowestSection = `${slowest.km}kmÁõÆ (${formatPaceFromSpeed(slowest.pace, sportCategory)})`;
                    }
                }
            }
            
            // ÂøÉÊãçÂàÜÊûê
            if (streamData.heartrate && streamData.heartrate.data) {
                const hrData = streamData.heartrate.data;
                const validHr = hrData.filter(h => h > 0);
                
                if (validHr.length > 0) {
                    const thresholds = getUserThresholds();
                    const maxHr = thresholds.maxHr || 190;
                    
                    // ÂâçÂçä„ÉªÂæåÂçä„ÅÆÂøÉÊãçÊØîËºÉÔºà„Éâ„É™„Éï„ÉàÔºâ
                    const midPoint = Math.floor(validHr.length / 2);
                    const firstHalfHr = validHr.slice(0, midPoint);
                    const secondHalfHr = validHr.slice(midPoint);
                    
                    const avgFirstHr = firstHalfHr.reduce((a, b) => a + b, 0) / firstHalfHr.length;
                    const avgSecondHr = secondHalfHr.reduce((a, b) => a + b, 0) / secondHalfHr.length;
                    const drift = ((avgSecondHr / avgFirstHr) - 1) * 100;
                    
                    // ZoneÂàÜÂ∏É
                    const zones = { z1: 0, z2: 0, z3: 0, z4: 0, z5: 0 };
                    validHr.forEach(hr => {
                        const percent = (hr / maxHr) * 100;
                        if (percent < 60) zones.z1++;
                        else if (percent < 70) zones.z2++;
                        else if (percent < 80) zones.z3++;
                        else if (percent < 90) zones.z4++;
                        else zones.z5++;
                    });
                    
                    const total = validHr.length;
                    Object.keys(zones).forEach(z => {
                        zones[z] = Math.round((zones[z] / total) * 100);
                    });
                    
                    // ÂøÉÊãçÂäπÁéáÔºà„Éö„Éº„Çπ„Åå„ÅÇ„ÇãÂ†¥ÂêàÔºâ
                    let efficiency = null;
                    if (currentActivity.average_speed && currentActivity.average_heartrate) {
                        // ÂøÉÊãç1bpm„ÅÇ„Åü„Çä„ÅÆ„Éö„Éº„ÇπÔºàÊï∞ÂÄ§„ÅåÂ∞è„Åï„ÅÑ„Åª„Å©ÂäπÁéáÁöÑÔºâ
                        const pacePerKm = 1000 / currentActivity.average_speed / 60;
                        efficiency = (currentActivity.average_heartrate / pacePerKm).toFixed(1);
                    }
                    
                    analysis.heartRateAnalysis = {
                        drift: drift.toFixed(1),
                        zones: zones,
                        efficiency: efficiency
                    };
                }
            }
            
            // Ê®ôÈ´òÂàÜÊûê
            if (streamData.altitude && streamData.altitude.data && streamData.velocity_smooth?.data) {
                const altData = streamData.altitude.data;
                const velData = streamData.velocity_smooth.data;
                const gradeData = streamData.grade_smooth?.data;
                
                if (gradeData) {
                    // Áôª„Çä„ÉªÂπ≥Âú∞„Éª‰∏ã„Çä„Åß„ÅÆ„Éö„Éº„ÇπÊØîËºÉ
                    const climbVels = [];
                    const flatVels = [];
                    const descentVels = [];
                    
                    for (let i = 0; i < gradeData.length; i++) {
                        if (velData[i] > 0.5) {
                            if (gradeData[i] > 2) climbVels.push(velData[i]);
                            else if (gradeData[i] < -2) descentVels.push(velData[i]);
                            else flatVels.push(velData[i]);
                        }
                    }
                    
                    if (climbVels.length > 0 && flatVels.length > 0) {
                        const avgClimb = climbVels.reduce((a, b) => a + b, 0) / climbVels.length;
                        const avgFlat = flatVels.reduce((a, b) => a + b, 0) / flatVels.length;
                        const climbLoss = ((avgFlat / avgClimb) - 1) * 100;
                        
                        analysis.elevationAnalysis = {
                            climbingPaceLoss: climbLoss.toFixed(0)
                        };
                    }
                }
            }
            
            return Object.keys(analysis).length > 0 ? analysis : null;
        }
        
        function formatPaceFromSpeed(speed, sportCategory) {
            if (!speed || speed <= 0) return '-';
            if (sportCategory === 'bike') {
                return `${(speed * 3.6).toFixed(1)} km/h`;
            } else if (sportCategory === 'swim') {
                const pace = 100 / speed;
                const min = Math.floor(pace / 60);
                const sec = Math.round(pace % 60);
                return `${min}:${String(sec).padStart(2, '0')}/100m`;
            } else {
                const pace = 1000 / speed / 60;
                const min = Math.floor(pace);
                const sec = Math.round((pace - min) * 60);
                return `${min}:${String(sec).padStart(2, '0')}/km`;
            }
        }
        
        // ===== È°û‰ºº„Ç¢„ÇØ„ÉÜ„Ç£„Éì„ÉÜ„Ç£Ê§úÁ¥¢ =====
        function findSimilarActivities() {
            const cachedActivities = localStorage.getItem('strava_activities');
            if (!cachedActivities) return [];
            
            const activities = JSON.parse(cachedActivities);
            const currentSport = currentActivity.sport_type || currentActivity.type;
            const currentDist = currentActivity.distance || 0;
            const currentId = currentActivity.id;
            
            // Âêå„ÅòÁ®ÆÁõÆ„ÄÅË∑ùÈõ¢„Åå¬±30%‰ª•ÂÜÖ„ÅÆ„Ç¢„ÇØ„ÉÜ„Ç£„Éì„ÉÜ„Ç£„ÇíÊ§úÁ¥¢
            const similar = activities.filter(a => {
                if (a.id === currentId) return false;
                const sport = a.sport_type || a.type;
                if (sport !== currentSport) return false;
                
                const dist = a.distance || 0;
                const ratio = dist / currentDist;
                return ratio >= 0.7 && ratio <= 1.3;
            });
            
            // Êó•‰ªò„ÅßÈôçÈ†Ü„ÇΩ„Éº„Éà„ÄÅÊúÄÊñ∞3‰ª∂„ÇíËøî„Åô
            similar.sort((a, b) => new Date(b.start_date) - new Date(a.start_date));
            return similar.slice(0, 5);
        }
        
        // ===== AI„Ç≥„É°„É≥„Éà =====
        let conversationHistory = [];
        
        async function fetchAIComment(userQuestion = null) {
            const loadingEl = document.getElementById('aiCommentLoading');
            const commentEl = document.getElementById('aiComment');
            
            if (!userQuestion) {
                loadingEl.style.display = 'flex';
                commentEl.style.display = 'none';
            }
            
            try {
                // „Çπ„Éà„É™„Éº„É†ÂàÜÊûê„Éá„Éº„Çø„ÇíË®àÁÆó
                const streamAnalysis = analyzeStreamData();
                
                // È°û‰ºº„Ç¢„ÇØ„ÉÜ„Ç£„Éì„ÉÜ„Ç£„ÇíÊ§úÁ¥¢
                const similarActivities = findSimilarActivities();
                
                const response = await fetch('/.netlify/functions/ai-coach-comment', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        activity: currentActivity,
                        trainingStatus: trainingStatus,
                        streamAnalysis: streamAnalysis,
                        similarActivities: similarActivities,
                        userQuestion: userQuestion,
                        conversationHistory: userQuestion ? conversationHistory : []
                    })
                });
                
                if (!response.ok) {
                    throw new Error('AI„Ç≥„É°„É≥„Éà„ÅÆÂèñÂæó„Å´Â§±Êïó„Åó„Åæ„Åó„Åü');
                }
                
                const data = await response.json();
                
                if (userQuestion) {
                    // ‰ºöË©±Â±•Ê≠¥„ÇíÊõ¥Êñ∞
                    conversationHistory.push({ role: 'user', content: userQuestion });
                    conversationHistory.push({ role: 'assistant', content: data.comment });
                    
                    // Ë≥™Âïè„Å∏„ÅÆÂõûÁ≠î„ÇíÂ±•Ê≠¥„Å´ËøΩÂä†
                    addChatMessage('coach', data.comment);
                } else {
                    // ÂàùÊúü„Ç≥„É°„É≥„Éà
                    commentEl.innerHTML = formatAIComment(data.comment);
                    loadingEl.style.display = 'none';
                    commentEl.style.display = 'block';
                }
                
            } catch (error) {
                console.error('AI comment error:', error);
                
                if (!userQuestion) {
                    commentEl.innerHTML = formatAIComment(generateFallbackComment());
                    loadingEl.style.display = 'none';
                    commentEl.style.display = 'block';
                } else {
                    addChatMessage('coach', 'Áî≥„ÅóË®≥„ÅÇ„Çä„Åæ„Åõ„Çì„ÄÅÂõûÁ≠î„ÅÆÁîüÊàê„Å´Â§±Êïó„Åó„Åæ„Åó„Åü„ÄÇ„Åó„Å∞„Çâ„Åè„Åó„Å¶„Åã„Çâ„ÅäË©¶„Åó„Åè„Å†„Åï„ÅÑ„ÄÇ');
                }
            }
        }
        
        // AI„Ç≥„É°„É≥„Éà„ÅÆMarkdown„ÇíÊï¥ÂΩ¢
        function formatAIComment(text) {
            // ÊîπË°å„ÇíÁ∂≠ÊåÅ„Åó„Å§„Å§„ÄÅ**Â§™Â≠ó**„Çí<strong>„Å´Â§âÊèõ
            return text
                .replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>')
                .replace(/\n/g, '<br>');
        }
        
        function generateFallbackComment() {
            const sportType = currentActivity.sport_type || currentActivity.type;
            const sportCategory = getSportCategory(sportType);
            const distance = currentActivity.distance ? (currentActivity.distance / 1000).toFixed(1) : '0';
            const tss = currentActivity.tss || 0;
            const avgHr = currentActivity.average_heartrate;
            const duration = (currentActivity.moving_time || 0) / 60;
            
            let comment = `üèÉ **„Çª„ÉÉ„Ç∑„Éß„É≥Á∑èË©ï**\n`;
            comment += `${distance}km„ÅÆ${getSportLabel(sportType)}„Éà„É¨„Éº„Éã„É≥„Ç∞„ÄÅ„ÅäÁñ≤„Çå„Åï„Åæ„Åß„Åó„ÅüÔºÅ`;
            
            // ÊôÇÈñì„Å´Âü∫„Å•„Åè„Ç≥„É°„É≥„Éà
            if (duration > 120) {
                comment += `${Math.round(duration)}ÂàÜ„Å®„ÅÑ„ÅÜÈï∑ÊôÇÈñì„ÅÆ„Çª„ÉÉ„Ç∑„Éß„É≥„Çí„ÇÑ„ÇäÈÅÇ„Åí„Åü„Åì„Å®„ÅØÁ¥†Êô¥„Çâ„Åó„ÅÑ„Åß„Åô„ÄÇ`;
            } else if (duration > 60) {
                comment += `1ÊôÇÈñì‰ª•‰∏ä„ÅÆ„Åó„Å£„Åã„Çä„Å®„Åó„Åü„Éà„É¨„Éº„Éã„É≥„Ç∞„Åß„Åó„Åü„Å≠„ÄÇ`;
            }
            
            // TSSÂü∫„Å•„ÅèÂº∑Â∫¶Ë©ï‰æ°
            comment += `\n\nüí™ **Âº∑Â∫¶„Å®ÂäπÊûú**\n`;
            if (tss > 150) {
                comment += `TSS ${tss}„ÅØÈ´òÂº∑Â∫¶„Çª„ÉÉ„Ç∑„Éß„É≥„Åß„Åô„ÄÇÂøÉËÇ∫Ê©üËÉΩ„Å®‰π≥ÈÖ∏ÈñæÂÄ§„ÅÆÂêë‰∏ä„Å´Â§ß„Åç„ÅèË≤¢ÁåÆ„Åô„Çã„Éà„É¨„Éº„Éã„É≥„Ç∞„Åß„Åó„Åü„ÄÇ`;
            } else if (tss > 80) {
                comment += `TSS ${tss}„ÅØÈÅ©Â∫¶„Å™Ë≤†Ëç∑„Åß„ÄÅÊúâÈÖ∏Á¥†„Éô„Éº„Çπ„ÅÆÊßãÁØâ„Å´ÂäπÊûúÁöÑ„Å™„Çª„ÉÉ„Ç∑„Éß„É≥„Åß„Åó„Åü„ÄÇ`;
            } else {
                comment += `TSS ${tss}„ÅØ‰Ωé„Äú‰∏≠Âº∑Â∫¶„Åß„ÄÅÂõûÂæ©„Çí‰øÉ„Åó„Å™„Åå„Çâ„Éï„Ç£„ÉÉ„Éà„Éç„Çπ„ÇíÁ∂≠ÊåÅ„Åô„ÇãËâØ„ÅÑ„Çª„ÉÉ„Ç∑„Éß„É≥„Åß„Åó„Åü„ÄÇ`;
            }
            
            // ÂøÉÊãçÊï∞„Å´Âü∫„Å•„Åè„Ç≥„É°„É≥„Éà
            if (avgHr) {
                const hr = Math.round(avgHr);
                comment += `\n\nüíì **ÂøÉÊãçÂàÜÊûê**\n`;
                if (hr < 140) {
                    comment += `Âπ≥ÂùáÂøÉÊãç${hr}bpm„ÅØÊúâÈÖ∏Á¥†„Çæ„Éº„É≥ÔºàZone 1-2Ôºâ„Åß„ÅÆ„Éà„É¨„Éº„Éã„É≥„Ç∞„Åß„Åô„ÄÇ„Éü„Éà„Ç≥„É≥„Éâ„É™„Ç¢„ÅÆÂ¢óÂä†„Å®ËÑÇËÇ™ÁáÉÁÑºÂäπÁéá„ÅÆÂêë‰∏ä„ÅåÊúüÂæÖ„Åß„Åç„Åæ„Åô„ÄÇ`;
                } else if (hr < 160) {
                    comment += `Âπ≥ÂùáÂøÉÊãç${hr}bpm„ÅØ‰∏≠Âº∑Â∫¶„Çæ„Éº„É≥ÔºàZone 3Ôºâ‰ªòËøë„Åß„Åô„ÄÇÊåÅ‰πÖÂäõ„ÅÆÂü∫Áõ§ÊßãÁØâ„Å®‰π≥ÈÖ∏Âá¶ÁêÜËÉΩÂäõ„ÅÆÂêë‰∏ä„Å´ÂäπÊûúÁöÑ„Åß„Åô„ÄÇ`;
                } else {
                    comment += `Âπ≥ÂùáÂøÉÊãç${hr}bpm„ÅØÈ´òÂº∑Â∫¶„Çæ„Éº„É≥ÔºàZone 4-5Ôºâ„Åß„Åô„ÄÇVO2max„ÅÆÂêë‰∏ä„Å®È´òÂº∑Â∫¶„Å∏„ÅÆËÄêÊÄßÊßãÁØâ„Å´Ë≤¢ÁåÆ„Åó„Åæ„Åô„ÄÇ`;
                }
            }
            
            // Á®ÆÁõÆÂà•„Ç≥„É°„É≥„Éà
            comment += `\n\nüéØ **Á®ÆÁõÆÂà•„Éù„Ç§„É≥„Éà**\n`;
            if (sportCategory === 'swim') {
                comment += `„Çπ„Ç§„É†„ÅØÂÖ®Ë∫´„ÅÆÁ≠ãÁæ§„Çí‰ΩøÁî®„Åó„ÄÅÈñ¢ÁØÄ„Å∏„ÅÆË≤†ÊãÖ„ÅåÂ∞ë„Å™„ÅÑÁä∂ÊÖã„ÅßÂøÉËÇ∫Ê©üËÉΩ„ÇíÂêë‰∏ä„Åï„Åõ„ÇãÂÑ™„Çå„Åü„Éà„É¨„Éº„Éã„É≥„Ç∞„Åß„Åô„ÄÇ`;
            } else if (sportCategory === 'bike') {
                comment += `„Éê„Ç§„ÇØ„Éà„É¨„Éº„Éã„É≥„Ç∞„ÅØ‰∏ãËÇ¢„ÅÆÁ≠ãÊåÅ‰πÖÂäõ„Å®ÂøÉË°ÄÁÆ°Á≥ª„ÅÆÂº∑Âåñ„Å´ÂÑ™„Çå„Å¶„ÅÑ„Åæ„Åô„ÄÇ„Éö„ÉÄ„É™„É≥„Ç∞ÂäπÁéá„ÇíÊÑèË≠ò„Åô„Çã„Åì„Å®„Åß„ÄÅ„Åï„Çâ„Å´ÂäπÊûú„ÅåÈ´ò„Åæ„Çä„Åæ„Åô„ÄÇ`;
            } else if (sportCategory === 'run') {
                comment += `„É©„É≥„Éã„É≥„Ç∞„ÅØÈ™®ÂØÜÂ∫¶„ÅÆÂêë‰∏ä„Å®‰∏ãËÇ¢Á≠ãÂäõ„ÅÆÂº∑Âåñ„Å´ÂäπÊûúÁöÑ„Åß„Åô„ÄÇÁùÄÂú∞Ë°ùÊíÉ„Å´„Çà„ÇãÈÅ©Âøú„ÅØ„ÄÅÈ™®Ê†ºÁ≥ª„ÅÆÂº∑Âåñ„Å´„ÇÇ„Å§„Å™„Åå„Çä„Åæ„Åô„ÄÇ`;
            }
            
            // ÂõûÂæ©„Ç¢„Éâ„Éê„Ç§„Çπ
            comment += `\n\nüîÑ **„É™„Ç´„Éê„É™„Éº„Å®Ê¨°„ÅÆ„Çπ„ÉÜ„ÉÉ„Éó**\n`;
            if (tss > 150) {
                comment += `„Åì„ÅÆ„Çª„ÉÉ„Ç∑„Éß„É≥Âæå„ÅØ24-48ÊôÇÈñì„ÅÆÂõûÂæ©„ÇíÊé®Â•®„Åó„Åæ„Åô„ÄÇÊòéÊó•„ÅØÂÆåÂÖ®‰ºëÈ§ä„Åã„ÄÅËªΩ„ÅÑ„É™„Ç´„Éê„É™„Éº„Çπ„Ç§„É†/„Ç¶„Ç©„Éº„Ç≠„É≥„Ç∞„Å´„Å®„Å©„ÇÅ„Åæ„Åó„Çá„ÅÜ„ÄÇ`;
            } else if (tss > 80) {
                comment += `ÊòéÊó•„ÅØËªΩ„ÇÅ„ÅÆ„É™„Ç´„Éê„É™„Éº„Çª„ÉÉ„Ç∑„Éß„É≥„ÅåËâØ„ÅÑ„Åß„Åó„Çá„ÅÜ„ÄÇZone 1-2„Åß„ÅÆ30-45ÂàÜÁ®ãÂ∫¶„ÅÆËªΩ„ÅÑÈÅãÂãï„ÅßË°ÄÊµÅ„Çí‰øÉÈÄ≤„Åó„Åæ„Åó„Çá„ÅÜ„ÄÇ`;
            } else {
                comment += `ÊòéÊó•„ÇÇÈÄöÂ∏∏ÈÄö„Çä„Éà„É¨„Éº„Éã„É≥„Ç∞„ÇíÁ∂ôÁ∂ö„Åß„Åç„Åæ„Åô„ÄÇË≥™„ÅÆÈ´ò„ÅÑ„Çª„ÉÉ„Ç∑„Éß„É≥„Å´ÊåëÊà¶„Åô„Çã„ÅÆ„ÇÇËâØ„ÅÑ„Çø„Ç§„Éü„É≥„Ç∞„Åß„Åô„ÄÇ`;
            }
            
            // „Éà„É¨„Éº„Éã„É≥„Ç∞„Çπ„ÉÜ„Éº„Çø„Çπ„Å´Âü∫„Å•„Åè„Ç≥„É°„É≥„Éà
            if (trainingStatus) {
                comment += `\n\nüìà **„Ç≥„É≥„Éá„Ç£„Ç∑„Éß„É≥Áä∂Ê≥Å**\n`;
                comment += `ÁèæÂú®„ÅÆFitnessÔºàCTLÔºâ„ÅØ${trainingStatus.ctl}„ÄÅFormÔºàTSBÔºâ„ÅØ${trainingStatus.tsb}„Åß„Åô„ÄÇ`;
                
                if (trainingStatus.tsb < -20) {
                    comment += `Áñ≤Âä¥„ÅåËìÑÁ©ç„Åó„Å¶„ÅÑ„Åæ„Åô„ÄÇ1-2Êó•„ÅÆ‰ºëÊÅØ„ÇíÂÖ•„Çå„Å¶„ÄÅ„Ç™„Éº„Éê„Éº„Éà„É¨„Éº„Éã„É≥„Ç∞„ÇíÈò≤„Åé„Åæ„Åó„Çá„ÅÜ„ÄÇ`;
                } else if (trainingStatus.tsb < -10) {
                    comment += `ÈÅ©Â∫¶„Å™Ë≤†Ëç∑Áä∂ÊÖã„Åß„Åô„ÄÇ„Åì„ÅÆ„Åæ„Åæ„Éà„É¨„Éº„Éã„É≥„Ç∞„ÇíÁ∂ôÁ∂ö„Åó„Å§„Å§„ÄÅÂõûÂæ©„Å´„ÇÇÊ∞ó„ÇíÈÖç„Çä„Åæ„Åó„Çá„ÅÜ„ÄÇ`;
                } else if (trainingStatus.tsb > 15) {
                    comment += `„Éï„É¨„ÉÉ„Ç∑„É•„Å™Áä∂ÊÖã„Åß„ÅôÔºÅË≥™„ÅÆÈ´ò„ÅÑ„Ç≠„Éº„ÉØ„Éº„ÇØ„Ç¢„Ç¶„Éà„Å´ÊåëÊà¶„Åô„ÇãÁµ∂Â•Ω„ÅÆ„Çø„Ç§„Éü„É≥„Ç∞„Åß„Åô„ÄÇ`;
                } else {
                    comment += `„Éê„É©„É≥„Çπ„ÅÆÂèñ„Çå„ÅüÁä∂ÊÖã„Åß„Åô„ÄÇË®àÁîªÈÄö„Çä„ÅÆ„Éà„É¨„Éº„Éã„É≥„Ç∞„ÇíÁ∂ôÁ∂ö„Åó„Åæ„Åó„Çá„ÅÜ„ÄÇ`;
                }
            }
            
            return comment;
        }
        
        async function askQuestion() {
            const input = document.getElementById('questionInput');
            const btn = document.getElementById('askBtn');
            const question = input.value.trim();
            
            if (!question) return;
            
            // Ë≥™Âïè„ÇíÂ±•Ê≠¥„Å´ËøΩÂä†
            addChatMessage('user', question);
            input.value = '';
            btn.disabled = true;
            btn.textContent = 'ÈÄÅ‰ø°‰∏≠...';
            
            // Â±•Ê≠¥„ÇíË°®Á§∫
            document.getElementById('chatHistory').style.display = 'block';
            
            await fetchAIComment(question);
            
            btn.disabled = false;
            btn.textContent = 'Ë≥™Âïè„Åô„Çã';
        }
        
        function addChatMessage(type, content) {
            const historyEl = document.getElementById('chatHistory');
            const label = type === 'user' ? 'üë§ „ÅÇ„Å™„Åü' : 'ü§ñ AI„Ç≥„Éº„ÉÅ';
            
            // „Ç≥„Éº„ÉÅ„ÅÆÂõûÁ≠î„ÅØMarkdown„Éï„Ç©„Éº„Éû„ÉÉ„Éà„ÇíÈÅ©Áî®
            const formattedContent = type === 'coach' ? formatAIComment(content) : content;
            
            const messageHtml = `
                <div class="chat-message ${type}">
                    <div class="chat-message-label">${label}</div>
                    <div class="chat-message-content">${formattedContent}</div>
                </div>
            `;
            
            historyEl.insertAdjacentHTML('beforeend', messageHtml);
            historyEl.scrollTop = historyEl.scrollHeight;
        }
        
        // Enter„Ç≠„Éº„ÅßÈÄÅ‰ø°
        document.getElementById('questionInput')?.addEventListener('keypress', (e) => {
            if (e.key === 'Enter') askQuestion();
        });
        
        // ===== „É¶„Éº„ÉÜ„Ç£„É™„ÉÜ„Ç£ =====
        function getUserThresholds() {
            const saved = localStorage.getItem('user_thresholds');
            if (saved) {
                try {
                    return JSON.parse(saved);
                } catch (e) {}
            }
            return { ftp: 200, rFtpPacePerKm: 300, sFtpPacePer100m: 100, maxHr: 190, thresholdHr: 170 };
        }
        
        function getSportCategory(sportType) {
            const swim = ['Swim'];
            const bike = ['Ride', 'VirtualRide', 'EBikeRide'];
            const run = ['Run', 'TrailRun', 'VirtualRun'];
            
            if (swim.includes(sportType)) return 'swim';
            if (bike.includes(sportType)) return 'bike';
            if (run.includes(sportType)) return 'run';
            return 'other';
        }
        
        function getSportLabel(sportType) {
            const labels = {
                'Run': '„É©„É≥', 'TrailRun': '„Éà„É¨„Ç§„É´', 'VirtualRun': '„Éê„Éº„ÉÅ„É£„É´„É©„É≥',
                'Ride': '„Éê„Ç§„ÇØ', 'VirtualRide': '„Éê„Éº„ÉÅ„É£„É´„É©„Ç§„Éâ', 'EBikeRide': 'E-Bike',
                'Swim': '„Çπ„Ç§„É†', 'WeightTraining': '„Ç¶„Çß„Ç§„Éà', 'Yoga': '„É®„Ç¨'
            };
            return labels[sportType] || sportType;
        }
        
        function getActivityIcon(sportType) {
            const icons = {
                'Run': 'üèÉ‚Äç‚ôÇÔ∏è', 'TrailRun': 'üèîÔ∏è', 'VirtualRun': 'üèÉ‚Äç‚ôÇÔ∏è',
                'Ride': 'üö¥‚Äç‚ôÇÔ∏è', 'VirtualRide': 'üö¥‚Äç‚ôÇÔ∏è', 'EBikeRide': 'üö¥‚Äç‚ôÇÔ∏è',
                'Swim': 'üèä‚Äç‚ôÇÔ∏è', 'WeightTraining': 'üèãÔ∏è‚Äç‚ôÇÔ∏è', 'Yoga': 'üßò‚Äç‚ôÇÔ∏è'
            };
            return icons[sportType] || 'üèÉ‚Äç‚ôÇÔ∏è';
        }
        
        function formatDuration(seconds) {
            if (!seconds) return '0:00';
            const h = Math.floor(seconds / 3600);
            const m = Math.floor((seconds % 3600) / 60);
            const s = Math.floor(seconds % 60);
            
            if (h > 0) {
                return `${h}:${String(m).padStart(2, '0')}:${String(s).padStart(2, '0')}`;
            }
            return `${m}:${String(s).padStart(2, '0')}`;
        }
        
        function formatDurationShort(seconds) {
            if (!seconds) return '0:00';
            const m = Math.floor(seconds / 60);
            const s = Math.floor(seconds % 60);
            return `${m}:${String(s).padStart(2, '0')}`;
        }
        
        function formatRunPace(avgSpeed) {
            if (!avgSpeed || avgSpeed <= 0) return '-';
            const pace = 1000 / avgSpeed;
            const min = Math.floor(pace / 60);
            const sec = Math.round(pace % 60);
            return `${min}:${String(sec).padStart(2, '0')}`;
        }
        
        function formatSwimPace(avgSpeed) {
            if (!avgSpeed || avgSpeed <= 0) return '-';
            const pace = 100 / avgSpeed;
            const min = Math.floor(pace / 60);
            const sec = Math.round(pace % 60);
            return `${min}:${String(sec).padStart(2, '0')}`;
        }
        
        function showError(message) {
            document.getElementById('loadingSection').style.display = 'none';
            document.getElementById('errorSection').style.display = 'block';
            document.getElementById('errorMessage').textContent = message;
        }
        
        function goBackToData() {
            window.location.href = 'data.html';
        }
    </script>
</body>
</html>
